
; ******** Source: lcd12864gallery.asm
     1                          ; Troy's HBC-56 - LCD picture gallery
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;

; ******** Source: ../../kernel\hbc56kernel.inc
     1                          ; 6502 - HBC-56 Kernel Include file for user code
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          ;
    10                          
    11                          !cpu w65c02
    12                          !initmem $FF
    13                          cputype = $65c02
    14                          

; ******** Source: ../../kernel\kernel.o.lmap
     1                          	HBC56_RST_VECTOR	= $f1a1	; ?
     2                          	AY_ENV_SHAPE_SAW1	= $8	; unused
     3                          	NES_RAM_SIZE	= $1
     4                          	UART_ZP_START	= $26
     5                          	UART_STATUS_RCVR_OVERRUN	= $20	; unused
     6                          	HBC56_TMP	= $7c99
     7                          	lcdDisplayOff	= $e60b	; ?
     8                          	TILEMAP_SIZE	= $1
     9                          	KB_SCANCODE_ESC	= $76	; unused
    10                          	AY_ENV_SHAPE_SAW2	= $c	; unused
    11                          	TILEMAP_TMP_OUTPUT_ROW	= $7a83
    12                          	lcdCurrentLine	= $e73f	; ?
    13                          	LCD_RAM_END	= $7b50
    14                          	LCD_ZP_SIZE	= $2
    15                          	LCD_EXTENDED	= $3c	; ?
    16                          	KB_SCANCODE_ARROW_RIGHT	= $f4	; unused
    17                          	LCD_CMD_SHIFT_DISPLAY	= $8	; unused
    18                          	KB_CAPS_LOCK	= $8
    19                          	KB_EXT_KEY	= $e0
    20                          	HBC56_VSYNC_CALLBACK	= $7cb0
    21                          	isLower	= $e000
    22                          	bitmapLineH	= $e2f6
    23                          	KB_BUFFER_MASK	= $f
    24                          	KB_SCANCODE_SLASH_FORWARD	= $4a	; unused
    25                          	AY_PORTB	= $f	; unused
    26                          	lcdLineFour	= $e804	; ?
    27                          	lcdConsolePrint	= $e8bb	; unused
    28                          	AY_PORTA	= $e	; unused
    29                          	lcdLineThreeEnd	= $e795	; ?
    30                          	kbInit	= $ead1
    31                          	START_BYTE	= $7b1f
    32                          	UART_IRQ_BIT	= $4
    33                          	bitmapLineV	= $e387
    34                          	_bitmapLineWide	= $e417	; ?
    35                          	lcdCharScroll	= $e66d
    36                          	LCD_CMD_SET_CGRAM_ADDR	= $40	; unused
    37                          	UART_STATUS_RX_REG_FULL	= $1
    38                          	BITMAP_ZP_START	= $1e
    39                          	BITMAP_LINE_STYLE_ODD	= $7b1e
    40                          	END_BYTE	= $7b20
    41                          	JMP_OPCODE	= $4c
    42                          	hbc56IntHandler	= $f185
    43                          	TILEMAP_RAM_START	= $7a00
    44                          	KB_SCANCODE_SCROLL_LOCK	= $7e	; unused
    45                          	KB_RAM_END	= $7c93
    46                          	AY_ENV_SHAPE_HOLD	= $1
    47                          	TILEMAP_ADDR	= $18
    48                          	TILEMAP_SIZE_Y_8	= $0
    49                          	KB_SHIFT_LEFT_MAP_BYTE	= $2
    50                          	MEMORY_ZP_END	= $30
    51                          	BITMAP_X	= $7b17
    52                          	BITMAP_Y	= $7b18
    53                          	KB_SCANCODE_PRTSCR	= $92	; unused
    54                          	LCD_BASIC	= $38	; ?	; unused
    55                          	KB_SCANCODE_SLASH_BACK	= $5d	; unused
    56                          	TILEMAP_SIZE_X_64	= $2
    57                          	AY_WRITE	= $1
    58                          	UART_STATUS_CARRIER_DETECT	= $4	; unused
    59                          	KB_PRESSED_MAP	= $7c6d
    60                          	TMS9918_ZP_START	= $24
    61                          	UART_CTL_WORD_8BIT_1SB	= $14	; unused
    62                          	HBC56_CONSOLE_FLAG_LCD	= $20	; unused
    63                          	ASCII_NEWLINE	= $a
    64                          	HBC56_TITLE	= $ed8a	; unused
    65                          	memcpyMultiPage	= $e0bf	; unused
    66                          	LCD_ROWS	= $4
    67                          	KB_SCANCODE_NUM_LOCK	= $77	; unused
    68                          	TILEMAP_RAM_END	= $7b16
    69                          	lcdGraphicsMode	= $e51a
    70                          	TILEMAP_ZP_SIZE	= $6
    71                          	lcdPrint	= $e64a
    72                          	KB_BUFFER_TAIL	= $7c5c
    73                          	lcdGotoLineEnd	= $e742	; ?
    74                          	KB_SCANCODE_NUMPAD_ENTER	= $da	; unused
    75                          	TILEMAP_FIXED_ADDRESS	= $7b00
    76                          	UART_STATUS_TX_REG_EMPTY	= $2
    77                          	UART_RX_BUFFER_XOFF_SIZE	= $c0
    78                          	KB_FLAGS	= $7c53
    79                          	lcdGotoLine	= $e7d9	; ?
    80                          	HBC56_NMI_VECTOR	= $7e04
    81                          	KB_SCANCODE_SQUARE_LEFT	= $54	; unused
    82                          	LCD_CMD_SHIFT_CURSOR	= $0	; unused
    83                          	lcdRead	= $e643
    84                          	BITMAP_ZP_END	= $24
    85                          	lcdLineOne	= $e7ec	; ?
    86                          	UART_CTL_CLOCK_DIV_64	= $2
    87                          	toUpper	= $e06b	; unused
    88                          	LCD_CMD_ENTRY_MODE	= $4	; unused
    89                          	NES_TMP	= $7c93	; unused
    90                          	HBC56_META_TITLE_END	= $7cae
    91                          	uartFlowCtrlXoff	= $ea5a	; ?
    92                          	SFXMAN_RAM_START	= $7c50
    93                          	uartInWait	= $ea63
    94                          	uartOutString	= $eaa7	; unused
    95                          	RTI_OPCODE	= $40
    96                          	KB_SCANCODE_PAGE_UP	= $fd	; unused
    97                          	AY_ENV_SHAPE_FADE_OUT	= $9	; unused
    98                          	LINE_WIDTH	= $7b1f
    99                          	lcdReadLine	= $e82b
   100                          	LCD_CMD_SET_DRAM_ADDR	= $80
   101                          	NOTE_FREQ_AS8	= 7458.619999999999890860635787248611	; unused
   102                          	HBC56_TMP_Y	= $7c9c	; unused
   103                          	KB_SCANCODE_TILDE	= $e	; unused
   104                          	HBC56_TITLE_LEN	= $1a	; unused
   105                          	UART_IO_PORT	= $20
   106                          	TMS9918_RAM_END	= $7b26
   107                          	AY_S0_ADDR	= $7f40	; unused
   108                          	HBC56_TMP_X	= $7c9b	; unused
   109                          	NOTE_FREQ_AS5	= 932.330000000000040927261579781771	; unused
   110                          	LCD_CMD_DISPLAY_CURSOR_BLINK	= $1
   111                          	LCD_ADDR_LINE2	= $10
   112                          	KB_SCANCODE_WINDOWS_RIGHT	= $a7	; unused
   113                          	HBC56_KERNEL_ZP_END	= $34
   114                          	AY_S1_WRITE	= $7f45	; unused
   115                          	NOTE_FREQ_AS4	= 466.160000000000025011104298755527	; unused
   116                          	LCD_CMD_SHIFT	= $10
   117                          	LCD_ADDR_LINE3	= $8
   118                          	NOTE_FREQ_AS7	= 3729.309999999999945430317893624306	; unused
   119                          	KB_SCANCODE_PERIOD	= $49	; unused
   120                          	tableBitFromLeft	= $e130
   121                          	NOTE_FREQ_AS6	= 1864.660000000000081854523159563541	; unused
   122                          	LCD_ADDR_LINE1	= $0
   123                          	AY_NOISE_GEN	= $6	; unused
   124                          	NOTE_FREQ_AS1	= 58.270000000000003126388037344441	; unused
   125                          	BITMAP_X2	= $7b19
   126                          	AY_S0_WRITE	= $7f41	; unused
   127                          	NOTE_FREQ_AS0	= 29.140000000000000568434188608080	; unused
   128                          	NOTE_FREQ_AS3	= 233.080000000000012505552149377763	; unused
   129                          	LCD_CMD_CLEAR	= $1
   130                          	UART_RX_BUFFER_TAIL	= $27
   131                          	LCD_ADDR_LINE4	= $18
   132                          	AY_S1_ADDR	= $7f44	; unused
   133                          	NOTE_FREQ_AS2	= 116.540000000000006252776074688882	; unused
   134                          	BITMAP_X1	= $7b17
   135                          	UART_RX_BUFFER	= $7b50
   136                          	KB_SCANCODE_NUMPAD_MULTIPLY	= $7c	; unused
   137                          	HBC56_DISABLE_SFXMAN	= $1
   138                          	D	= $7b24
   139                          	LCD_GRAPHICS	= $1
   140                          	LCD_IO_PORT	= $2
   141                          	KB_SCANCODE_CTRL_RIGHT	= $94	; unused
   142                          	HAVE_GRAPHICS_LCD	= $1
   143                          	KB_BUFFER_SIZE	= $10
   144                          	KB_SCANCODE_COMMA	= $41	; unused
   145                          	HBC56_TITLE_TEXT	= $ed8a
   146                          	AY_R10	= $a
   147                          	BITMAP_TMP1	= $7b1f
   148                          	LCD_CMD_12864B_EXTENDED	= $4
   149                          	AY_IO_PORT	= $40
   150                          	AY_R11	= $b
   151                          	NES_LEFT	= $2	; unused
   152                          	AY_R12	= $c
   153                          	LCD_RAM_SIZE	= $2a
   154                          	KB_NUM_LOCK	= $10	; unused
   155                          	BITMAP_TMP3	= $7b21
   156                          	kernelMain	= $f1a1	; ?
   157                          	AY_R13	= $d
   158                          	BITMAP_TMP2	= $7b20
   159                          	tilemapSetActive	= $e940	; ?
   160                          	ASCII_CR	= $d
   161                          	AY_R14	= $e
   162                          	KB_SCANCODE_PAGE_DOWN	= $fa	; unused
   163                          	BITMAP_TMP5	= $7b23
   164                          	kbIntHandler	= $eb0c
   165                          	IO_PORT_BASE_ADDRESS	= $7f00
   166                          	AY_R15	= $f
   167                          	BITMAP_TMP4	= $7b22
   168                          	isDigit	= $e01e
   169                          	AY_R16	= $10	; unused
   170                          	UART_CTL_MASTER_RESET	= $3
   171                          	AY_R17	= $11	; unused
   172                          	BITMAP_TMP6	= $7b24
   173                          	KB_SCANCODE_TAB	= $d	; unused
   174                          	HBC56_KERNEL_ZP_START	= $18
   175                          	TMS9918_IRQ_BIT	= $1	; unused
   176                          	lcdTextMode	= $e52b
   177                          	lcdNextLine2	= $e81e	; unused
   178                          	LCD_CMD_DISPLAY_CURSOR	= $2
   179                          	lcdClear	= $e5f0	; ?
   180                          	lcdNextLine4	= $e80c
   181                          	HBC56_CONSOLE_FLAG_NOWAIT	= $10
   182                          	lcdGraphicsSetRow	= $e53c
   183                          	KB_SCANCODE_ENTER	= $5a	; unused
   184                          	KB_IO_PORT	= $80
   185                          	AY_ENV_SHAPE_ATTACK	= $4
   186                          	UART_STATUS_IRQ	= $80	; unused
   187                          	X	= $7b21
   188                          	TILEMAP_INVERT_ADDR	= $3
   189                          	NES_DOWN	= $4	; unused
   190                          	Y	= $7b21
   191                          	NES_SELECT	= $20	; unused
   192                          	LCD_CMD_ENTRY_MODE_SHIFT	= $1	; unused
   193                          	TILEMAP_RAM_SIZE	= $107
   194                          	hbc56Stop	= $f2e3
   195                          	lcdChar	= $e666
   196                          	lcdInt8	= $e6be	; unused
   197                          	UART_RX_BUFFER_SIZE	= $100
   198                          	KB_BUFFER	= $7c5d
   199                          	DEFAULT_HBC56_NMI_VECTOR	= $ffe0	; unused
   200                          	COL_BYTE	= $7b1f
   201                          	HAVE_TILEMAP	= $1	; unused
   202                          	TILEMAP_HEIGHT_TILES	= $6
   203                          	NES1_IO_ADDR	= $7f82
   204                          	lcdDetect	= $e62f
   205                          	UART_CTL_WORD_7BIT_OPB_1SB	= $c	; unused
   206                          	KB_SCANCODE_NUMPAD_PLUS	= $79	; unused
   207                          	NES2_IO_ADDR	= $7f83
   208                          	BITMAP_RAM_END	= $7b26
   209                          	BITMAP_ZP_SIZE	= $4
   210                          	KB_SCANCODE_F2	= $6	; unused
   211                          	lcdCursorBlinkOn	= $e626	; unused
   212                          	HBC56_TITLE_TEXT_LEN	= $1a
   213                          	lcdConsoleOut	= $e895
   214                          	NES_UP	= $8	; unused
   215                          	KB_SCANCODE_F3	= $4	; unused
   216                          	DELAY_L	= $32
   217                          	ASCII_BACKSPACE	= $8
   218                          	KB_SCANCODE_F1	= $5	; unused
   219                          	KB_SCANCODE_SEMICOLON	= $4c	; unused
   220                          	c	= $20
   221                          	KB_SCANCODE_F6	= $b	; unused
   222                          	KB_SCANCODE_F7	= $83	; unused
   223                          	KB_SCANCODE_HOME	= $ec	; unused
   224                          	DELAY_H	= $33
   225                          	KB_SCANCODE_F4	= $c	; unused
   226                          	uartInNoWait	= $ea6d	; unused
   227                          	hbc56Reset	= $f2e0	; unused
   228                          	KB_SCANCODE_F5	= $3	; unused
   229                          	hbc56CustomDelayMs	= $f2e6	; unused
   230                          	lcdLineThree	= $e7fc	; ?
   231                          	uartOut	= $ea90	; ?
   232                          	KB_TMP_X	= $7c54
   233                          	KB_SCANCODE_F8	= $a	; unused
   234                          	hbc56LogoLcd	= $f000
   235                          	HBC56_KERNEL_RAM_START	= $7a00
   236                          	KB_TMP_Y	= $7c55	; unused
   237                          	KB_SCANCODE_F9	= $1	; unused
   238                          	lcdLineTwo	= $e7f4	; ?
   239                          	TILEMAP_BUFFER_ADDR	= $0
   240                          	uartIrq	= $ea2b
   241                          	HAVE_LCD	= $1
   242                          	TILEMAP_WIDTH_TILES	= $5
   243                          	HBC56_META_TITLE	= $7c9d
   244                          	KB_SCANCODE_SQUARE_RIGHT	= $5b	; unused
   245                          	LCD_CMD_8BITMODE	= $10
   246                          	AY_S1	= $7f44
   247                          	NOTE_FREQ_C8	= 4186.010000000000218278728425502777	; unused
   248                          	KB_IRQ_BIT	= $2
   249                          	AY_S0	= $7f40
   250                          	NOTE_FREQ_A8	= $1b80	; unused
   251                          	HBC56_TICKS	= $7c96
   252                          	HBC56_SECONDS_H	= $7c98
   253                          	memcpySinglePage	= $e0a3	; unused
   254                          	NOTE_FREQ_G8	= 6271.930000000000291038304567337036	; unused
   255                          	AY_ADDR	= $0
   256                          	NOTE_FREQ_E8	= 5274.039999999999963620211929082870	; unused
   257                          	AY_ENV_SHAPE_ALTERNATE	= $2
   258                          	NOTE_FREQ_DS8	= 4978.029999999999745341483503580093	; unused
   259                          	TILEMAP_TMP_BUFFER_ADDR	= $1a
   260                          	NES_B	= $40	; unused
   261                          	HBC56_SECONDS_L	= $7c97
   262                          	AY_PSG1	= $4
   263                          	UART_CTL_WORD_7BIT_EPB_1SB	= $8	; unused
   264                          	NES_A	= $80	; unused
   265                          	LCD_COLUMNS	= $10
   266                          	TMS9918_IO_PORT	= $10	; unused
   267                          	UART_RAM_END	= $7c50
   268                          	AY_PSG0	= $0
   269                          	UART_FLOWCTRL_XON	= $11
   270                          	LCD_CMD_FUNCTIONSET	= $20
   271                          	DEFAULT_HBC56_RST_VECTOR	= $8000
   272                          	NOTE_FREQ_C0	= 16.350000000000001421085471520200	; unused
   273                          	NOTE_FREQ_A1	= $37	; unused
   274                          	NOTE_FREQ_G2	= $62	; unused
   275                          	NOTE_FREQ_E3	= 164.810000000000002273736754432321
   276                          	NOTE_FREQ_DS4	= 311.129999999999995452526491135359	; unused
   277                          	KB_SCANCODE_CTRL_LEFT	= $14	; unused
   278                          	lcdImageVflip	= $e597	; unused
   279                          	TILE_SIZE	= $8	; unused
   280                          	NOTE_FREQ_A0	= 27.500000000000000000000000000000	; unused
   281                          	NOTE_FREQ_E2	= 82.409999999999996589394868351519	; unused
   282                          	NOTE_FREQ_DS5	= 622.250000000000000000000000000000	; unused
   283                          	LCD_CMD_HOME	= $2
   284                          	UART_STATUS_CLEAR_TO_SEND	= $8	; unused
   285                          	NOTE_FREQ_G3	= $c4	; unused
   286                          	NOTE_FREQ_C1	= 32.700000000000002842170943040401	; unused
   287                          	NOTE_FREQ_G0	= 24.500000000000000000000000000000	; unused
   288                          	NOTE_FREQ_E1	= 41.200000000000002842170943040401	; unused
   289                          	NOTE_FREQ_DS6	= 1244.509999999999990905052982270718	; unused
   290                          	UART_DATA	= $7f21
   291                          	NOTE_FREQ_C2	= 65.409999999999996589394868351519	; unused
   292                          	NOTE_FREQ_A3	= $dc	; unused
   293                          	NOTE_FREQ_E0	= 20.600000000000001421085471520200	; unused
   294                          	NOTE_FREQ_DS7	= 2489.019999999999981810105964541435	; unused
   295                          	NOTE_FREQ_G1	= $31	; unused
   296                          	NOTE_FREQ_A2	= $6e	; unused
   297                          	NOTE_FREQ_C3	= 130.810000000000002273736754432321	; unused
   298                          	UART_ZP_END	= $2a
   299                          	NOTE_FREQ_DS0	= 19.449999999999999289457264239900	; unused
   300                          	NOTE_FREQ_C4	= 261.629999999999995452526491135359	; unused
   301                          	NOTE_FREQ_A5	= $370	; unused
   302                          	NOTE_FREQ_G6	= 1567.980000000000018189894035458565	; unused
   303                          	NOTE_FREQ_E7	= 2637.019999999999981810105964541435	; unused
   304                          	NOTE_FREQ_DS1	= 38.890000000000000568434188608080	; unused
   305                          	HAVE_KEYBOARD	= $1
   306                          	NOTE_FREQ_A4	= $1b8	; unused
   307                          	NOTE_FREQ_E6	= 1318.509999999999990905052982270718	; unused
   308                          	_bitmapLineTall	= $e468	; ?
   309                          	hbc56HighBell	= $f261	; ?
   310                          	NOTE_FREQ_G7	= 3135.960000000000036379788070917130	; unused
   311                          	NOTE_FREQ_C5	= 523.250000000000000000000000000000	; unused
   312                          	_bitmapOffset	= $e2a8
   313                          	NOTE_FREQ_DS2	= 77.780000000000001136868377216160	; unused
   314                          	NOTE_FREQ_G4	= $188	; unused
   315                          	NOTE_FREQ_E5	= 659.250000000000000000000000000000	; unused
   316                          	NOTE_FREQ_C6	= 1046.500000000000000000000000000000	; unused
   317                          	NOTE_FREQ_A7	= $dc0	; unused
   318                          	BCD_RAM_START	= $7c50
   319                          	HBC56_META_TITLE_MAX_LEN	= $10
   320                          	isDigitX	= $e030	; unused
   321                          	NOTE_FREQ_DS3	= 155.560000000000002273736754432321	; unused
   322                          	NOTE_FREQ_E4	= 329.629999999999995452526491135359	; unused
   323                          	NOTE_FREQ_G5	= 783.990000000000009094947017729282	; unused
   324                          	NOTE_FREQ_A6	= $6e0	; unused
   325                          	NOTE_FREQ_C7	= $82d	; unused
   326                          	AY_INACTIVE	= $3	; unused
   327                          	KB_SCANCODE_F11	= $78	; unused
   328                          	AY_S0_READ	= $7f42	; unused
   329                          	LCD_TMP2	= $25
   330                          	lcdCursorOn	= $e614	; unused
   331                          	KB_SCANCODE_F10	= $9	; unused
   332                          	LCD_TMP1	= $24
   333                          	KB_SCANCODE_NUMPAD_PERIOD	= $71	; unused
   334                          	KB_SCANCODE_F12	= $7	; unused
   335                          	kbNextScancode	= $ec1e
   336                          	lcdBackspace	= $e68a
   337                          	KB_SCANCODE_WINDOWS_LEFT	= $9f	; unused
   338                          	BCD_RAM_END	= $7c53
   339                          	ASCII_RETURN	= $a
   340                          	lcdWaitPreserve	= $e63d
   341                          	TILEMAP_TILES_ADDR	= $2
   342                          	tilemapRenderToLcd	= $e97d	; unused
   343                          	LCD_CMD_DISPLAY	= $8
   344                          	TILEMAP_TMP_TILE_SIZE	= $7a88
   345                          	lcdLineOneEnd	= $e751	; ?
   346                          	bitmapLine	= $e3d0	; unused
   347                          	UART_CTL_WORD_8BIT_OPAR_1SB	= $1c	; unused
   348                          	isSpace	= $e049	; unused
   349                          	hbc56BootScreen	= $f100
   350                          	AY_S1_READ	= $7f46	; unused
   351                          	KB_SCANCODE_END	= $e9	; unused
   352                          	BCD_RAM_SIZE	= $3
   353                          	KB_SCANCODE_SHIFT_RIGHT	= $59
   354                          	TILEMAP_STRUCTURE_SIZE	= $7
   355                          	uartOutNoBsCheck	= $ea96	; ?
   356                          	KB_SCANCODE_ALT_LEFT	= $11	; unused
   357                          	lcdLineTwoEnd	= $e773	; ?
   358                          	HBC56_INT_VECTOR	= $7e00
   359                          	LINE_HEIGHT	= $7b20
   360                          	INT_IO_PORT	= $df
   361                          	KB_PRESSED_MAP_BYTES	= $20
   362                          	STR_ADDR_H	= $31
   363                          	NES_RAM_END	= $7c96
   364                          	memsetSinglePage	= $e101
   365                          	kbWaitForScancode	= $ec12
   366                          	LCD_CMD_SHIFT_LEFT	= $0
   367                          	KB_SCANCODE_APOS	= $52	; unused
   368                          	STR_ADDR_L	= $30
   369                          	KB_SHIFT_RIGHT_MAP_BYTE	= $b
   370                          	AY_CLOCK_FREQ	= $1e8480
   371                          	BITMAP_ADDR_H	= $20
   372                          	UART_RX_BUFFER_XON_SIZE	= $4
   373                          	uartFlowCtrlXon	= $ea4f	; ?
   374                          	TILEMAP_SIZE_X_32	= $1
   375                          	ASCII_BELL	= $7	; unused
   376                          	BCD_TMP3	= $7c52
   377                          	DISPLAY_MODE	= $c
   378                          	UART_CTL_WORD_8BIT_EPAR_1SB	= $18	; unused
   379                          	BCD_TMP2	= $7c51
   380                          	LCD_ZP_END	= $26
   381                          	toLower	= $e073	; unused
   382                          	BCD_TMP1	= $7c50
   383                          	MEM_SRC	= $2c
   384                          	AY_ENABLES	= $7
   385                          	lcdWait	= $e637	; ?
   386                          	UART_CTL_WORD_7BIT_OPB_2SB	= $4	; unused
   387                          	lcdInit	= $e5de
   388                          	LCD_RAM_START	= $7b26
   389                          	TILEMAP_SIZE_X_16	= $0
   390                          	TILEMAP_TMP_TILES_W	= $7a86
   391                          	HAVE_MATH_INC	= $1
   392                          	KB_SCANCODE_B	= $32	; unused
   393                          	hbc56Bell	= $f293	; unused
   394                          	KB_SCANCODE_C	= $21	; unused
   395                          	lcdCursorOff	= $e61d	; unused
   396                          	HBC56_KERNEL_RAM_SIZE	= $2b2	; unused
   397                          	lcdLineFourEnd	= $e7b7	; ?
   398                          	KB_SCANCODE_A	= $1c	; unused
   399                          	KB_PRESSED_MAP_SIZE	= $fe	; unused
   400                          	KB_SCANCODE_F	= $2b	; unused
   401                          	kbIsPressed	= $ebf8	; unused
   402                          	TILEMAP_DIRTY_ADDR	= $4
   403                          	KB_SCANCODE_G	= $34	; unused
   404                          	bitmapClear	= $e269	; unused
   405                          	KB_CB_RELEASED	= $7c58
   406                          	KB_SCANCODE_D	= $23	; unused
   407                          	KB_SCANCODE_E	= $24	; unused
   408                          	TILEMAP_ZP_START	= $18
   409                          	KB_SHIFT_DOWN	= $1	; unused
   410                          	KB_SCANCODE_J	= $3b	; unused
   411                          	KB_CB_PRESSED	= $7c56
   412                          	KB_SCANCODE_K	= $42	; unused
   413                          	KB_SHIFT_RIGHT_MAP_BIT	= $40
   414                          	HBC56_CONSOLE_FLAGS	= $7c9a
   415                          	AY_ENV_SHAPE	= $d
   416                          	LCD_CMD_ENTRY_MODE_DECREMENT	= $0	; unused
   417                          	KB_SCANCODE_H	= $33	; unused
   418                          	kbReadAscii	= $ec7d	; unused
   419                          	KB_BUFFER_HEAD	= $7c5b
   420                          	KB_SCANCODE_I	= $43	; unused
   421                          	KB_SCANCODE_N	= $31	; unused
   422                          	UART_CTL_CLOCK_DIV_16	= $1	; unused
   423                          	nesWaitForPress	= $eab4
   424                          	KB_SCANCODE_O	= $44	; unused
   425                          	memcpyMultiPagePort	= $e0e1	; unused
   426                          	KB_SCANCODE_L	= $4b	; unused
   427                          	bin2bcd8	= $e07b	; unused
   428                          	KB_SCANCODE_M	= $3a	; unused
   429                          	KB_SCANCODE_ARROW_UP	= $f5	; unused
   430                          	lcdCurrentLine2	= $e732	; unused
   431                          	UART_RX_BUFFER_HEAD	= $26
   432                          	KB_SCANCODE_R	= $2d	; unused
   433                          	LCD_CMD_ENTRY_MODE_INCREMENT	= $2	; unused
   434                          	tilemapRenderRowToLcd	= $e956
   435                          	KB_SCANCODE_S	= $1b	; unused
   436                          	hbc56FontLcd	= $ee00
   437                          	KB_SCANCODE_P	= $4d	; unused
   438                          	LCD_CMD_SHIFT_RIGHT	= $4	; unused
   439                          	TILEMAP_TMP_BUF_ROW	= $7a80
   440                          	KB_SCANCODE_Q	= $15	; unused
   441                          	NOTE_FREQ_GS8	= 6644.880000000000109139364212751389	; unused
   442                          	BITMAP_LINE_STYLE	= $7b1d
   443                          	KB_CURRENT_STATE	= $7c5a
   444                          	KB_SCANCODE_V	= $2a	; unused
   445                          	NOTE_FREQ_CS8	= 4434.920000000000072759576141834259	; unused
   446                          	KB_SCANCODE_W	= $1d	; unused
   447                          	HBC56_CONSOLE_FLAG_NES	= $40
   448                          	lcdCurrentLine4	= $e71d
   449                          	UART_CTL_WORD_7BIT_EPB_2SB	= $0	; unused
   450                          	kbScancodeToAscii	= $ec2d
   451                          	LCD_CMD	= $7f02
   452                          	KB_SCANCODE_T	= $2c	; unused
   453                          	KB_SHIFT_LEFT_MAP_BIT	= $20
   454                          	TILEMAP_TMP_TILES_ADDR	= $1c
   455                          	KB_SCANCODE_U	= $3c	; unused
   456                          	SFXMAN_RAM_END	= $7c50
   457                          	NOTE_FREQ_GS4	= 415.300000000000011368683772161603	; unused
   458                          	NOTE_FREQ_CS5	= 554.370000000000004547473508864641	; unused
   459                          	lcdHex8	= $e6f4	; unused
   460                          	KB_SCANCODE_Z	= $1a	; unused
   461                          	LCD_ZP_START	= $24
   462                          	NOTE_FREQ_CS4	= 277.180000000000006821210263296962	; unused
   463                          	NOTE_FREQ_GS5	= 830.610000000000013642420526593924	; unused
   464                          	KB_SCANCODE_MINUS	= $4e	; unused
   465                          	isUpper	= $e00c
   466                          	UART_IRQ	= $3
   467                          	NES_RAM_START	= $7c93
   468                          	LCD_CMD_2LINE	= $8
   469                          	NOTE_FREQ_GS6	= 1661.220000000000027284841053187847	; unused
   470                          	NOTE_FREQ_CS7	= 2217.460000000000036379788070917130	; unused
   471                          	KB_SCANCODE_X	= $22	; unused
   472                          	KB_SCANCODE_PAUSE	= $e1
   473                          	KB_IO_ADDR	= $7f80
   474                          	TILEMAP_SIZE_Y_32	= $8
   475                          	memcpySinglePagePort	= $e0b1	; unused
   476                          	NOTE_FREQ_CS6	= 1108.730000000000018189894035458565	; unused
   477                          	NOTE_FREQ_GS7	= 3322.440000000000054569682106375694	; unused
   478                          	KB_SCANCODE_Y	= $35	; unused
   479                          	NOTE_FREQ_GS0	= 25.960000000000000852651282912120	; unused
   480                          	NOTE_FREQ_CS1	= 34.649999999999998578914528479800	; unused
   481                          	HAVE_BITMAP	= $1	; unused
   482                          	BITMAP_Y2	= $7b1a
   483                          	bitmapFilledRect	= $e4e2	; unused
   484                          	HBC56_USER_ZP_START	= $34	; unused
   485                          	NOTE_FREQ_CS0	= 17.320000000000000284217094304040	; unused
   486                          	NOTE_FREQ_GS1	= 51.909999999999996589394868351519	; unused
   487                          	LCD_CMD_EXT_GRAPHICS_ENABLE	= $2
   488                          	UART_CTL_RX_INT_ENABLE	= $80
   489                          	KB_SCANCODE_CAPS_LOCK	= $58
   490                          	tableInvBitFromRight	= $e148	; unused
   491                          	TMS9918_IRQ	= $1
   492                          	HBC56_CONSOLE_FLAG_CURSOR	= $80	; unused
   493                          	NOTE_FREQ_GS2	= 103.829999999999998294697434175760	; unused
   494                          	NOTE_FREQ_CS3	= 138.590000000000003410605131648481	; unused
   495                          	NOTE_FREQ_CS2	= 69.299999999999997157829056959599	; unused
   496                          	NOTE_FREQ_GS3	= 207.650000000000005684341886080801	; unused
   497                          	BITMAP_Y1	= $7b18
   498                          	TILEMAP_TMP_TILES_H	= $7a87
   499                          	TILEMAP_SIZE_Y_16	= $4
   500                          	KB_IRQ	= $2
   501                          	VIA_IO_PORT	= $f0	; unused
   502                          	KB_SCANCODE_NUMPAD_5	= $73	; unused
   503                          	AY_CHA	= $0
   504                          	lcdImage	= $e557
   505                          	KB_SCANCODE_ALT_RIGHT_	= $91	; unused
   506                          	bitmapFill	= $e270	; unused
   507                          	bitmapXor	= $e28d	; unused
   508                          	KB_SCANCODE_NUMPAD_4	= $6b	; unused
   509                          	HBC56_DISABLE_TMS9918	= $1
   510                          	AY_CHB	= $1
   511                          	lcdNextLine	= $e828	; ?
   512                          	KB_RAM_SIZE	= $3a
   513                          	lcdDisplayOn	= $e602
   514                          	KB_SCANCODE_NUMPAD_7	= $6c	; unused
   515                          	UART_RAM_START	= $7b50
   516                          	AY_CHC	= $2
   517                          	KB_SCANCODE_NUMPAD_6	= $74	; unused
   518                          	MEMORY_ZP_SIZE	= $6
   519                          	tilemapInit	= $e8c8
   520                          	KB_SCANCODE_NUMPAD_1	= $69	; unused
   521                          	KEY_MAP_SHIFTED	= $ed0a	; ?
   522                          	AY_READ	= $2
   523                          	KB_SCANCODE_NUMPAD_0	= $70	; unused
   524                          	KB_SCANCODE_NUMPAD_3	= $7a	; unused
   525                          	VIA_IRQ	= $5	; unused
   526                          	tableBitFromRight	= $e140	; unused
   527                          	KB_SCANCODE_NUMPAD_2	= $72	; unused
   528                          	KB_SCANCODE_NUMPAD_MINUS	= $7b	; unused
   529                          	BITMAP_RAM_START	= $7b16
   530                          	TILEMAP_TMP_TILE_ROW	= $7a82
   531                          	uartInit	= $ea0f	; unused
   532                          	hbc56CustomDelay	= $ffe3
   533                          	UART_STATUS_FRAMING_ERROR	= $10	; unused
   534                          	AY_ENV_SHAPE_FADE_IN_STOP	= $4	; unused
   535                          	HAVE_UART	= $1
   536                          	MEM_DST	= $2a
   537                          	TILEMAP_TMP_2	= $7a85
   538                          	UART_STATUS_PARITY_ERROR	= $40	; unused
   539                          	lcdScrollUp	= $e83c	; ?
   540                          	KB_SCANCODE_NUMPAD_9	= $7d	; unused
   541                          	LCD_INITIALIZE	= $38	; ?
   542                          	KB_SCANCODE_NUMPAD_8	= $75	; unused
   543                          	AY_CHN	= $3	; unused
   544                          	AY_ENV_SHAPE_TRIANGLE	= $e	; unused
   545                          	hbc56Delay	= $ffe1
   546                          	tableInvBitFromLeft	= $e138
   547                          	TILEMAP_TMP_1	= $7a84
   548                          	STYLE_BYTE	= $7b20
   549                          	KB_SCANCODE_2	= $1e	; unused
   550                          	AY_CHB_TONE_H	= $3	; unused
   551                          	KB_SCANCODE_3	= $26	; unused
   552                          	kbResetCallbacks	= $eafb	; unused
   553                          	NES_IO_PORT	= $82
   554                          	KB_SCANCODE_0	= $45	; unused
   555                          	TMS9918_RAM_START	= $7b26
   556                          	AY_CHA_TONE_L	= $0
   557                          	AY_CHC_TONE_H	= $5	; unused
   558                          	AY_ENV_SHAPE_CONTINUE	= $8
   559                          	KB_SCANCODE_1	= $16	; unused
   560                          	HBC56_META_VECTOR	= $dffc
   561                          	cputype	= $65c02	; unused
   562                          	KB_SCANCODE_6	= $36	; unused
   563                          	HBC56_KERNEL_RAM_END	= $7cb2
   564                          	AY_CHB_TONE_L	= $2	; unused
   565                          	KB_SCANCODE_7	= $3d	; unused
   566                          	AY_ENV_SHAPE_FADE_IN	= $d	; unused
   567                          	KB_SCANCODE_DELETE	= $f1	; unused
   568                          	KB_SCANCODE_4	= $25	; unused
   569                          	KB_SCANCODE_MENU	= $af	; unused
   570                          	KB_SCANCODE_SPACEBAR	= $29	; unused
   571                          	AY_CHA_TONE_H	= $1
   572                          	AY_CHC_TONE_L	= $4	; unused
   573                          	KB_SCANCODE_5	= $2e	; unused
   574                          	MEMORY_ZP_START	= $2a
   575                          	nes1Pressed	= $eac1	; unused
   576                          	INT_CTRL_ADDRESS	= $7fdf
   577                          	STR_ADDR	= $30
   578                          	AY_ENV_PERIOD_H	= $c
   579                          	TILEMAP_ZP_END	= $1e
   580                          	KEY_MAP	= $ec8a	; ?
   581                          	KB_SCANCODE_8	= $3e	; unused
   582                          	KB_RAM_START	= $7c53
   583                          	KB_SCANCODE_9	= $46	; unused
   584                          	TILEMAP_DEFAULT_BUFFER_ADDRESS	= $7a00
   585                          	AY_ENV_PERIOD_L	= $b
   586                          	bitmapClearPixel	= $e2e0	; unused
   587                          	KB_PAUSE_KEY	= $e1
   588                          	KB_CTRL_DOWN	= $2	; unused
   589                          	NES_RIGHT	= $1	; unused
   590                          	nes2Pressed	= $eac9	; unused
   591                          	MEM_LEN	= $2e
   592                          	bitmapRect	= $e4b9	; unused
   593                          	UART_CTL_WORD_8BIT_2SB	= $10
   594                          	NES_START	= $10	; unused
   595                          	HBC56_META_TITLE_LEN	= $7caf
   596                          	memsetMultiPage	= $e10d
   597                          	UART_REG	= $7f20
   598                          	LCD_MODEL	= $3240
   599                          	KB_SCANCODE_SHIFT_LEFT	= $12
   600                          	isAlNum	= $e02a	; unused
   601                          	AY_CHA_AMPL	= $8
   602                          	LAST_MODULE_RAM_END	= $7c96
   603                          	BITMAP_RAM_SIZE	= $10
   604                          	bitmapXorPixel	= $e2eb	; unused
   605                          	KB_SCANCODE_NUMPAD_DIVIDE	= $ca	; unused
   606                          	DEFAULT_HBC56_INT_VECTOR	= $ffe0
   607                          	bitmapSetPixel	= $e2d5
   608                          	KB_SCANCODE_EQUAL	= $55	; unused
   609                          	KB_RELEASE	= $f0
   610                          	LCD_CMD_EXT_GRAPHICS_ADDR	= $80
   611                          	KB_SCANCODE_ARROW_DOWN	= $f2	; unused
   612                          	TILEMAP_TMP_BUF_COL	= $7a81
   613                          	END_OFFSET	= $7b21
   614                          	UART_RX_BUFFER_BYTES	= $28
   615                          	lcdHome	= $e5f9	; ?
   616                          	isAlpha	= $e018
   617                          	ayInit	= $e150
   618                          	LCD_CMD_DISPLAY_ON	= $4
   619                          	UART_RX_FLAGS	= $29
   620                          	AY_R1	= $1
   621                          	NOTE_FREQ_B8	= 7902.130000000000109139364212751389	; unused
   622                          	LCD_DATA	= $7f03
   623                          	KB_STATUS_ADDR	= $7f81
   624                          	AY_R0	= $0
   625                          	AY_R3	= $3
   626                          	NOTE_FREQ_F8	= 5587.649999999999636202119290828705	; unused
   627                          	AY_R2	= $2
   628                          	NOTE_FREQ_D8	= 4698.630000000000109139364212751389	; unused
   629                          	AY_R5	= $5
   630                          	AY_CHC_AMPL	= $a	; unused
   631                          	NOTE_FREQ_FS8	= 5919.909999999999854480847716331482	; unused
   632                          	AY_R4	= $4
   633                          	AY_R7	= $7
   634                          	KB_ALT_DOWN	= $4	; unused
   635                          	AY_R6	= $6
   636                          	AY_R9	= $9
   637                          	NOTE_FREQ_B0	= 30.870000000000000994759830064140	; unused
   638                          	NOTE_FREQ_F2	= 87.310000000000002273736754432321	; unused
   639                          	NOTE_FREQ_D3	= 146.830000000000012505552149377763	; unused
   640                          	NOTE_FREQ_FS4	= 369.990000000000009094947017729282	; unused
   641                          	AY_R8	= $8
   642                          	NOTE_FREQ_B1	= 61.740000000000001989519660128281	; unused
   643                          	NOTE_FREQ_D2	= 73.420000000000001705302565824240	; unused
   644                          	NOTE_FREQ_FS5	= 739.990000000000009094947017729282	; unused
   645                          	UART_FLOWCTRL_XOFF	= $13
   646                          	NOTE_FREQ_F3	= 174.610000000000013642420526593924	; unused
   647                          	NOTE_FREQ_F0	= 21.829999999999998294697434175760	; unused
   648                          	NOTE_FREQ_D1	= 36.710000000000000852651282912120	; unused
   649                          	NOTE_FREQ_FS6	= 1479.980000000000018189894035458565	; unused
   650                          	KB_SCANCODE_ARROW_LEFT	= $eb	; unused
   651                          	NOTE_FREQ_B2	= 123.469999999999998863131622783840	; unused
   652                          	NOTE_FREQ_D0	= 18.350000000000001421085471520200	; unused
   653                          	NOTE_FREQ_FS7	= 2959.960000000000036379788070917130	; unused
   654                          	PIX_ADDR	= $1e
   655                          	NOTE_FREQ_F1	= 43.649999999999998578914528479800	; unused
   656                          	NOTE_FREQ_B3	= 246.939999999999997726263245567679	; unused
   657                          	TILEMAP_TILE_SIZE_PX	= $7
   658                          	HBC56_KERNEL_START	= $e000
   659                          	TMS9918_ZP_END	= $24
   660                          	HAVE_AY3891X	= $1
   661                          	NOTE_FREQ_FS0	= 23.120000000000000994759830064140	; unused
   662                          	AY_CHB_AMPL	= $9	; unused
   663                          	NOTE_FREQ_B4	= 493.879999999999995452526491135359	; unused
   664                          	NOTE_FREQ_F6	= 1396.910000000000081854523159563541	; unused
   665                          	NOTE_FREQ_D7	= 2349.320000000000163709046319127083	; unused
   666                          	NOTE_FREQ_FS1	= 46.250000000000000000000000000000	; unused
   667                          	NOTE_FREQ_B5	= 987.769999999999981810105964541435	; unused
   668                          	NOTE_FREQ_D6	= 1174.660000000000081854523159563541	; unused
   669                          	NOTE_FREQ_F7	= 2793.829999999999927240423858165741	; unused
   670                          	NOTE_FREQ_FS2	= 92.500000000000000000000000000000	; unused
   671                          	NOTE_FREQ_F4	= 349.230000000000018189894035458565	; unused
   672                          	NOTE_FREQ_D5	= 587.330000000000040927261579781771	; unused
   673                          	LOGO_BUFFER	= $3000
   674                          	NOTE_FREQ_B6	= 1975.529999999999972715158946812153	; unused
   675                          	KB_SCANCODE_BACKSPACE	= $66	; unused
   676                          	NOTE_FREQ_FS3	= $b9	; unused
   677                          	NOTE_FREQ_D4	= 293.660000000000025011104298755527	; unused
   678                          	TMP_STYLE	= $7b23
   679                          	NOTE_FREQ_F5	= 698.460000000000036379788070917130
   680                          	NOTE_FREQ_B7	= 3951.070000000000163709046319127083	; unused
   681                          	KB_SCANCODE_INSERT	= $f0	; unused

; ******** Source: ../../kernel\hbc56kernel.inc
    15                          
    16                          

; ******** Source: ../../lib\ut\math.inc
     1                          ; 6502
     2                          ;
     3                          ; Math macros
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/hbc-56
    10                          ;
    11                          ;
    12                          
    13                          HAVE_MATH_INC = 1
    14                          
    15                          !macro lsr2 {
    16                                  lsr
    17                                  lsr
    18                          }
    19                          
    20                          !macro lsr3 {
    21                                  +lsr2
    22                                  lsr
    23                          }
    24                          
    25                          !macro lsr4 {
    26                                  +lsr3
    27                                  lsr
    28                          }
    29                          
    30                          !macro lsr5 {
    31                                  +lsr4
    32                                  lsr
    33                          }
    34                          
    35                          !macro lsr6 {
    36                                  +lsr5
    37                                  lsr
    38                          }
    39                          
    40                          !macro lsr7 {
    41                                  +lsr6
    42                                  lsr
    43                          }
    44                          
    45                          !macro div2   { lsr }
    46                          !macro div4   { +lsr2 }
    47                          !macro div8   { +lsr3 }
    48                          !macro div16  { +lsr4 }
    49                          !macro div32  { +lsr5 }
    50                          !macro div64  { +lsr6 }
    51                          !macro div128 { +lsr7 }
    52                          
    53                          !macro asl2 {
    54                                  asl
    55                                  asl
    56                          }
    57                          
    58                          !macro asl3 {
    59                                  +asl2
    60                                  asl
    61                          }
    62                          
    63                          !macro asl4 {
    64                                  +asl3
    65                                  asl
    66                          }
    67                          
    68                          !macro asl5 {
    69                                  +asl4
    70                                  asl
    71                          }
    72                          
    73                          !macro asl6 {
    74                                  +asl5
    75                                  asl
    76                          }
    77                          
    78                          !macro asl7 {
    79                                  +asl6
    80                                  asl
    81                          }
    82                          
    83                          !macro mul2   { asl }
    84                          !macro mul4   { +asl2 }
    85                          !macro mul8   { +asl3 }
    86                          !macro mul16  { +asl4 }
    87                          !macro mul32  { +asl5 }
    88                          !macro mul64  { +asl6 }
    89                          !macro mul128 { +asl7 }
    90                          
    91                          
    92                          
    93                          ; -----------------------------------------------------------------------------
    94                          ; +dec16: decement a 16-bit value
    95                          ; -----------------------------------------------------------------------------
    96                          ; Inputs:
    97                          ;  addr: address containing LSB of value to decrement
    98                          ; -----------------------------------------------------------------------------
    99                          !macro dec16 .addr {
   100                            lda .addr
   101                            bne +
   102                            dec .addr + 1
   103                          +
   104                            dec .addr
   105                          }
   106                          
   107                          ; -----------------------------------------------------------------------------
   108                          ; +inc16: increment a 16-bit value
   109                          ; -----------------------------------------------------------------------------
   110                          ; Inputs:
   111                          ;  addr: address containing LSB of value to increment
   112                          ; -----------------------------------------------------------------------------
   113                          !macro inc16 .addr {
   114                            inc .addr
   115                            bne +
   116                            inc .addr + 1
   117                          +
   118                          }
   119                          
   120                          ; -----------------------------------------------------------------------------
   121                          ; +cmp16: compare two 16-bit values in memory
   122                          ; -----------------------------------------------------------------------------
   123                          ; Inputs:
   124                          ;  left:  address containing LSB of left value to comapre
   125                          ;  right: address containing LSB of right value to comapre
   126                          ; Outputs:
   127                          ;  C set if right < left
   128                          ;  Z set if right == left
   129                          ; -----------------------------------------------------------------------------
   130                          !macro cmp16 .left, .right {
   131                            lda .left + 1
   132                            cmp .right + 1
   133                          	bne +
   134                          	lda .left
   135                          	cmp .right
   136                          +
   137                          }
   138                          
   139                          ; -----------------------------------------------------------------------------
   140                          ; +cmp16: compare two 16-bit values in memory
   141                          ; -----------------------------------------------------------------------------
   142                          ; Inputs:
   143                          ;  value: immediate value to compare
   144                          ;  x:     msb
   145                          ;  a:     lsb
   146                          ; -----------------------------------------------------------------------------
   147                          !macro cmp16xa .value {
   148                            cpx #>.value
   149                          	bne .doneCmpXa
   150                          	cmp #<.value
   151                          .doneCmpXa
   152                          }
   153                          
   154                          ; -----------------------------------------------------------------------------
   155                          ; +sub16: subtract 16 bit numbers
   156                          ; -----------------------------------------------------------------------------
   157                          ; Inputs:
   158                          ;  left:  address containing LSB of left value
   159                          ;  right: address containing LSB of right value
   160                          ; Outputs:
   161                          ;  res:   address containing LSB of result
   162                          ; -----------------------------------------------------------------------------
   163                          !macro sub16 .left, .right, .res {
   164                            sec
   165                            lda .left
   166                            sbc .right
   167                            sta .res
   168                            lda .left + 1
   169                            sbc .right + 1
   170                            sta .res + 1
   171                          }
   172                          
   173                          ; -----------------------------------------------------------------------------
   174                          ; +sub16: subtract 16 bit numbers - result in ax registers
   175                          ; -----------------------------------------------------------------------------
   176                          ; Inputs:
   177                          ;  left:  address containing LSB of left value
   178                          ;  right: address containing LSB of right value
   179                          ; Outputs:
   180                          ;  a:     result msb
   181                          ;  x:     result lsb
   182                          ; -----------------------------------------------------------------------------
   183                          !macro sub16 .left, .right {
   184                            sec
   185                            lda .left
   186                            sbc .right
   187                            tax
   188                            lda .left + 1
   189                            sbc .right + 1
   190                          }
   191                          
   192                          
   193                          ; -----------------------------------------------------------------------------
   194                          ; +add16: add 16 bit numbers - result in ax registers
   195                          ; -----------------------------------------------------------------------------
   196                          ; Inputs:
   197                          ;  left:  address containing LSB of left value
   198                          ;  right: address containing LSB of right value
   199                          ; Outputs:
   200                          ;  a:     result msb
   201                          ;  x:     result lsb
   202                          ; -----------------------------------------------------------------------------
   203                          !macro add16 .left, .right {
   204                            clc
   205                            lda .left
   206                            adc .right
   207                            tax
   208                            lda .left + 1
   209                            adc .right + 1
   210                          }
   211                          
   212                          
   213                          ; -----------------------------------------------------------------------------
   214                          ; +add16Imm: add 16 bit numbers - result stored to res
   215                          ; -----------------------------------------------------------------------------
   216                          ; Inputs:
   217                          ;  left:  address containing LSB of left value
   218                          ;  imm:   immediate value to add
   219                          ; Outputs:
   220                          ;  res: address to store result
   221                          ; -----------------------------------------------------------------------------
   222                          !macro add16Imm .left, .imm, .res {
   223                            clc
   224                            lda .left
   225                            adc #<.imm
   226                            sta .res
   227                            lda .left + 1
   228                            adc #>.imm
   229                            sta .res + 1
   230                          }
   231                          
   232                          
   233                          ; -----------------------------------------------------------------------------
   234                          ; +subImm8From16: subtract an 8 bit number from a 16 bit number
   235                          ; -----------------------------------------------------------------------------
   236                          ; Inputs:
   237                          ;  left:  address containing LSB of left value
   238                          ;  right: immediate 8-bit value
   239                          ; Outputs:
   240                          ;  res:   address containing LSB of result
   241                          ; -----------------------------------------------------------------------------
   242                          !macro subImm8From16 .left, .right, .res {
   243                            sec
   244                            lda .left
   245                            sbc #.right
   246                            sta .res
   247                            lda .left + 1
   248                            sbc #0
   249                            sta .res + 1
   250                          }
   251                          
   252                          ; -----------------------------------------------------------------------------
   253                          ; +incBcd: increment a BCD byte (inc instruction doesn't work in bcd mode)
   254                          ; -----------------------------------------------------------------------------
   255                          ; Inputs:
   256                          ;  addr:  address containing BCD value
   257                          ; -----------------------------------------------------------------------------
   258                          !macro incBcd .addr {
   259                            lda .addr
   260                            sed
   261                            clc
   262                            adc #1
   263                            cld
   264                            sta .addr
   265                          }
   266                          
   267                          ; -----------------------------------------------------------------------------
   268                          ; +decBcd: decrement a BCD byte (inc instruction doesn't work in bcd mode)
   269                          ; -----------------------------------------------------------------------------
   270                          ; Inputs:
   271                          ;  addr:  address containing BCD value
   272                          ; -----------------------------------------------------------------------------
   273                          !macro decBcd .addr {
   274                            lda .addr
   275                            sed
   276                            sec
   277                            sbc #1
   278                            cld
   279                            sta .addr

; ******** Source: ../../kernel\hbc56kernel.inc
    17                          

; ******** Source: ../../lib\ut\memory.inc
     1                          ; 6502
     2                          ;
     3                          ; Memory subroutines and macros
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/hbc-56
    10                          ;
    11                          ;
    12                          
    13                          ; -----------------------------------------------------------------------------
    14                          ; store16: Write a 16-bit immediate value to memory
    15                          ; -----------------------------------------------------------------------------
    16                          ; Inputs:
    17                          ;	.dst: destination address
    18                          ;	.val16: 16-bit value
    19                          ; -----------------------------------------------------------------------------
    20                          !macro store16 .dst, .val16 {
    21                                  lda #<.val16
    22                                  sta .addr
    23                                  lda #>.val16
    24                                  sta .addr + 1
    25                          }
    26                          
    27                          ; -----------------------------------------------------------------------------
    28                          ; memcpy: Copy a fixed number of bytes from .src to dest
    29                          ; -----------------------------------------------------------------------------
    30                          ; Inputs:
    31                          ;	.src: source address
    32                          ;	.dst: destination address
    33                          ;	.cnt: number of bytes
    34                          ; -----------------------------------------------------------------------------
    35                          !macro memcpy .dst, .src, .cnt {
    36                          !if .cnt <= 0 {
    37                          	!error "memcpy: invalid count: ", .cnt
    38                          } else if .cnt <= 8 {
    39                          	!for i, 0, .cnt - 1 {
    40                          		lda .src + i
    41                          		sta .dst + i
    42                          	}
    43                          } else { !if .cnt <= 256 {
    44                          	ldx #0
    45                          -
    46                          	lda .src, x
    47                          	sta .dst, x
    48                          	inx
    49                          	cpx #(.cnt & $ff)	
    50                          	bne -
    51                          } else {
    52                          	lda #<.src
    53                          	sta MEM_SRC
    54                          	lda #>.src
    55                          	sta MEM_SRC + 1
    56                          
    57                          	lda #<.dst
    58                          	sta MEM_DST
    59                          	lda #>.dst
    60                          	sta MEM_DST + 1
    61                          
    62                          
    63                          		lda #<.cnt
    64                          		sta MEMCPY_LEN
    65                          		lda #>.cnt
    66                          		sta MEMCPY_LEN + 1
    67                          		jsr memcpyMultiPage
    68                          	}
    69                          }
    70                          }
    71                          
    72                          !macro setMemCpySrc .src {
    73                          	lda #<.src
    74                          	sta MEM_SRC
    75                          	lda #>.src
    76                          	sta MEM_SRC + 1
    77                          }
    78                          
    79                          !macro setMemCpyDst .dst {
    80                          	lda #<.dst
    81                          	sta MEM_DST
    82                          	lda #>.dst
    83                          	sta MEM_DST + 1
    84                          }
    85                          
    86                          !macro setMemCpySrcInd .srcRef {
    87                          	lda .srcRef
    88                          	sta MEM_SRC
    89                          	lda .srcRef + 1
    90                          	sta MEM_SRC + 1
    91                          }
    92                          
    93                          !macro setMemCpyDstInd .dstRef {
    94                          	lda .dstRef
    95                          	sta MEM_DST
    96                          	lda .dstRef + 1
    97                          	sta MEM_DST + 1
    98                          }
    99                          
   100                          !macro memcpySinglePage .bytes {
   101                          
   102                          	!if .bytes <= 0 {
   103                          		!error "memcpySinglePage: invalid count: ", .bytes
   104                          	}	
   105                          
   106                          	ldy #.bytes
   107                          	jsr memcpySinglePage
   108                          }
   109                          
   110                          
   111                          ; -----------------------------------------------------------------------------
   112                          ; memcpyPort: Copy a fixed number of bytes from .src ram to dest port
   113                          ; -----------------------------------------------------------------------------
   114                          ; Inputs:
   115                          ;	.src: source address
   116                          ;	.dst: destination address
   117                          ;	.cnt: number of bytes
   118                          ; -----------------------------------------------------------------------------
   119                          !macro memcpyPort .dst, .src, .cnt {
   120                          	!if .cnt <= 0 {
   121                          		!error "memcpyPort: invalid count: ", .cnt
   122                          	}
   123                          	
   124                          	lda #<.src
   125                          	sta MEM_SRC
   126                          	lda #>.src
   127                          	sta MEM_SRC + 1
   128                          
   129                          	lda #<.dst
   130                          	sta MEM_DST
   131                          	lda #>.dst
   132                          	sta MEM_DST + 1
   133                          
   134                          	!if .cnt <= 256 {
   135                          		ldy #<.cnt					
   136                          		jsr memcpySinglePagePort
   137                          	} else {
   138                          		lda #<.cnt
   139                          		sta MEMCPY_LEN
   140                          		lda #>.cnt
   141                          		sta MEMCPY_LEN + 1
   142                          		jsr memcpyMultiPagePort
   143                          	}
   144                          }
   145                          
   146                          !zone {
   147                          
   148                          ; -----------------------------------------------------------------------------
   149                          ; memset: Set a fixed number of bytes to a single value
   150                          ; -----------------------------------------------------------------------------
   151                          ; Inputs:
   152                          ;	.dst: destination address
   153                          ;	val: the byte value
   154                          ;	.cnt: number of bytes
   155                          ; -----------------------------------------------------------------------------
   156                          !macro memset .dst, .val, .cnt {
   157                          !if .cnt <= 0 {
   158                          	!error "memset: invalid count: ", .cnt
   159                          } else if .cnt <= 8 {
   160                          	lda #.val
   161                          	!for i, 0, .cnt - 1 {
   162                          	sta .dst + i
   163                          	}
   164                          } else if .cnt <= 256 {
   165                          	ldx #<.cnt
   166                          	lda #.val
   167                          -
   168                          	dex
   169                          	sta .dst, x
   170                          	cpx #0
   171                          	bne -
   172                          } else {
   173                          	lda #<.dst
   174                          	sta MEM_DST
   175                          	lda #>.dst
   176                          	sta MEM_DST + 1
   177                          	lda #<.cnt
   178                          	sta MEM_LEN
   179                          	lda #>.cnt
   180                          	sta MEM_LEN + 1
   181                          	lda #.val
   182                          	jsr memsetMultiPage
   183                          }
   184                          }
   185                          
   186                          

; ******** Source: ../../kernel\hbc56kernel.inc
    18                          

; ******** Source: ../../lib\gfx\tms9918.inc
     1                          ; 6502 - TMS9918 VDP Macros
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          
    10                          
    11                          
    12                          
    13                          ; -----------------------------------------------------------------------------
    14                          ; tmsWaitReg: Not sure how much delay we need so make a macro for now
    15                          ; -----------------------------------------------------------------------------
    16                          !macro tmsWaitReg {
    17                                  jsr _tmsWaitReg
    18                          }
    19                          
    20                          ; -----------------------------------------------------------------------------
    21                          ; tmsWaitData: Not sure how much delay we need so make a macro for now
    22                          ; -----------------------------------------------------------------------------
    23                          !macro tmsWaitData {
    24                                  jsr _tmsWaitData
    25                          }
    26                          
    27                          ; -----------------------------------------------------------------------------
    28                          ; tmsSetAddressWrite: Set an address in the TMS9918
    29                          ; -----------------------------------------------------------------------------
    30                          !macro tmsSetAddressWrite .addr {
    31                                  +tmsSetAddressRead ($4000 | .addr)
    32                          }
    33                          
    34                          ; -----------------------------------------------------------------------------
    35                          ; tmsSetAddressRead: Set an address to read from the TMS9918
    36                          ; -----------------------------------------------------------------------------
    37                          !macro tmsSetAddressRead .addr {
    38                                  php
    39                                  sei             ; we can't be interrupted here
    40                                  lda #<(.addr)
    41                                  sta TMS9918_REG
    42                                  +tmsWaitReg
    43                                  lda #>(.addr)
    44                                  sta TMS9918_REG
    45                                  +tmsWaitReg
    46                                  plp
    47                          }
    48                          
    49                          ; -----------------------------------------------------------------------------
    50                          ; tmsGet: Get a byte of data from the TMS9918
    51                          ; -----------------------------------------------------------------------------
    52                          !macro tmsGet {
    53                                  lda TMS9918_RAM
    54                                  +tmsWaitData
    55                          }
    56                          
    57                          ; -----------------------------------------------------------------------------
    58                          ; tmsPut: Send a byte of data to the TMS9918
    59                          ; -----------------------------------------------------------------------------
    60                          !macro tmsPut .byte {
    61                                  lda #(.byte & 0xff)
    62                                  +tmsPut
    63                          }
    64                          
    65                          
    66                          ; -----------------------------------------------------------------------------
    67                          ; tmsPut: Send a byte (A) of data to the TMS9918
    68                          ; -----------------------------------------------------------------------------
    69                          !macro tmsPut {
    70                                  sta TMS9918_RAM
    71                                  +tmsWaitData
    72                          }
    73                          
    74                          ; -----------------------------------------------------------------------------
    75                          ; tmsSetColor: Set current fg/bg color
    76                          ; -----------------------------------------------------------------------------
    77                          !macro tmsSetColor .color {
    78                                  lda #.color
    79                                  jsr tmsSetBackground
    80                          }
    81                          
    82                          ; -----------------------------------------------------------------------------
    83                          ; tmsSetColorFgBg: Set current fg/bg color
    84                          ; -----------------------------------------------------------------------------
    85                          !macro tmsSetColorFgBg .fg, .bg {
    86                                  +tmsColorFgBg .fg, .bg
    87                                  jsr tmsSetBackground
    88                          }
    89                          
    90                          ; -----------------------------------------------------------------------------
    91                          ; byteTmsColorFgBg: Output a data byte
    92                          ; -----------------------------------------------------------------------------
    93                          !macro byteTmsColorFgBg .fg, .bg {
    94                          !byte (.fg << 4 | .bg)
    95                          }
    96                          
    97                          
    98                          ; -----------------------------------------------------------------------------
    99                          ; tmsDisableOutput: Disable the TMS9918 output
   100                          ; -----------------------------------------------------------------------------
   101                          !macro tmsDisableOutput {
   102                                  lda #TMS_R1_DISP_ACTIVE
   103                                  jsr tmsReg1ClearFields
   104                          }
   105                          
   106                          ; -----------------------------------------------------------------------------
   107                          ; tmsEnableOutput: Enable the TMS9918 output
   108                          ; -----------------------------------------------------------------------------
   109                          !macro tmsEnableOutput {
   110                                  lda #TMS_R1_DISP_ACTIVE
   111                                  jsr tmsReg1SetFields
   112                          }
   113                          
   114                          ; -
   115                          !macro tmsEnableInterrupts {
   116                                  lda #TMS_R1_INT_ENABLE
   117                                  jsr tmsReg1SetFields
   118                          }
   119                          
   120                          !macro tmsDisableInterrupts {
   121                                  lda #TMS_R1_INT_ENABLE
   122                                  jsr tmsReg1ClearFields
   123                          }
   124                          
   125                          !macro tmsConsoleOut .char {
   126                                  lda #.char
   127                                  jsr tmsConsoleOut
   128                          }
   129                          
   130                          
   131                          ; -----------------------------------------------------------------------------
   132                          ; tmsConsolePrintAddr: Print text to console
   133                          ; -----------------------------------------------------------------------------
   134                          ; Inputs:
   135                          ;  textAddr: Address of null-terminated string to print
   136                          ; -----------------------------------------------------------------------------
   137                          !macro tmsConsolePrintAddr .textAddr {
   138                                  lda #<.textAddr
   139                                  sta STR_ADDR_L
   140                                  lda #>.textAddr
   141                                  sta STR_ADDR_H
   142                                  jsr tmsConsolePrint        
   143                          }
   144                          
   145                          ; -----------------------------------------------------------------------------
   146                          ; tmsConsolePrint: Print immediate text to console
   147                          ; -----------------------------------------------------------------------------
   148                          ; Inputs:
   149                          ;  str: String to print
   150                          ; -----------------------------------------------------------------------------
   151                          !macro tmsConsolePrint .str {
   152                          	jmp .afterText
   153                          .textAddr
   154                          	!text .str,0
   155                          .afterText        
   156                                  +tmsConsolePrintAddr .textAddr
   157                          }
   158                          
   159                          ; -----------------------------------------------------------------------------
   160                          ; +tmsColorFgBg: Set A to the given FG / BG color
   161                          ; -----------------------------------------------------------------------------
   162                          !macro tmsColorFgBg .fg, .bg {
   163                                  lda #(.fg << 4 | .bg)
   164                          }
   165                          
   166                          ; -----------------------------------------------------------------------------
   167                          ; tmsReadStatus: Read status - clear interrupt
   168                          ; -----------------------------------------------------------------------------
   169                          !macro tmsReadStatus  {
   170                                  bit TMS9918_REG
   171                          }
   172                          
   173                          ; -----------------------------------------------------------------------------
   174                          ; tmsSendData: Send # bytes from .sourceAddr to tms9918 data port
   175                          ; -----------------------------------------------------------------------------
   176                          !macro tmsSendData .sourceAddr, .numBytes {
   177                                  lda #<.sourceAddr
   178                                  sta TMS_TMP_ADDRESS
   179                                  lda #>.sourceAddr
   180                                  sta TMS_TMP_ADDRESS + 1
   181                          
   182                                  !if .numBytes < 256 {
   183                                          ldx #.numBytes
   184                                          jsr tmsSendBytes
   185                                  } else {
   186                                          !do while .numBytes > 0 {
   187                                                  !if .numBytes > 255 {
   188                                                          ldx #0
   189                                                          !set .numBytes = .numBytes - 256
   190                                                  } else {
   191                                                          ldx #.numBytes
   192                                                          !set .numBytes = 0
   193                                                  }
   194                                                  jsr tmsSendBytes
   195                                                  inc TMS_TMP_ADDRESS + 1
   196                                          }
   197                                  }
   198                          
   199                          }
   200                          
   201                          ; -----------------------------------------------------------------------------
   202                          ; tmsSendDataRpt: Send # bytes from .sourceAddr to tms9918 data port .rpt times
   203                          ; -----------------------------------------------------------------------------
   204                          !macro tmsSendDataRpt .sourceAddr, .numBytes, .rpt {
   205                                  lda #<.sourceAddr
   206                                  sta TMS_TMP_ADDRESS
   207                                  lda #>.sourceAddr
   208                                  sta TMS_TMP_ADDRESS + 1
   209                          
   210                                  !if .numBytes < 256 {
   211                                          !if .rpt < 5 {
   212                                                  !for i,1,.rpt {
   213                                                          ldx #.numBytes
   214                                                          jsr tmsSendBytes
   215                                                  }
   216                                          } else {
   217                                                  lda #.rpt
   218                                                  sta TMS9918_TMP_BUFFER
   219                          -
   220                                                  ldx #.numBytes
   221                                                  jsr tmsSendBytes
   222                                                  dec TMS9918_TMP_BUFFER
   223                                                  bne -
   224                                          }
   225                                  } else {
   226                                          !error "tmsSendDataRpt supports <256 bytes only"
   227                                  }
   228                          }
   229                          
   230                          
   231                          ; -----------------------------------------------------------------------------
   232                          ; tmsPutRpt: Send value .rpt times
   233                          ; -----------------------------------------------------------------------------
   234                          !macro tmsPutRpt .value, .rpt {
   235                                  ldx #.rpt
   236                                  lda #.value
   237                          -
   238                                  +tmsPut
   239                                  dex
   240                                  bne -
   241                          }
   242                          
   243                          !macro tmsPutSeq .from, .count {
   244                                  lda #.from
   245                          -
   246                                  +tmsPut
   247                                  inc
   248                                  cmp #<(.from + .count)
   249                                  bne -
   250                          }
   251                          
   252                          !macro tmsSetSourceAddressInd .addr {
   253                          	lda .addr
   254                          	sta TMS_TMP_ADDRESS
   255                          	lda .addr + 1
   256                          	sta TMS_TMP_ADDRESS + 1
   257                          }
   258                          
   259                          !macro tmsSetSourceAddressIndOffset .addr, .offset {
   260                                  clc
   261                          	lda .addr
   262                                  adc #<.offset
   263                          	sta TMS_TMP_ADDRESS
   264                          	lda .addr + 1
   265                                  adc #>.offset
   266                          	sta TMS_TMP_ADDRESS + 1
   267                          }
   268                          
   269                          
   270                          !macro tmsSendBytes .bytes {
   271                                  ldx #.bytes
   272                                  jsr tmsSendBytes
   273                          }
   274                          
   275                          
   276                          ; -----------------------------------------------------------------------------
   277                          ; tmsSetAddrPattTable: Initialise address for font table
   278                          ; -----------------------------------------------------------------------------
   279                          !macro tmsSetAddrPattTable {
   280                                  +tmsSetAddrPattTable 0
   281                          }
   282                          
   283                          ; -----------------------------------------------------------------------------
   284                          ; tmsSetAddrPattTable: Initialise address for pattern table
   285                          ; -----------------------------------------------------------------------------
   286                          !macro tmsSetAddrPattTable .ind {
   287                                  +tmsSetAddressWrite TMS_VRAM_PATT_ADDRESS + (8 * .ind)
   288                          }
   289                          
   290                          ; -----------------------------------------------------------------------------
   291                          ; tmsSetAddrPattTable: Initialise address for pattern table
   292                          ; -----------------------------------------------------------------------------
   293                          !macro tmsSetAddrPattTable .ind, .row {
   294                                  +tmsSetAddressWrite TMS_VRAM_PATT_ADDRESS + (8 * .ind) + .row
   295                          }
   296                          
   297                          ; -----------------------------------------------------------------------------
   298                          ; tmsSetAddrPattTableIIBank0: Initialise address for pattern table
   299                          ; -----------------------------------------------------------------------------
   300                          !macro tmsSetAddrPattTableIIBank0 .ind {
   301                                  +tmsSetAddrPattTable .ind
   302                          }
   303                          
   304                          ; -----------------------------------------------------------------------------
   305                          ; tmsSetAddrPattTableIIBank1: Initialise address for pattern table
   306                          ; -----------------------------------------------------------------------------
   307                          !macro tmsSetAddrPattTableIIBank1 .ind {
   308                                  +tmsSetAddrPattTable 256 + .ind
   309                          }
   310                          
   311                          ; -----------------------------------------------------------------------------
   312                          ; tmsSetAddrPattTableIIBank2: Initialise address for pattern table
   313                          ; -----------------------------------------------------------------------------
   314                          !macro tmsSetAddrPattTableIIBank2 .ind {
   315                                  +tmsSetAddrPattTable 512 + .ind
   316                          }
   317                          
   318                          ; -----------------------------------------------------------------------------
   319                          ; tmsSetAddrPattTableRead: Initialise address for pattern table to read
   320                          ; -----------------------------------------------------------------------------
   321                          !macro tmsSetAddrPattTableRead .ind {
   322                                  +tmsSetAddressRead TMS_VRAM_PATT_ADDRESS + (8 * .ind)
   323                          }
   324                          
   325                          ; -----------------------------------------------------------------------------
   326                          ; tmsSetAddrPattTableRowRead: Initialise address for pattern table to read
   327                          ; -----------------------------------------------------------------------------
   328                          !macro tmsSetAddrPattTableRead .ind, .row {
   329                                  +tmsSetAddressRead TMS_VRAM_PATT_ADDRESS + (8 * .ind) + .row
   330                          }
   331                          
   332                          ; -----------------------------------------------------------------------------
   333                          ; tmsUpdateFont: Update the pattern table with a given font
   334                          ; -----------------------------------------------------------------------------
   335                          !macro tmsUpdateFont .fontAddr {
   336                                  +tmsSetAddrPattTable 32
   337                                  +tmsSendData .fontAddr, $300
   338                          }
   339                          
   340                          ; -----------------------------------------------------------------------------
   341                          ; tmsSetAddrNameTable: Initialise address for base (text) table
   342                          ; -----------------------------------------------------------------------------
   343                          !macro tmsSetAddrNameTable {
   344                                  +tmsSetAddressWrite TMS_VRAM_NAME_ADDRESS
   345                          }
   346                          
   347                          ; -----------------------------------------------------------------------------
   348                          ; tmsSetAddrColorTable: Initialise address for color table
   349                          ; -----------------------------------------------------------------------------
   350                          !macro tmsSetAddrColorTable {
   351                                  +tmsSetAddressWrite TMS_VRAM_COLOR_ADDRESS
   352                          }
   353                          
   354                          ; -----------------------------------------------------------------------------
   355                          ; tmsSetAddrColorTable: Initialise address for color table index
   356                          ; -----------------------------------------------------------------------------
   357                          !macro tmsSetAddrColorTable .ind {
   358                                  +tmsSetAddressWrite TMS_VRAM_COLOR_ADDRESS + .ind
   359                          }
   360                          
   361                          ; -----------------------------------------------------------------------------
   362                          ; tmsSetAddrColorTableII: Initialise address for color table index (mode II)
   363                          ; -----------------------------------------------------------------------------
   364                          !macro tmsSetAddrColorTableII .ind {
   365                                  +tmsSetAddressWrite TMS_VRAM_COLOR_ADDRESS + .ind * 8
   366                          }
   367                          
   368                          ; -----------------------------------------------------------------------------
   369                          ; tmsSetAddrColorTableIIBank0: Initialise address for color table index (mode II)
   370                          ; -----------------------------------------------------------------------------
   371                          !macro tmsSetAddrColorTableIIBank0 .ind {
   372                                  +tmsSetAddrColorTableII .ind
   373                          }
   374                          
   375                          ; -----------------------------------------------------------------------------
   376                          ; tmsSetAddrColorTableIIBank1: Initialise address for color table index (mode II)
   377                          ; -----------------------------------------------------------------------------
   378                          !macro tmsSetAddrColorTableIIBank1 .ind {
   379                                  +tmsSetAddrColorTableII 256 + .ind
   380                          }
   381                          
   382                          ; -----------------------------------------------------------------------------
   383                          ; tmsSetAddrColorTableIIBank2: Initialise address for color table index (mode II)
   384                          ; -----------------------------------------------------------------------------
   385                          !macro tmsSetAddrColorTableIIBank2 .ind {
   386                                  +tmsSetAddrColorTableII 512 + .ind
   387                          }
   388                          
   389                          ; -----------------------------------------------------------------------------
   390                          ; tmsSetAddrSpriteAttrTable: Initialise address for sprite attributes table
   391                          ; -----------------------------------------------------------------------------
   392                          !macro tmsSetAddrSpriteAttrTable {
   393                                  +tmsSetAddrSpriteAttrTable 0
   394                          }
   395                          
   396                          ; -----------------------------------------------------------------------------
   397                          ; tmsSetAddrSpriteAttrTable: Initialise address for sprite attributes table
   398                          ; -----------------------------------------------------------------------------
   399                          !macro tmsSetAddrSpriteAttrTable .index {
   400                                  +tmsSetAddressWrite TMS_VRAM_SPRITE_ATTR_ADDRESS + .index * 4
   401                          }
   402                          
   403                          ; -----------------------------------------------------------------------------
   404                          ; tmsSetAddrSpritePattTable: Initialise address for sprite pattern table
   405                          ; -----------------------------------------------------------------------------
   406                          !macro tmsSetAddrSpritePattTable {
   407                                  +tmsSetAddrSpritePattTable 0
   408                          }
   409                          
   410                          ; -----------------------------------------------------------------------------
   411                          ; tmsSetAddrSpritePattTable: Initialise address for sprite pattern table
   412                          ; -----------------------------------------------------------------------------
   413                          !macro tmsSetAddrSpritePattTable .index {
   414                                  +tmsSetAddressWrite TMS_VRAM_SPRITE_PATT_ADDRESS + .index * 8
   415                          }
   416                          
   417                          
   418                          ; -----------------------------------------------------------------------------
   419                          ; tmsCreateSpritePattern: Create a sprite pattern (.spriteDataAddr is 8 bytes)
   420                          ; -----------------------------------------------------------------------------
   421                          !macro tmsCreateSpritePattern .pattInd, .spriteDataAddr {
   422                          
   423                                  
   424                          
   425                                  ; sprite pattern table
   426                                  +tmsSetAddrSpritePattTable .pattInd
   427                          
   428                                  ldx #0
   429                          -
   430                                  lda .spriteDataAddr,x
   431                                  +tmsPut
   432                                  inx
   433                                  cpx #8
   434                          
   435                                  
   436                          
   437                                  bne -
   438                          }
   439                          
   440                          ; -----------------------------------------------------------------------------
   441                          ; tmsCreateSpritePatternQuad: Create a (size 1) sprite pattern 
   442                          ;   (.spriteDataAddr is 32 bytes)
   443                          ; -----------------------------------------------------------------------------
   444                          !macro tmsCreateSpritePatternQuad .pattInd, .spriteDataAddr {
   445                          
   446                                  
   447                          
   448                                  ; sprite pattern table
   449                                  +tmsSetAddrSpritePattTable .pattInd * 4
   450                          
   451                                  ldx #0
   452                          -
   453                                  lda .spriteDataAddr,x
   454                                  +tmsPut 
   455                                  inx
   456                                  cpx #32
   457                          
   458                                  
   459                          
   460                                  bne -
   461                          }
   462                          
   463                          
   464                          !macro tmsCreateSpritePatternImm .ind, .b0, .b1, .b2, .b3, .b4, .b5, .b6, .b7 {
   465                          
   466                                  ; sprite pattern table
   467                                  +tmsSetAddrSpritePattTable .ind
   468                                  +tmsPut .b0
   469                                  +tmsPut .b2
   470                                  +tmsPut .b2
   471                                  +tmsPut .b3
   472                                  +tmsPut .b4
   473                                  +tmsPut .b5
   474                                  +tmsPut .b6
   475                                  +tmsPut .b7
   476                          }
   477                          
   478                          !macro tmsCreatePatternImm .ind, .b0, .b1, .b2, .b3, .b4, .b5, .b6, .b7 {
   479                          
   480                                  ; sprite pattern table
   481                                  +tmsSetAddrPattTable .ind
   482                                  +tmsPut .b0
   483                                  +tmsPut .b2
   484                                  +tmsPut .b2
   485                                  +tmsPut .b3
   486                                  +tmsPut .b4
   487                                  +tmsPut .b5
   488                                  +tmsPut .b6
   489                                  +tmsPut .b7
   490                          }
   491                          
   492                          
   493                          ; -----------------------------------------------------------------------------
   494                          ; tmsCreateSprite: Create a sprite
   495                          ; -----------------------------------------------------------------------------
   496                          !macro tmsCreateSprite .ind, .pattInd, .xPos, .yPos, .color {
   497                          
   498                                  ; sprite attr table
   499                                  +tmsSetAddrSpriteAttrTable .ind
   500                          
   501                                  +tmsPut .yPos
   502                                  +tmsPut .xPos
   503                                  +tmsPut .pattInd
   504                                  +tmsPut .color
   505                          }
   506                          
   507                          ; -----------------------------------------------------------------------------
   508                          ; tmsSpritePos: Set a sprite position
   509                          ; -----------------------------------------------------------------------------
   510                          !macro tmsSpritePos .ind, .xPos, .yPos {
   511                                  
   512                          
   513                                  ; sprite attr table
   514                                  +tmsSetAddrSpriteAttrTable .ind
   515                          
   516                                  +tmsPut .yPos
   517                                  +tmsPut .xPos        
   518                          }
   519                          
   520                          
   521                          ; -----------------------------------------------------------------------------
   522                          ; tmsSetLastSprite: Mark a sprite as the last sprite (set next ypos to )
   523                          ; -----------------------------------------------------------------------------
   524                          !macro tmsSetLastSprite .ind {
   525                                  +tmsSpritePos .ind + 1, 0, $d0
   526                          }
   527                          
   528                          
   529                          ; -----------------------------------------------------------------------------
   530                          ; tmsSpritePosXYReg: Set a sprite position from x/y registers
   531                          ; -----------------------------------------------------------------------------
   532                          !macro tmsSpritePosXYReg .ind {
   533                                  
   534                          
   535                                  ; sprite attr table
   536                                  +tmsSetAddrSpriteAttrTable .ind
   537                          
   538                                  tya
   539                                  +tmsPut 
   540                                  txa
   541                                  +tmsPut 
   542                          }
   543                          
   544                          
   545                          ; -----------------------------------------------------------------------------
   546                          ; tmsSetAddrSpriteColor: Change a sprite color
   547                          ; -----------------------------------------------------------------------------
   548                          !macro tmsSetAddrSpriteColor .ind {
   549                          
   550                                  ; sprite attr table
   551                                  +tmsSetAddressWrite TMS_VRAM_SPRITE_ATTR_ADDRESS + (.ind * 4) + 3
   552                          }
   553                          ; -----------------------------------------------------------------------------
   554                          ; tmsSpriteColor: Change a sprite color
   555                          ; -----------------------------------------------------------------------------
   556                          !macro tmsSpriteColor .ind, .color {
   557                          
   558                                  +tmsSetAddrSpriteColor .ind
   559                          
   560                                  +tmsPut .color
   561                          }
   562                          
   563                          
   564                          ; -----------------------------------------------------------------------------
   565                          ; tmsSetPosWrite: Set cursor position
   566                          ; -----------------------------------------------------------------------------
   567                          !macro tmsSetPosWrite .x, .y {
   568                                  +tmsSetAddressWrite (TMS_VRAM_NAME_ADDRESS + .y * 32 + .x)
   569                          }
   570                          
   571                          ; -----------------------------------------------------------------------------
   572                          ; tmsSetPosRead: Set read cursor position
   573                          ; -----------------------------------------------------------------------------
   574                          !macro tmsSetPosRead .x, .y {
   575                                  +tmsSetAddressRead (TMS_VRAM_NAME_ADDRESS + .y * 32 + .x)
   576                          }
   577                          
   578                          ; -----------------------------------------------------------------------------
   579                          ; tmsPrint: Print immediate text
   580                          ; -----------------------------------------------------------------------------
   581                          ; Inputs:
   582                          ;  str: String to print
   583                          ;  x: x position
   584                          ;  y: y position
   585                          ; -----------------------------------------------------------------------------
   586                          !macro tmsPrint .str, .x, .y {
   587                          	jmp .afterText
   588                          .textAddr
   589                          	!text .str,0
   590                          .afterText        
   591                          
   592                                  +tmsSetPosWrite .x, .y
   593                          
   594                                  lda #<.textAddr
   595                                  sta STR_ADDR_L
   596                                  lda #>.textAddr
   597                                  sta STR_ADDR_H
   598                                  jsr tmsPrint        
   599                          }
   600                          
   601                          
   602                          ; -----------------------------------------------------------------------------
   603                          ; tmsPrintCentre: Print centre-aligned immediate text
   604                          ; -----------------------------------------------------------------------------
   605                          ; Inputs:
   606                          ;  str: String to print
   607                          ;  y: y position
   608                          ; -----------------------------------------------------------------------------
   609                          !macro tmsPrintCentre .str, .y {
   610                          	jmp .afterText
   611                          .textAddr
   612                          	!text .str,0
   613                          .afterText        
   614                          
   615                                  +tmsSetPosWrite (32 - ((.afterText - 1) - .textAddr)) / 2, .y
   616                          
   617                                  lda #<.textAddr
   618                                  sta STR_ADDR_L
   619                                  lda #>.textAddr
   620                                  sta STR_ADDR_H
   621                                  jsr tmsPrint        
   622                          }
   623                          
   624                          
   625                          ; -----------------------------------------------------------------------------
   626                          ; tmsPrintZ: Print text
   627                          ; -----------------------------------------------------------------------------
   628                          ; Inputs:
   629                          ;  str: Address of zero-terminated string to print
   630                          ;  x: x position
   631                          ;  y: y position
   632                          ; -----------------------------------------------------------------------------
   633                          !macro tmsPrintZ .textAddr, .x, .y {
   634                                  +tmsSetPosWrite .x, .y
   635                          
   636                                  lda #<.textAddr
   637                                  sta STR_ADDR_L
   638                                  lda #>.textAddr
   639                                  sta STR_ADDR_H
   640                                  jsr tmsPrint        
   641                          }

; ******** Source: ../../kernel\hbc56kernel.inc
    19                          

; ******** Source: ../../lib\gfx\tilemap.inc
     1                          ; 6502 - Tilemap
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          ;
    10                          
    11                          
    12                          
    13                          !macro tilemapCreate .tilemapStructAddr, .bufferAddr, .tilesetAddr, .sizeFlags, .tileSizePx, .invertAddr, .dirtyAddr {
    14                          	!if <.tilesetAddr != 0 { !error "tilemapCreate: Tileset address must be page-aligned",.tilesetAddr }
    15                          	!if >.tilesetAddr < 3 { !error "tilemapCreate: Tileset address must be greater than $2ff",.tilesetAddr }
    16                          	!if <.bufferAddr != 0 { !error "tilemapCreate: Buffer address must be page-aligned",.bufferAddr }
    17                          	!if >.bufferAddr < 3 { !error "tilemapCreate: Buffer address must be greater than $2ff",.bufferAddr }
    18                          	!if .invertAddr != 0 and <.invertAddr != 0  {!error "tilemapCreate: Invert address must be page-aligned", .invertAddr}
    19                          	!if .invertAddr != 0 and >.invertAddr < 3  {!error "tilemapCreate: Invert address must be greater than $2ff", .invertAddr}
    20                          	!if .dirtyAddr != 0 and <.dirtyAddr != 0  {!error "tilemapCreate: Dirty address must be page-aligned", .dirtyAddr}
    21                          	!if .dirtyAddr != 0 and >.dirtyAddr < 3  {!error "tilemapCreate: Dirty address must be greater than $2ff", .dirtyAddr}
    22                          	!if .tileSizePx != 4 and .tileSizePx != 8 {!error "tilemapCreate: Tile size must be 4 or 8 pixels",.tileSizePx}
    23                          
    24                          	lda #<.tilemapStructAddr
    25                          	sta TILEMAP_ADDR
    26                          	lda #>.tilemapStructAddr
    27                          	sta TILEMAP_ADDR + 1
    28                          
    29                          	lda #>.bufferAddr
    30                          	sta .tilemapStructAddr + TILEMAP_BUFFER_ADDR
    31                          	lda #.sizeFlags
    32                          	sta .tilemapStructAddr + TILEMAP_SIZE
    33                          	lda #>.tilesetAddr
    34                          	sta .tilemapStructAddr + TILEMAP_TILES_ADDR
    35                          	lda #>.invertAddr
    36                          	sta .tilemapStructAddr + TILEMAP_INVERT_ADDR
    37                          	lda #>.dirtyAddr
    38                          	sta .tilemapStructAddr + TILEMAP_DIRTY_ADDR
    39                          	lda #.tileSizePx
    40                          	sta .tilemapStructAddr + TILEMAP_TILE_SIZE_PX
    41                          
    42                          	jsr tilemapInit
    43                          }
    44                          
    45                          !macro tilemapCreateDefault .sizeFlags, .tilesetAddr {
    46                          	+tilemapCreate TILEMAP_FIXED_ADDRESS, TILEMAP_DEFAULT_BUFFER_ADDRESS, .tilesetAddr, .sizeFlags, 8, $0, $0
    47                          }
    48                          
    49                          !macro tilemapSetActive .tilemapStructAddr {
    50                          	lda #<.tilemapStructAddr
    51                          	sta TILEMAP_ADDR
    52                          	lda #>.tilemapStructAddr
    53                          	sta TILEMAP_ADDR + 1
    54                          
    55                          	jsr tilemapSetActive

; ******** Source: ../../kernel\hbc56kernel.inc
    20                          

; ******** Source: ../../lib\lcd\lcd.inc
     1                          ; 6502 LCD Macros - HBC-56
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          
    10                          ; -----------------------------------------------------------------------------
    11                          ; lcdPrint: Print immediate text
    12                          ; -----------------------------------------------------------------------------
    13                          ; Inputs:
    14                          ;  str: String to print
    15                          ; -----------------------------------------------------------------------------
    16                          !macro lcdPrint str {
    17                          	jmp +
    18                          .textAddr
    19                          	!text str,0
    20                          +
    21                          	lda #<.textAddr
    22                          	sta STR_ADDR_L
    23                          	lda #>.textAddr
    24                          	sta STR_ADDR_H
    25                          	jsr lcdPrint
    26                          }
    27                          
    28                          
    29                          ; -----------------------------------------------------------------------------
    30                          ; lcdChar: Print immediate character
    31                          ; -----------------------------------------------------------------------------
    32                          ; Inputs:
    33                          ;  c: Character to print
    34                          ; -----------------------------------------------------------------------------
    35                          !macro lcdChar c {
    36                          	pha
    37                          	lda #c
    38                          	jsr lcdChar
    39                          	pla
    40                          }
    41                          
    42                          
    43                          ; -----------------------------------------------------------------------------
    44                          ; lcdConsolePrint: Print immediate text to console
    45                          ; -----------------------------------------------------------------------------
    46                          ; Inputs:
    47                          ;  str: String to print
    48                          ; -----------------------------------------------------------------------------
    49                          !macro lcdConsolePrint .str {
    50                          	jmp .afterText
    51                          .textAddr
    52                          	!text .str,0
    53                          .afterText        
    54                          
    55                                  lda #<.textAddr
    56                                  sta STR_ADDR_L
    57                                  lda #>.textAddr
    58                                  sta STR_ADDR_H
    59                                  jsr lcdConsolePrint        

; ******** Source: ../../kernel\hbc56kernel.inc
    21                          

; ******** Source: ../../lib\inp\nes.inc
     1                          ; 6502 NES Controller Macros - HBC-56
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          ; Dependencies:
    10                          ;  - hbc56.asm
    11                          
    12                          
    13                          !macro nes1BranchIfPressed .buttonMask, .addr {
    14                                  pha
    15                                  lda #(.buttonMask)
    16                                  jsr nes1Pressed
    17                                  pla
    18                                  bcs .addr
    19                          }
    20                          
    21                          !macro nes1BranchIfNotPressed .buttonMask, .addr {
    22                                  pha
    23                                  lda #(.buttonMask)
    24                                  jsr nes1Pressed
    25                                  pla
    26                                  bcc .addr
    27                          }
    28                          
    29                          !macro nes2BranchIfPressed .buttonMask, addr {
    30                                  pha
    31                                  lda #(.buttonMask)
    32                                  jsr nes2Pressed
    33                                  pla
    34                                  bcs addr
    35                          }
    36                          
    37                          !macro nes2BranchIfNotPressed .buttonMask, addr {
    38                                  pha
    39                                  lda #(.buttonMask)
    40                                  jsr nes2Pressed
    41                                  pla
    42                                  bcc addr
    43                          }

; ******** Source: ../../kernel\hbc56kernel.inc
    22                          

; ******** Source: ../../lib\inp\keyboard.inc
     1                          ; 6502 KB Controller Macros - HBC-56
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          ; Dependencies:
    10                          ;  - hbc56.asm
    11                          
    12                          
    13                          !macro kbBranchIfNotPressed .scancode, .addr {
    14                                  ldx #.scancode
    15                                  jsr kbReadAscii
    16                                  beq .addr
    17                          }
    18                          
    19                          !macro kbBranchIfPressed .scancode, .addr {
    20                                  ldx #.scancode
    21                                  jsr kbIsPressed
    22                                  bne .addr
    23                          }
    24                          
    25                          !macro kbSetEventHandlerPressed .cb {
    26                                  lda #<.cb
    27                                  sta KB_CB_PRESSED
    28                                  lda #>.cb
    29                                  sta KB_CB_PRESSED + 1
    30                          }
    31                          
    32                          !macro kbSetEventHandlerReleased .cb {
    33                                  lda #<.cb
    34                                  sta KB_CB_RELEASED
    35                                  lda #>.cb
    36                                  sta KB_CB_RELEASED + 1

; ******** Source: ../../kernel\hbc56kernel.inc
    23                          

; ******** Source: ../../lib\sfx\ay3891x.inc
     1                          ; 6502 - AY-3-819x PSG
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          
    10                          
    11                          
    12                          !macro ayWrite .dev, .reg, .val {
    13                                  lda #.reg
    14                                  sta IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_ADDR | .dev
    15                                  lda #.val
    16                                  sta IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_WRITE | .dev
    17                          }        
    18                          
    19                          !macro ayRead .dev, .reg {
    20                                  lda #.reg
    21                                  sta IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_ADDR | .dev
    22                                  lda IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_READ | .dev
    23                          }        
    24                          
    25                          
    26                          !macro ayWriteX .dev, .reg {
    27                                  lda #.reg
    28                                  sta IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_ADDR | .dev
    29                                  stx IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_WRITE | .dev
    30                          }
    31                          
    32                          !macro ayWriteA .dev, .reg {
    33                                  ldx #.reg
    34                                  stx IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_ADDR | .dev
    35                                  sta IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_WRITE | .dev
    36                          }
    37                          
    38                          !macro ayPlayNote .dev, .chan, .freq {
    39                                  !if .freq <= 0 {
    40                                          .val = 0
    41                                  } else {
    42                                          .val = AY_CLOCK_FREQ / (32.0 * .freq)
    43                                  }
    44                                  +ayWrite .dev, AY_CHA_TONE_L + (.chan * 2), <.val
    45                                  +ayWrite .dev, AY_CHA_TONE_H + (.chan * 2), >.val
    46                          }
    47                          
    48                          !macro ayToneWord .freq {
    49                                  !word (AY_CLOCK_FREQ / (32.0 * .freq))
    50                          }
    51                          
    52                          !macro ayToneByteL .freq {
    53                                  !byte <(AY_CLOCK_FREQ / (32.0 * .freq))
    54                          }
    55                          
    56                          !macro ayToneByteH .freq {
    57                                  !byte >(AY_CLOCK_FREQ / (32.0 * .freq))
    58                          }
    59                          
    60                          
    61                          !macro ayToneEnable .dev, .chan {
    62                                  +ayRead .dev, AY_ENABLES
    63                                  and #!($01 << .chan)
    64                                  +ayWriteA .dev, AY_ENABLES
    65                          }
    66                          
    67                          !macro ayToneDisable .dev, .chan {
    68                                  +ayRead .dev, AY_ENABLES
    69                                  ora #($01 << .chan)
    70                                  +ayWriteA .dev, AY_ENABLES
    71                          }
    72                          
    73                          !macro ayNoiseEnable .dev, .chan {
    74                                  +ayRead .dev, AY_ENABLES
    75                                  eor #($08 << .chan)
    76                                  +ayWriteA .dev, AY_ENABLES
    77                          }
    78                          
    79                          !macro ayNoiseDisable .dev, .chan {
    80                                  +ayRead .dev, AY_ENABLES
    81                                  ora #($08 << .chan)
    82                                  +ayWriteA .dev, AY_ENABLES
    83                          }
    84                          
    85                          !macro aySetVolume .dev, .chan, .vol {
    86                                  +ayWrite .dev, (AY_CHA_AMPL + .chan), (.vol >> 4)
    87                          }
    88                          
    89                          !macro aySetVolumeEnvelope .dev, .chan {
    90                                  +ayWrite .dev, (AY_CHA_AMPL + .chan), $10
    91                          }
    92                          
    93                          !macro aySetEnvelopePeriod .dev, .period {
    94                                  +ayWrite .dev, AY_ENV_PERIOD_L, <.period
    95                                  +ayWrite .dev, AY_ENV_PERIOD_H, >.period
    96                          }
    97                          
    98                          !macro aySetEnvShape .dev, .shape {
    99                                  +ayWrite .dev, AY_ENV_SHAPE, .shape
   100                          }
   101                          
   102                          !macro aySetNoise .dev, .freq {
   103                                  +ayWrite .dev, AY_ENV_SHAPE, .freq >> 3
   104                          }
   105                          
   106                          !macro ayStop .dev, .chan {
   107                                  +ayPlayNote .dev, .chan, 0
   108                          }

; ******** Source: ../../kernel\hbc56kernel.inc
    24                          

; ******** Source: ../../lib\ser\uart.inc
     1                          ; 6502 - MC68B50 UART Macros
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          
    10                          ; -----------------------------------------------------------------------------
    11                          ; uartOutStringAddr: Output a string to the uart
    12                          ; -----------------------------------------------------------------------------
    13                          ; Inputs:
    14                          ;  .addr: Address of null-terminated string to print
    15                          ; -----------------------------------------------------------------------------
    16                          !macro uartOutStringAddr .addr {
    17                                  lda #<.addr
    18                                  sta STR_ADDR_L
    19                                  lda #>.addr
    20                                  sta STR_ADDR_H
    21                                  jsr uartOutString        
    22                          }
    23                          
    24                          
    25                          ; -----------------------------------------------------------------------------
    26                          ; uartOutString: Output an immediate string to the uart
    27                          ; -----------------------------------------------------------------------------
    28                          ; Inputs:
    29                          ;  .str: String to output
    30                          ; -----------------------------------------------------------------------------
    31                          !macro uartOutString .str {
    32                          	jmp @afterText
    33                          @textAddr
    34                          	!text .str,0
    35                          @afterText        
    36                                  +uartOutStringAddr @textAddr
    37                          }
    38                          

; ******** Source: ../../kernel\hbc56kernel.inc
    25                          

; ******** Source: ../../kernel\kernel.inc
     1                          ; 6502 - HBC-56 Kernel Macros
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          ;
    10                          
    11                          !macro setIntHandler .address {
    12                                  lda #<.address
    13                                  sta HBC56_INT_VECTOR + 1
    14                                  lda #>.address
    15                                  sta HBC56_INT_VECTOR + 2
    16                                  lda #JMP_OPCODE
    17                                  sta HBC56_INT_VECTOR
    18                          }
    19                          
    20                          !macro setNmiHandler .address {
    21                                  lda #<.address
    22                                  sta HBC56_NMI_VECTOR + 1
    23                                  lda #>.address
    24                                  sta HBC56_NMI_VECTOR + 2
    25                                  lda #JMP_OPCODE
    26                                  sta HBC56_NMI_VECTOR
    27                          }
    28                          
    29                          !macro setHbcMetaNES {
    30                                  lda #HBC56_CONSOLE_FLAG_NES
    31                                  ora HBC56_CONSOLE_FLAGS
    32                                  sta HBC56_CONSOLE_FLAGS
    33                          }
    34                          
    35                          !macro setHbcMetaNoWait {
    36                                  lda #HBC56_CONSOLE_FLAG_NOWAIT
    37                                  ora HBC56_CONSOLE_FLAGS
    38                                  sta HBC56_CONSOLE_FLAGS
    39                          }
    40                          
    41                          
    42                          !macro hbc56SetVsyncCallback .vsync {
    43                                  lda #<.vsync
    44                                  sta HBC56_VSYNC_CALLBACK
    45                                  lda #>.vsync
    46                                  sta HBC56_VSYNC_CALLBACK + 1
    47                          }
    48                          
    49                          !macro setHbcMetaTitle .titleStr {
    50                                  jmp .hbcMetaTitleOut
    51                          .titleStrLabel:
    52                                  !text .titleStr
    53                          .titleStrLabelLen = * - .titleStrLabel
    54                                  !byte 0 ; nul terminator for game name
    55                          
    56                          !if .titleStrLabelLen > HBC56_META_TITLE_MAX_LEN {
    57                                  !error "setHbcMetaTitle: Title metadata limited to ",HBC56_META_TITLE_MAX_LEN,"bytes"
    58                          }
    59                          .hbcMetaTitleOut:
    60                                  +memcpy HBC56_META_TITLE + (HBC56_META_TITLE_MAX_LEN-.titleStrLabelLen)/2, .titleStrLabel, .titleStrLabelLen
    61                                  lda #.titleStrLabelLen
    62                                  sta HBC56_META_TITLE_LEN
    63                          }
    64                          
    65                          !macro consoleEnableCursor {
    66                                  lda HBC56_CONSOLE_FLAGS
    67                                  ora #HBC56_CONSOLE_FLAG_CURSOR
    68                                  sta HBC56_CONSOLE_FLAGS
    69                          }
    70                          
    71                          !macro consoleDisableCursor {
    72                                  lda HBC56_CONSOLE_FLAGS
    73                                  and #!HBC56_CONSOLE_FLAG_CURSOR & $ff
    74                                  sta HBC56_CONSOLE_FLAGS
    75                          }
    76                          
    77                          !macro consoleLCDMode {
    78                                  lda HBC56_CONSOLE_FLAGS
    79                                  ora #HBC56_CONSOLE_FLAG_LCD
    80                                  sta HBC56_CONSOLE_FLAGS
    81                          }
    82                          
    83                          !macro setBreakpoint {
    84                                 !byte $db 
    85                          }
    86                          
    87                          !macro hbc56CustomDelay .delay {
    88                                  ldy #.delay
    89                                  jsr hbc56CustomDelay
    90                          }
    91                          
    92                          !macro hbc56DelayUs .us {
    93                          !if .us = 1 {
    94                                  nop
    95                                  nop
    96                          }
    97                          }
    98                          !macro hbc56DelayMs .ms {
    99                                  lda #<.ms
   100                                  sta DELAY_L
   101                                  lda #>.ms
   102                                  sta DELAY_H
   103                          
   104                                  jsr hbc56CustomDelayMs

; ******** Source: ../../kernel\hbc56kernel.inc
    26                          
    27                          
    28                          !ifndef HBC_56_EXCLUDE_KERNEL_ROM {
    29                          
    30                                  ; if the program requires the kernal image
    31                                  ; then... include it
    32                          
    33                                  *=HBC56_META_VECTOR
    34                                  !ifdef hbc56Meta {
    35  dffc 4c0380                             jmp hbc56Meta
    36                                  } else {
    37                                          rts
    38                                  }
    39                          
    40                                  *=HBC56_KERNEL_START
    41  e000 c9619005c97b9002...        !bin "kernel.o"
    42                          
    43                                  *=DEFAULT_HBC56_RST_VECTOR
    44  8000 4c3180                     jmp hbc56Main
    45                          
    46                          } else {
    47                          
    48                                  ; otherwise, place the program in RAM
    49                          
    50                                  *=$0400

; ******** Source: lcd12864gallery.asm
     9                          
    10                          
    11                          BUFFER_ADDR = $1000
    12                          
    13                          TMP1 	= HBC56_USER_ZP_START
    14                          
    15                          ; -----------------------------------------------------------------------------
    16                          ; metadata for the HBC-56 kernel
    17                          ; -----------------------------------------------------------------------------
    18                          hbc56Meta:
    19  8003 4c16805049435455...        +setHbcMetaTitle "PICTURE GALLERY"
    20  8028 ad9a7c09208d9a7c           +consoleLCDMode
    21  8030 60                         rts
    22                          
    23                          hbc56Main:
    24                          
    25  8031 20dee5             	jsr lcdInit
    26  8034 20f0e5             	jsr lcdClear
    27  8037 201ae5             	jsr lcdGraphicsMode
    28                          
    29                          start:
    30                          
    31  803a a900               	lda #0
    32  803c 851e               	sta PIX_ADDR
    33                          	
    34                          
    35                          
    36                          mainLoop:
    37  803e a987               	lda #>LOGO_IMG
    38  8040 8520               	sta BITMAP_ADDR_H
    39  8042 2097e5             	jsr lcdImageVflip
    40                          	
    41  8045 20ce80             	jsr longDelay
    42                          
    43  8048 a98c               	lda #>ROX_IMG
    44  804a 8520               	sta BITMAP_ADDR_H
    45  804c 2097e5             	jsr lcdImageVflip
    46                          	
    47  804f 20ce80             	jsr longDelay
    48                          	
    49  8052 a982               	lda #>LIV_IMG
    50  8054 8520               	sta BITMAP_ADDR_H
    51  8056 2097e5             	jsr lcdImageVflip
    52                          	
    53  8059 20ce80             	jsr longDelay
    54                          
    55  805c a991               	lda #>SELFIE_IMG
    56  805e 8520               	sta BITMAP_ADDR_H
    57  8060 2097e5             	jsr lcdImageVflip
    58                          	
    59  8063 20ce80             	jsr longDelay
    60                          	
    61  8066 206c80             	jsr rectDemo
    62                          	
    63  8069 4c3e80             	jmp mainLoop
    64                          
    65                          rectDemo:
    66                          
    67  806c a910               	lda #>BUFFER_ADDR
    68  806e 8520               	sta BITMAP_ADDR_H
    69                          
    70  8070 2069e2             	jsr bitmapClear
    71                          
    72  8073 a91e               	lda #30
    73  8075 8534               	sta TMP1
    74                          
    75                          -	
    76  8077 a91f               	lda #31
    77  8079 38                 	sec
    78  807a e534               	sbc TMP1
    79  807c 8d177b             	sta BITMAP_X1
    80  807f 8d187b             	sta BITMAP_Y1
    81  8082 a534               	lda TMP1
    82  8084 18                 	clc
    83  8085 6960               	adc #96	
    84  8087 8d197b             	sta BITMAP_X2
    85  808a a534               	lda TMP1
    86  808c 18                 	clc
    87  808d 6920               	adc #32	
    88  808f 8d1a7b             	sta BITMAP_Y2
    89                          	
    90  8092 20b9e4             	jsr bitmapRect
    91                          	
    92  8095 2057e5             	jsr lcdImage
    93                          	
    94                          	;jsr medDelay
    95                          	
    96  8098 c634               	dec TMP1
    97  809a c634               	dec TMP1
    98  809c d0d9               	bne -
    99                          
   100  809e a900               	lda #0
   101  80a0 8534               	sta TMP1
   102                          
   103                          -	
   104  80a2 a91f               	lda #31
   105  80a4 38                 	sec
   106  80a5 e534               	sbc TMP1
   107  80a7 8d177b             	sta BITMAP_X1
   108  80aa 8d187b             	sta BITMAP_Y1
   109  80ad a534               	lda TMP1
   110  80af 18                 	clc
   111  80b0 6960               	adc #96	
   112  80b2 8d197b             	sta BITMAP_X2
   113  80b5 a534               	lda TMP1
   114  80b7 18                 	clc
   115  80b8 6920               	adc #32
   116  80ba 8d1a7b             	sta BITMAP_Y2
   117                          	
   118  80bd 20e2e4             	jsr bitmapFilledRect
   119                          	
   120  80c0 2057e5             	jsr lcdImage
   121                          	
   122                          	;jsr medDelay
   123                          	
   124  80c3 e634               	inc TMP1
   125  80c5 e634               	inc TMP1
   126  80c7 a534               	lda TMP1
   127  80c9 c91e               	cmp #30
   128  80cb d0d5               	bne -
   129                          
   130  80cd 60                 	rts
   131                          
   132                          
   133                          
   134                          longDelay:
   135  80ce 20e1ff             	jsr hbc56Delay
   136  80d1 20e1ff             	jsr hbc56Delay
   137  80d4 20e1ff             	jsr hbc56Delay
   138  80d7 20e1ff             	jsr hbc56Delay
   139  80da 20e1ff             	jsr hbc56Delay
   140  80dd 20e1ff             	jsr hbc56Delay
   141  80e0 20e1ff             	jsr hbc56Delay
   142  80e3 20e1ff             	jsr hbc56Delay
   143                          
   144  80e6 4ce1ff             	jmp hbc56Delay
   145                          
   146                          	
   147                          ;IMG_DATA_OFFSET = 62  ; Paint
   148                          IMG_DATA_OFFSET = 130  ; GIMP
   149                          
   150  80e9 eaeaeaeaeaeaeaea...!align 255, 0
   151  8100 0000000000000000...!fill 256 - IMG_DATA_OFFSET
   152                          
   153                          livData:
   154  817e 424d820400000000...	!bin "img/liv.bmp"
   155                          
   156                          LIV_IMG = livData + IMG_DATA_OFFSET
   157                          
   158                          
   159                          !align 255, 0
   160  8600 0000000000000000...!fill 256 - IMG_DATA_OFFSET
   161                          
   162                          logoData:
   163  867e 424d820400000000...	!bin "img/logo.bmp"
   164                          
   165                          LOGO_IMG = logoData + IMG_DATA_OFFSET
   166                          
   167                          
   168                          !align 255, 0
   169  8b00 0000000000000000...!fill 256 - IMG_DATA_OFFSET
   170                          
   171                          roxData:
   172  8b7e 424d820400000000...	!bin "img/rox.bmp"
   173                          
   174                          ROX_IMG = roxData + IMG_DATA_OFFSET
   175                          
   176                          
   177                          !align 255, 0
   178  9000 0000000000000000...!fill 256 - IMG_DATA_OFFSET
   179                          
   180                          selfieData:
   181  907e 424d820400000000...	!bin "img/selfie.bmp"
   182                          
   183                          SELFIE_IMG = selfieData + IMG_DATA_OFFSET

; ******** Source: kernel.asm
     1                          ; 6502 - HBC-56 Kernel
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          ;
    10                          
    11                          HBC56_INT_VECTOR = $7e00
    12                          HBC56_NMI_VECTOR = $7e04
    13                          HBC56_RST_VECTOR = kernelMain
    14                          
    15                          HBC56_KERNEL_START = $e000
    16                          HBC56_META_VECTOR  = HBC56_KERNEL_START-4
    17                          
    18                          RTI_OPCODE = $40
    19                          JMP_OPCODE = $4c
    20                          
    21                          ; -------------------------
    22                          ; I/O devices
    23                          ; -------------------------
    24                          LCD_IO_PORT             = $02
    25                          TMS9918_IO_PORT         = $10
    26                          UART_IO_PORT            = $20
    27                          AY_IO_PORT              = $40
    28                          KB_IO_PORT              = $80
    29                          NES_IO_PORT             = $82
    30                          INT_IO_PORT             = $df
    31                          VIA_IO_PORT             = $f0
    32                          
    33                          ; -------------------------
    34                          ; Kernel Zero Page
    35                          ; -------------------------
    36                          HBC56_KERNEL_ZP_START   = $18
    37                          
    38                          TILEMAP_ZP_START        = HBC56_KERNEL_ZP_START
    39                          TILEMAP_ZP_END          = TILEMAP_ZP_START + 6
    40                          
    41                          BITMAP_ZP_START         = TILEMAP_ZP_END
    42                          BITMAP_ZP_END           = BITMAP_ZP_START + 6
    43                          
    44                          !ifdef HBC56_DISABLE_TMS9918 { .TMS_ZP_SIZE = 0 } else { .TMS_ZP_SIZE = 4 }
    45                          TMS9918_ZP_START        = BITMAP_ZP_END
    46                          TMS9918_ZP_END          = TMS9918_ZP_START + .TMS_ZP_SIZE
    47                          
    48                          !ifdef HBC56_DISABLE_LCD { .LCD_ZP_SIZE = 0 } else { .LCD_ZP_SIZE = 2 }
    49                          LCD_ZP_START            = TMS9918_ZP_END
    50                          LCD_ZP_END              = LCD_ZP_START + .LCD_ZP_SIZE
    51                          
    52                          !ifdef HBC56_DISABLE_UART { .UART_ZP_SIZE = 0 } else { .UART_ZP_SIZE = 4 }
    53                          UART_ZP_START            = LCD_ZP_END
    54                          UART_ZP_END              = UART_ZP_START + .UART_ZP_SIZE
    55                          
    56                          MEMORY_ZP_START         = UART_ZP_END
    57                          MEMORY_ZP_END           = MEMORY_ZP_START + 6
    58                          
    59                          STR_ADDR                = MEMORY_ZP_END
    60                          STR_ADDR_L              = MEMORY_ZP_END
    61                          STR_ADDR_H              = MEMORY_ZP_END + 1
    62                          
    63                          DELAY_L                 = STR_ADDR_H + 1
    64                          DELAY_H                 = DELAY_L + 1
    65                          
    66                          HBC56_KERNEL_ZP_END     = DELAY_H + 1
    67                          HBC56_USER_ZP_START     = HBC56_KERNEL_ZP_END
    68                          
    69                          ;!warn "Total ZP used: ",STR_ADDR_H-HBC56_KERNEL_ZP_START
    70                          
    71                          
    72                          !ifndef HAVE_TMS9918 { HBC56_DISABLE_SFXMAN=1 }
    73                          
    74                          ; -------------------------
    75                          ; Kernel RAM
    76                          ; -------------------------
    77                          HBC56_KERNEL_RAM_START  = $7a00
    78                          
    79                          TILEMAP_RAM_START       = HBC56_KERNEL_RAM_START
    80                          TILEMAP_RAM_END         = TILEMAP_RAM_START + $116
    81                          
    82                          BITMAP_RAM_START        = TILEMAP_RAM_END
    83                          BITMAP_RAM_END          = BITMAP_RAM_START + 16
    84                          
    85                          !ifdef HBC56_DISABLE_TMS9918 { .TMS_RAM_SIZE = 0 } else { .TMS_RAM_SIZE = 50 }
    86                          TMS9918_RAM_START       = BITMAP_RAM_END
    87                          TMS9918_RAM_END         = TMS9918_RAM_START + .TMS_RAM_SIZE
    88                          
    89                          !ifdef HBC56_DISABLE_LCD { .LCD_RAM_SIZE = 0 } else { .LCD_RAM_SIZE = 42 }
    90                          LCD_RAM_START           = TMS9918_RAM_END
    91                          LCD_RAM_END             = LCD_RAM_START + .LCD_RAM_SIZE
    92                          
    93                          !ifdef HBC56_DISABLE_UART { .UART_RAM_SIZE = 0 } else { .UART_RAM_SIZE = 256 }
    94                          UART_RAM_START            = LCD_RAM_END
    95                          UART_RAM_END              = UART_RAM_START + .UART_RAM_SIZE
    96                          
    97                          !ifdef HBC56_DISABLE_SFXMAN { .SFXMAN_RAM_SIZE = 0 } else { .SFXMAN_RAM_SIZE = 18 }
    98                          SFXMAN_RAM_START        = UART_RAM_END
    99                          SFXMAN_RAM_END          = SFXMAN_RAM_START + .SFXMAN_RAM_SIZE
   100                          
   101                          BCD_RAM_START           = SFXMAN_RAM_END
   102                          BCD_RAM_END             = BCD_RAM_START + 3
   103                          
   104                          KB_RAM_START            = BCD_RAM_END
   105                          KB_RAM_END              = KB_RAM_START + 64
   106                          
   107                          NES_RAM_START            = KB_RAM_END
   108                          NES_RAM_END              = NES_RAM_START + 3
   109                          
   110                          LAST_MODULE_RAM_END     = NES_RAM_END
   111                          
   112                          HBC56_TICKS             = LAST_MODULE_RAM_END
   113                          HBC56_SECONDS_L         = LAST_MODULE_RAM_END + 1
   114                          HBC56_SECONDS_H         = LAST_MODULE_RAM_END + 2
   115                          HBC56_TMP               = LAST_MODULE_RAM_END + 3
   116                          
   117                          HBC56_CONSOLE_FLAGS     = LAST_MODULE_RAM_END + 4
   118                          HBC56_CONSOLE_FLAG_CURSOR = $80
   119                          HBC56_CONSOLE_FLAG_NES    = $40
   120                          HBC56_CONSOLE_FLAG_LCD    = $20
   121                          HBC56_CONSOLE_FLAG_NOWAIT = $10
   122                          
   123                          HBC56_TMP_X             = LAST_MODULE_RAM_END + 5
   124                          HBC56_TMP_Y             = LAST_MODULE_RAM_END + 6
   125                          
   126                          HBC56_META_TITLE_MAX_LEN = 16
   127                          HBC56_META_TITLE        = LAST_MODULE_RAM_END + 7
   128                          HBC56_META_TITLE_END    = HBC56_META_TITLE + HBC56_META_TITLE_MAX_LEN + 1
   129                          HBC56_META_TITLE_LEN    = HBC56_META_TITLE_END + 1
   130                          
   131                          ; callback function on vsync
   132                          HBC56_VSYNC_CALLBACK = HBC56_META_TITLE_LEN + 1
   133                          
   134                          
   135                          HBC56_KERNEL_RAM_END    = HBC56_VSYNC_CALLBACK + 2
   136                          HBC56_KERNEL_RAM_SIZE   = HBC56_KERNEL_RAM_END - HBC56_KERNEL_RAM_START
   137                          ;!warn "Total RAM used: ",HBC56_KERNEL_RAM_SIZE
   138                          

; ******** Source: ../lib\hbc56.asm
     1                          ; 6502 - HBC-56
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          ;
    10                          
    11                          !cpu w65c02
    12                          !initmem $FF
    13                          cputype = $65c02
    14                          

; ******** Source: ../lib\hbc56.inc
     1                          ; 6502 - HBC-56
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          ;
    10                          
    11                          ; Base address of the 256 IO port memory range
    12                          IO_PORT_BASE_ADDRESS    = $7f00
    13                          
    14                          
    15                          ; -------------------------
    16                          ; ASCII constants
    17                          ; -------------------------
    18                          ASCII_RETURN    = $0A
    19                          ASCII_CR        = $0D
    20                          ASCII_BACKSPACE = $08
    21                          ASCII_BELL      = $07

; ******** Source: ../lib\hbc56.asm
    16                          
    17                          DEFAULT_HBC56_NMI_VECTOR = $FFE0
    18                          DEFAULT_HBC56_RST_VECTOR = $8000
    19                          DEFAULT_HBC56_INT_VECTOR = $FFE0
    20                          
    21                          !macro hbc56Title .title {
    22                          HBC56_TITLE_TEXT:
    23                                  !text .title
    24                          HBC56_TITLE_TEXT_LEN = * - HBC56_TITLE_TEXT
    25                                  !byte 0 ; nul terminator for game name
    26                          }
    27                          
    28                          *=DEFAULT_HBC56_INT_VECTOR
    29  ffe0 40                         rti
    30                          
    31                          hbc56Delay:
    32  ffe1 a000                       ldy #0
    33                          hbc56CustomDelay:
    34  ffe3 a200                       ldx #0
    35                          -
    36  ffe5 ca                         dex
    37  ffe6 d0fd                       bne -
    38  ffe8 a200                       ldx #0
    39  ffea 88                         dey
    40  ffeb d0f8                       bne -
    41  ffed 60                         rts
    42                          
    43                          *=$FFFA
    44  fffa 047e               !ifdef HBC56_NMI_VECTOR { !word HBC56_NMI_VECTOR } else { !word DEFAULT_HBC56_NMI_VECTOR }
    45  fffc a1f1               !ifdef HBC56_RST_VECTOR { !word HBC56_RST_VECTOR } else { !word DEFAULT_HBC56_RST_VECTOR }
    46  fffe 007e               !ifdef HBC56_INT_VECTOR { !word HBC56_INT_VECTOR } else { !word DEFAULT_HBC56_INT_VECTOR }
    47                          
    48                          
    49                          *=DEFAULT_HBC56_RST_VECTOR

; ******** Source: kernel.asm
   140                          *=HBC56_KERNEL_START
   141                          

; ******** Source: ../lib\ut\ascii.asm
     1                          ; 6502 - ASCII subroutines
     2                          ;
     3                          ; Copyright (c) 2022 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          ;
    10                          
    11                          ; -----------------------------------------------------------------------------
    12                          ; isLower: Is the ASCII character a lower-case letter (a-z)
    13                          ; -----------------------------------------------------------------------------
    14                          ; Inputs:
    15                          ;   A: ASCII character
    16                          ; Outputs:
    17                          ;   Carry set if lower case, carry clear if not lower case
    18                          ; -----------------------------------------------------------------------------
    19                          isLower:
    20  e000 c961                       cmp #'a'
    21  e002 9005                       bcc @notLower   ; less than 'a'?
    22  e004 c97b                       cmp #'z' + 1
    23  e006 9002                       bcc @isLower    ; less than or equal 'z'?
    24  e008 18                         clc
    25                          @notLower:
    26  e009 60                         rts
    27                          
    28                          @isLower
    29  e00a 38                         sec
    30  e00b 60                         rts
    31                          
    32                          
    33                          ; -----------------------------------------------------------------------------
    34                          ; isUpper: Is the ASCII character a upper-case letter (A-Z)
    35                          ; -----------------------------------------------------------------------------
    36                          ; Inputs:
    37                          ;   A: ASCII character
    38                          ; Outputs:
    39                          ;   Carry set if upper case, carry clear if not upper case
    40                          ; -----------------------------------------------------------------------------
    41                          isUpper:
    42  e00c c941                       cmp #'A'
    43  e00e 9005                       bcc @notUpper   ; less than 'A'?
    44  e010 c95b                       cmp #'Z' + 1
    45  e012 9002                       bcc @isUpper    ; less than or equal 'Z'?
    46  e014 18                         clc
    47                          @notUpper:
    48  e015 60                         rts
    49                          
    50                          @isUpper
    51  e016 38                         sec
    52  e017 60                         rts
    53                          
    54                          ; -----------------------------------------------------------------------------
    55                          ; isAlpha: Is the ASCII character alphanumeric (A-Z, a-z)
    56                          ; -----------------------------------------------------------------------------
    57                          ; Inputs:
    58                          ;   A: ASCII character
    59                          ; Outputs:
    60                          ;   Carry set if alpha, carry clear if not alpha
    61                          ; -----------------------------------------------------------------------------
    62                          isAlpha:
    63  e018 2000e0                     jsr isLower
    64  e01b 90ef                       bcc isUpper
    65  e01d 60                         rts
    66                          
    67                          
    68                          ; -----------------------------------------------------------------------------
    69                          ; isDigit: Is the ASCII character a decimal digit (0-9)
    70                          ; -----------------------------------------------------------------------------
    71                          ; Inputs:
    72                          ;   A: ASCII character
    73                          ; Outputs:
    74                          ;   Carry set if digit, carry clear if not digit
    75                          ; -----------------------------------------------------------------------------
    76                          isDigit:
    77  e01e c930                       cmp #'0'
    78  e020 9005                       bcc @notDigit    ; less than '0'?
    79  e022 c93a                       cmp #'9' + 1
    80  e024 9002                       bcc @isDigit     ; less than or equal '9'?
    81  e026 18                         clc
    82                          
    83                          @notDigit:
    84  e027 60                         rts
    85                          
    86                          @isDigit
    87  e028 38                         sec
    88  e029 60                         rts
    89                          
    90                          
    91                          ; -----------------------------------------------------------------------------
    92                          ; isAlNum: Is the ASCII character alphanumeric (A-Z, a-z, 0-9)
    93                          ; -----------------------------------------------------------------------------
    94                          ; Inputs:
    95                          ;   A: ASCII character
    96                          ; Outputs:
    97                          ;   Carry set if alphanumeric, carry clear if not alphanumeric
    98                          ; -----------------------------------------------------------------------------
    99                          isAlNum:
   100  e02a 2018e0                     jsr isAlpha
   101  e02d 90ef                       bcc isDigit
   102  e02f 60                         rts
   103                          
   104                          ; -----------------------------------------------------------------------------
   105                          ; isDigitX: Is the ASCII character a hex digit (A-F, a-f, 0-9)
   106                          ; -----------------------------------------------------------------------------
   107                          ; Inputs:
   108                          ;   A: ASCII character
   109                          ; Outputs:
   110                          ;   Carry set if hexadecimal, carry clear if not hexadecimal
   111                          ; -----------------------------------------------------------------------------
   112                          isDigitX:
   113  e030 201ee0                     jsr isDigit
   114  e033 b013                       bcs @endIsDigitX
   115  e035 c941                       cmp #'A'
   116  e037 900d                       bcc @notHexDigit   ; less than 'A'?
   117  e039 c947                       cmp #'F' + 1
   118  e03b 900a                       bcc @isHexDigit    ; less than or equal 'F'?
   119  e03d c961                       cmp #'a'
   120  e03f 9005                       bcc @notHexDigit   ; less than 'a'?
   121  e041 c967                       cmp #'f' + 1
   122  e043 9002                       bcc @isHexDigit    ; less than or equal 'f'?
   123  e045 18                         clc
   124                          @notHexDigit:
   125  e046 60                         rts
   126                          
   127                          @isHexDigit
   128  e047 38                         sec
   129                          
   130                          @endIsDigitX
   131  e048 60                         rts
   132                          
   133                          
   134                          ; -----------------------------------------------------------------------------
   135                          ; isSpace: Is the ASCII character a whitespace character?
   136                          ; -----------------------------------------------------------------------------
   137                          ; Inputs:
   138                          ;   A: ASCII character
   139                          ; Outputs:
   140                          ;   Carry set if space, carry clear if not space
   141                          ; -----------------------------------------------------------------------------
   142                          isSpace:
   143  e049 c920                       cmp #' '
   144  e04b f01c                       beq @isSpace
   145  e04d b018                       bcs @notSpace
   146  e04f c90a                       cmp #'\n'
   147  e051 f016                       beq @isSpace
   148  e053 c90d                       cmp #'\r'
   149  e055 f012                       beq @isSpace
   150  e057 c909                       cmp #'\t'
   151  e059 f00e                       beq @isSpace
   152  e05b c90d                       cmp #'\r'
   153  e05d f00a                       beq @isSpace
   154  e05f c90b                       cmp #$0b
   155  e061 f006                       beq @isSpace
   156  e063 c90c                       cmp #$0c
   157  e065 f002                       beq @isSpace
   158                          
   159                          @notSpace:
   160  e067 18                         clc
   161  e068 60                         rts
   162                          
   163                          @isSpace
   164  e069 38                         sec
   165  e06a 60                         rts
   166                          
   167                          ; -----------------------------------------------------------------------------
   168                          ; toUpper: convert an ascii character to upper case
   169                          ; -----------------------------------------------------------------------------
   170                          ; Inputs:
   171                          ;   A: ascii character
   172                          ; Outputs:
   173                          ;   A: upper case ascii character
   174                          ;   C: set if character was converted
   175                          ; -----------------------------------------------------------------------------
   176                          toUpper:
   177  e06b 2000e0                     jsr isLower
   178  e06e 9002                       bcc @endToUpper
   179  e070 4920                       eor #$20        ; convert (subtract $20)
   180                          
   181                          @endToUpper
   182  e072 60                         rts        
   183                          
   184                          ; -----------------------------------------------------------------------------
   185                          ; toLower: convert an ascii character to lower case
   186                          ; -----------------------------------------------------------------------------
   187                          ; Inputs:
   188                          ;   A: ascii character
   189                          ; Outputs:
   190                          ;   A: lower case ascii character
   191                          ;   C: set if character was converted
   192                          ; -----------------------------------------------------------------------------
   193                          toLower:
   194  e073 200ce0                     jsr isUpper
   195  e076 9002                       bcc @endToUpper
   196                          
   197  e078 0920                       ora #$20        ; convert (add $20)
   198                          
   199                          @endToUpper

; ******** Source: kernel.asm

; ******** Source: ../lib\ut\bcd.asm
     1  e07a 60                 ; 6502 - BCD subroutines
     2                          ;
     3                          ; Copyright (c) 2020 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          ;
    10                          
    11                          
    12                          !ifndef BCD_RAM_START { BCD_RAM_START = $10
    13                                  !warn "BCD_RAM_START not provided. Defaulting to ", BCD_RAM_START
    14                          }
    15                          
    16                          ; -------------------------
    17                          ; High RAM
    18                          ; -------------------------
    19                          BCD_TMP1        = BCD_RAM_START
    20                          BCD_TMP2        = BCD_RAM_START + 1
    21                          BCD_TMP3        = BCD_RAM_START + 2
    22                          BCD_RAM_SIZE    = 3
    23                          
    24                          
    25                          !if BCD_RAM_END < (BCD_RAM_START + BCD_RAM_SIZE) {
    26                                  !error "BCD_RAM requires ",BCD_RAM_SIZE," bytes. Allocated ",BCD_RAM_END - BCD_RAM_START
    27                          }
    28                          
    29                          
    30                          ; -----------------------------------------------------------------------------
    31                          ; bin2bcd8: convert an unsigned byte to a 2-digit bcd value
    32                          ; -----------------------------------------------------------------------------
    33                          ; Inputs:
    34                          ;   A: value
    35                          ; Outputs:
    36                          ;   BCD value in R8
    37                          ; -----------------------------------------------------------------------------
    38                          bin2bcd8:
    39  e07b 8d507c               sta BCD_TMP1
    40  e07e a900                 lda #0
    41  e080 8d517c               sta BCD_TMP2
    42  e083 8d527c               sta BCD_TMP3
    43  e086 a208                 ldx #8 
    44  e088 f8                   sed    
    45                          .loop:
    46  e089 0e507c               asl BCD_TMP1
    47  e08c ad517c               lda BCD_TMP2
    48  e08f 6d517c               adc BCD_TMP2
    49  e092 8d517c               sta BCD_TMP2
    50  e095 ad527c               lda BCD_TMP3
    51  e098 6d527c               adc BCD_TMP3
    52  e09b 8d527c               sta BCD_TMP3
    53  e09e ca                   dex
    54  e09f d0e8                 bne .loop
    55  e0a1 d8                   cld   
    56  e0a2 60                   rts
    57                          

; ******** Source: kernel.asm

; ******** Source: ../lib\ut\memory.asm
     1                          ; 6502
     2                          ;
     3                          ; Memory subroutines and macros
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/hbc-56
    10                          ;
    11                          ;
    12                          

; ******** Source: ../lib\ut\memory.inc
     1                          ; 6502
     2                          ;
     3                          ; Memory subroutines and macros
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/hbc-56
    10                          ;
    11                          ;
    12                          
    13                          ; -----------------------------------------------------------------------------
    14                          ; store16: Write a 16-bit immediate value to memory
    15                          ; -----------------------------------------------------------------------------
    16                          ; Inputs:
    17                          ;       .dst: destination address
    18                          ;       .val16: 16-bit value
    19                          ; -----------------------------------------------------------------------------
    20                          !macro store16 .dst, .val16 {
    21                                  lda #<.val16
    22                                  sta .addr
    23                                  lda #>.val16
    24                                  sta .addr + 1
    25                          }
    26                          
    27                          ; -----------------------------------------------------------------------------
    28                          ; memcpy: Copy a fixed number of bytes from .src to dest
    29                          ; -----------------------------------------------------------------------------
    30                          ; Inputs:
    31                          ;       .src: source address
    32                          ;       .dst: destination address
    33                          ;       .cnt: number of bytes
    34                          ; -----------------------------------------------------------------------------
    35                          !macro memcpy .dst, .src, .cnt {
    36                          !if .cnt <= 0 {
    37                                  !error "memcpy: invalid count: ", .cnt
    38                          } else if .cnt <= 8 {
    39                                  !for i, 0, .cnt - 1 {
    40                                          lda .src + i
    41                                          sta .dst + i
    42                                  }
    43                          } else { !if .cnt <= 256 {
    44                                  ldx #0
    45                          -
    46                                  lda .src, x
    47                                  sta .dst, x
    48                                  inx
    49                                  cpx #(.cnt & $ff)       
    50                                  bne -
    51                          } else {
    52                                  lda #<.src
    53                                  sta MEM_SRC
    54                                  lda #>.src
    55                                  sta MEM_SRC + 1
    56                          
    57                                  lda #<.dst
    58                                  sta MEM_DST
    59                                  lda #>.dst
    60                                  sta MEM_DST + 1
    61                          
    62                          
    63                                          lda #<.cnt
    64                                          sta MEMCPY_LEN
    65                                          lda #>.cnt
    66                                          sta MEMCPY_LEN + 1
    67                                          jsr memcpyMultiPage
    68                                  }
    69                          }
    70                          }
    71                          
    72                          !macro setMemCpySrc .src {
    73                                  lda #<.src
    74                                  sta MEM_SRC
    75                                  lda #>.src
    76                                  sta MEM_SRC + 1
    77                          }
    78                          
    79                          !macro setMemCpyDst .dst {
    80                                  lda #<.dst
    81                                  sta MEM_DST
    82                                  lda #>.dst
    83                                  sta MEM_DST + 1
    84                          }
    85                          
    86                          !macro setMemCpySrcInd .srcRef {
    87                                  lda .srcRef
    88                                  sta MEM_SRC
    89                                  lda .srcRef + 1
    90                                  sta MEM_SRC + 1
    91                          }
    92                          
    93                          !macro setMemCpyDstInd .dstRef {
    94                                  lda .dstRef
    95                                  sta MEM_DST
    96                                  lda .dstRef + 1
    97                                  sta MEM_DST + 1
    98                          }
    99                          
   100                          !macro memcpySinglePage .bytes {
   101                          
   102                                  !if .bytes <= 0 {
   103                                          !error "memcpySinglePage: invalid count: ", .bytes
   104                                  }       
   105                          
   106                                  ldy #.bytes
   107                                  jsr memcpySinglePage
   108                          }
   109                          
   110                          
   111                          ; -----------------------------------------------------------------------------
   112                          ; memcpyPort: Copy a fixed number of bytes from .src ram to dest port
   113                          ; -----------------------------------------------------------------------------
   114                          ; Inputs:
   115                          ;       .src: source address
   116                          ;       .dst: destination address
   117                          ;       .cnt: number of bytes
   118                          ; -----------------------------------------------------------------------------
   119                          !macro memcpyPort .dst, .src, .cnt {
   120                                  !if .cnt <= 0 {
   121                                          !error "memcpyPort: invalid count: ", .cnt
   122                                  }
   123                                  
   124                                  lda #<.src
   125                                  sta MEM_SRC
   126                                  lda #>.src
   127                                  sta MEM_SRC + 1
   128                          
   129                                  lda #<.dst
   130                                  sta MEM_DST
   131                                  lda #>.dst
   132                                  sta MEM_DST + 1
   133                          
   134                                  !if .cnt <= 256 {
   135                                          ldy #<.cnt                                      
   136                                          jsr memcpySinglePagePort
   137                                  } else {
   138                                          lda #<.cnt
   139                                          sta MEMCPY_LEN
   140                                          lda #>.cnt
   141                                          sta MEMCPY_LEN + 1
   142                                          jsr memcpyMultiPagePort
   143                                  }
   144                          }
   145                          
   146                          !zone {
   147                          
   148                          ; -----------------------------------------------------------------------------
   149                          ; memset: Set a fixed number of bytes to a single value
   150                          ; -----------------------------------------------------------------------------
   151                          ; Inputs:
   152                          ;       .dst: destination address
   153                          ;       val: the byte value
   154                          ;       .cnt: number of bytes
   155                          ; -----------------------------------------------------------------------------
   156                          !macro memset .dst, .val, .cnt {
   157                          !if .cnt <= 0 {
   158                                  !error "memset: invalid count: ", .cnt
   159                          } else if .cnt <= 8 {
   160                                  lda #.val
   161                                  !for i, 0, .cnt - 1 {
   162                                  sta .dst + i
   163                                  }
   164                          } else if .cnt <= 256 {
   165                                  ldx #<.cnt
   166                                  lda #.val
   167                          -
   168                                  dex
   169                                  sta .dst, x
   170                                  cpx #0
   171                                  bne -
   172                          } else {
   173                                  lda #<.dst
   174                                  sta MEM_DST
   175                                  lda #>.dst
   176                                  sta MEM_DST + 1
   177                                  lda #<.cnt
   178                                  sta MEM_LEN
   179                                  lda #>.cnt
   180                                  sta MEM_LEN + 1
   181                                  lda #.val
   182                                  jsr memsetMultiPage
   183                          }
   184                          }
   185                          
   186                          

; ******** Source: ../lib\ut\memory.asm
    14                          
    15                          
    16                          !ifndef MEMORY_ZP_START { MEMORY_ZP_START = $48
    17                                  !warn "MEMORY_ZP_START not provided. Defaulting to ", MEMORY_ZP_START
    18                          }
    19                          
    20                          ; -------------------------
    21                          ; Zero page
    22                          ; -------------------------
    23                          MEM_DST = MEMORY_ZP_START
    24                          MEM_SRC = MEMORY_ZP_START + 2
    25                          MEM_LEN = MEMORY_ZP_START + 4
    26                          MEMORY_ZP_SIZE  = 6
    27                          
    28                          
    29                          !if MEMORY_ZP_END < (MEMORY_ZP_START + MEMORY_ZP_SIZE) {
    30                                  !error "MEMORY_ZP requires ",MEMORY_ZP_SIZE," bytes. Allocated ",MEMORY_ZP_END - MEMORY_ZP_START
    31                          }
    32                          
    33                          ; -----------------------------------------------------------------------------
    34                          ; memcpySinglePage: Copy up to 255 bytes 
    35                          ; -----------------------------------------------------------------------------
    36                          ; Inputs:
    37                          ;       MEM_SRC: src address
    38                          ;       MEM_DST: dst address
    39                          ;       Y:      bytes
    40                          ; -----------------------------------------------------------------------------
    41                          memcpySinglePage:
    42  e0a3 c000                       cpy #0
    43  e0a5 f009                       beq .endMemcpySinglePage
    44                          -
    45  e0a7 88                         dey
    46  e0a8 b12c                       lda (MEM_SRC), Y
    47  e0aa 912a                       sta (MEM_DST), Y
    48  e0ac c000                       cpy #0
    49  e0ae d0f7                       bne -
    50                          .endMemcpySinglePage:
    51  e0b0 60                         rts
    52                          ; -----------------------------------------------------------------------------
    53                          
    54                          
    55                          
    56                          ; -----------------------------------------------------------------------------
    57                          ; memcpySinglePagePort: Copy up to 255 bytes 
    58                          ; -----------------------------------------------------------------------------
    59                          ; Inputs:
    60                          ;       MEM_SRC: src address
    61                          ;       MEM_DST: dst address (port)
    62                          ;       Y:      bytes
    63                          ; -----------------------------------------------------------------------------
    64                          memcpySinglePagePort:
    65  e0b1 c000                       cpy #0
    66  e0b3 f009                       beq .endMemcpySinglePagePort
    67                          -
    68  e0b5 88                         dey
    69  e0b6 b12c                       lda (MEM_SRC), Y
    70  e0b8 852a                       sta MEM_DST
    71  e0ba c000                       cpy #0
    72  e0bc d0f7                       bne -
    73                          .endMemcpySinglePagePort
    74  e0be 60                         rts
    75                          ; -----------------------------------------------------------------------------
    76                          
    77                          
    78                          
    79                          ; -----------------------------------------------------------------------------
    80                          ; memcpyMultiPage: Copy an up to 2^15 bytes 
    81                          ; -----------------------------------------------------------------------------
    82                          ; Inputs:
    83                          ;       MEM_SRC: src address
    84                          ;       MEM_DST: dst address
    85                          ;       MEM_LEN: length
    86                          ; -----------------------------------------------------------------------------
    87                          memcpyMultiPage:
    88                          
    89                          !ifdef ALLOW_SELF_MODIFYING_CODE {
    90                                  lda MEM_SRC
    91                                  sta .loadIns + 1
    92                                  lda MEM_SRC + 1
    93                                  sta .loadIns + 2
    94                          
    95                                  lda MEM_DST
    96                                  sta .storeIns + 1
    97                                  lda MEM_DST + 1
    98                                  sta .storeIns + 2
    99                          
   100                          .loadIns:
   101                                  lda SELF_MODIFY_ADDR, Y
   102                                  
   103                          .storeIns:
   104                                  sta SELF_MODIFY_ADDR, Y
   105                                  dey
   106                                  bne .loadIns
   107                                  inc .loadIns + 2
   108                                  inc .storeIns + 2
   109                                  dex
   110                                  bne .loadIns
   111                          } else {
   112  e0bf a000                       ldy #0
   113  e0c1 a62f                       ldx MEM_LEN + 1
   114                          - 
   115  e0c3 b12c                       lda (MEM_SRC),y ; could unroll to any power of 2
   116  e0c5 912a                       sta (MEM_DST),y
   117  e0c7 c8                         iny
   118  e0c8 d0f9                       bne -
   119  e0ca ca                         dex
   120  e0cb f007                       beq .memcpyMultiPageRemaining
   121  e0cd e62d                       inc MEM_SRC + 1
   122  e0cf e62b                       inc MEM_DST + 1
   123  e0d1 4cc3e0                     jmp -
   124                          .memcpyMultiPageRemaining ; remaining bytes
   125  e0d4 a62e                       ldx MEM_LEN
   126  e0d6 f008                       beq .memcpyMultiPageEnd
   127                          - ; X bytes
   128  e0d8 b12c                       lda (MEM_SRC),y
   129  e0da 912a                       sta (MEM_DST),y
   130  e0dc c8                         iny
   131  e0dd ca                         dex
   132  e0de d0f8                       bne -
   133                          .memcpyMultiPageEnd
   134                          }
   135                          
   136  e0e0 60                         rts
   137                          ; -----------------------------------------------------------------------------
   138                          
   139                          
   140                          ; -----------------------------------------------------------------------------
   141                          ; memcpyMultiPagePort: Copy an up to 2^15 bytes 
   142                          ; -----------------------------------------------------------------------------
   143                          ; Inputs:
   144                          ;       MEM_SRC: src address
   145                          ;       MEM_DST: dst address (port)
   146                          ;       MEM_LEN: length
   147                          ; -----------------------------------------------------------------------------
   148                          memcpyMultiPagePort:
   149                          
   150  e0e1 a000                       ldy #0
   151  e0e3 a62f                       ldx MEM_LEN + 1
   152                          - 
   153  e0e5 b12c                       lda (MEM_SRC),y ; could unroll to any power of 2
   154  e0e7 852a                       sta MEM_DST
   155  e0e9 c8                         iny
   156  e0ea d0f9                       bne -
   157  e0ec ca                         dex
   158  e0ed f005                       beq .memcpyMultiPagePortRemaining
   159  e0ef e62d                       inc MEM_SRC + 1
   160  e0f1 4ce5e0                     jmp -
   161                          .memcpyMultiPagePortRemaining ; remaining bytes
   162  e0f4 a62e                       ldx MEM_LEN
   163  e0f6 f008                       beq .memcpyMultiPagePortEnd
   164                          - ; X bytes
   165  e0f8 b12c                       lda (MEM_SRC),y
   166  e0fa 852a                       sta MEM_DST
   167  e0fc c8                         iny
   168  e0fd ca                         dex
   169  e0fe d0f8                       bne -
   170                          .memcpyMultiPagePortEnd
   171  e100 60                         rts
   172                          ; -----------------------------------------------------------------------------
   173                          
   174                          
   175                          ; -----------------------------------------------------------------------------
   176                          ; memsetSinglePage: set a block of memory data
   177                          ; -----------------------------------------------------------------------------
   178                          ; Inputs:
   179                          ;        A:     value to set
   180                          ;        MEM_DST: start address
   181                          ;        Y:     bytes
   182                          ; -----------------------------------------------------------------------------
   183                          memsetSinglePage:
   184  e101 c000                       cpy #0
   185  e103 f007                       beq .doneCpy
   186                          -
   187  e105 88                         dey
   188  e106 912a                       sta (MEM_DST), y
   189  e108 c000                       cpy #0
   190  e10a d0f9                       bne -
   191                          .doneCpy
   192  e10c 60                         rts
   193                          
   194                          
   195                          ; -----------------------------------------------------------------------------
   196                          ; memsetMultiPage: set a block of memory data
   197                          ; -----------------------------------------------------------------------------
   198                          ; Inputs:
   199                          ;        A: value
   200                          ;        MEM_DST: start address
   201                          ;        MEM_LEN: length
   202                          ; -----------------------------------------------------------------------------
   203                          memsetMultiPage:
   204  e10d a62f                       ldx MEM_LEN + 1
   205  e10f d005                       bne .doneSet
   206  e111 a42e                       ldy MEM_LEN
   207  e113 4c01e1                     jmp memsetSinglePage
   208                          .doneSet
   209  e116 a000                       ldy #0
   210                          - 
   211  e118 912a                       sta (MEM_DST),y ; could unroll to any power of 2
   212  e11a c8                         iny
   213  e11b d0fb                       bne -
   214  e11d ca                         dex
   215  e11e f005                       beq .doneSet2
   216  e120 e62b                       inc MEM_DST + 1
   217  e122 4c18e1                     jmp -
   218                          .doneSet2 ; remaining bytes
   219  e125 a62e                       ldx MEM_LEN
   220  e127 f006                       beq .doneSet3
   221                          - ; X bytes
   222  e129 912a                       sta (MEM_DST),y
   223  e12b c8                         iny
   224  e12c ca                         dex
   225  e12d d0fa                       bne -
   226                          .doneSet3
   227  e12f 60                         rts

; ******** Source: kernel.asm

; ******** Source: ../lib\ut\tables.asm
     1                          ; 6502 - Useful tables
     2                          ;
     3                          ; Copyright (c) 2022 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          ;
    10                          
    11                          tableBitFromLeft:
    12  e130 8040201008040201   !byte $80,$40,$20,$10,$08,$04,$02,$01
    13                          tableInvBitFromLeft:
    14  e138 7fbfdfeff7fbfdfe   !byte $7f,$bf,$df,$ef,$f7,$fb,$fd,$fe
    15                          tableBitFromRight:
    16  e140 0102040810204080   !byte $01,$02,$04,$08,$10,$20,$40,$80
    17                          tableInvBitFromRight:

; ******** Source: kernel.asm
   146  e148 fefdfbf7efdfbf7f   
   147                          !ifndef HBC56_DISABLE_AY3891X {

; ******** Source: ../lib\sfx\ay3891x.asm
     1                          ; 6502 - AY-3-819x PSG
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          

; ******** Source: ../lib\sfx\ay3891x.inc
     1                          ; 6502 - AY-3-819x PSG
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          
    10                          
    11                          
    12                          !macro ayWrite .dev, .reg, .val {
    13                                  lda #.reg
    14                                  sta IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_ADDR | .dev
    15                                  lda #.val
    16                                  sta IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_WRITE | .dev
    17                          }        
    18                          
    19                          !macro ayRead .dev, .reg {
    20                                  lda #.reg
    21                                  sta IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_ADDR | .dev
    22                                  lda IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_READ | .dev
    23                          }        
    24                          
    25                          
    26                          !macro ayWriteX .dev, .reg {
    27                                  lda #.reg
    28                                  sta IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_ADDR | .dev
    29                                  stx IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_WRITE | .dev
    30                          }
    31                          
    32                          !macro ayWriteA .dev, .reg {
    33                                  ldx #.reg
    34                                  stx IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_ADDR | .dev
    35                                  sta IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_WRITE | .dev
    36                          }
    37                          
    38                          !macro ayPlayNote .dev, .chan, .freq {
    39                                  !if .freq <= 0 {
    40                                          .val = 0
    41                                  } else {
    42                                          .val = AY_CLOCK_FREQ / (32.0 * .freq)
    43                                  }
    44                                  +ayWrite .dev, AY_CHA_TONE_L + (.chan * 2), <.val
    45                                  +ayWrite .dev, AY_CHA_TONE_H + (.chan * 2), >.val
    46                          }
    47                          
    48                          !macro ayToneWord .freq {
    49                                  !word (AY_CLOCK_FREQ / (32.0 * .freq))
    50                          }
    51                          
    52                          !macro ayToneByteL .freq {
    53                                  !byte <(AY_CLOCK_FREQ / (32.0 * .freq))
    54                          }
    55                          
    56                          !macro ayToneByteH .freq {
    57                                  !byte >(AY_CLOCK_FREQ / (32.0 * .freq))
    58                          }
    59                          
    60                          
    61                          !macro ayToneEnable .dev, .chan {
    62                                  +ayRead .dev, AY_ENABLES
    63                                  and #!($01 << .chan)
    64                                  +ayWriteA .dev, AY_ENABLES
    65                          }
    66                          
    67                          !macro ayToneDisable .dev, .chan {
    68                                  +ayRead .dev, AY_ENABLES
    69                                  ora #($01 << .chan)
    70                                  +ayWriteA .dev, AY_ENABLES
    71                          }
    72                          
    73                          !macro ayNoiseEnable .dev, .chan {
    74                                  +ayRead .dev, AY_ENABLES
    75                                  eor #($08 << .chan)
    76                                  +ayWriteA .dev, AY_ENABLES
    77                          }
    78                          
    79                          !macro ayNoiseDisable .dev, .chan {
    80                                  +ayRead .dev, AY_ENABLES
    81                                  ora #($08 << .chan)
    82                                  +ayWriteA .dev, AY_ENABLES
    83                          }
    84                          
    85                          !macro aySetVolume .dev, .chan, .vol {
    86                                  +ayWrite .dev, (AY_CHA_AMPL + .chan), (.vol >> 4)
    87                          }
    88                          
    89                          !macro aySetVolumeEnvelope .dev, .chan {
    90                                  +ayWrite .dev, (AY_CHA_AMPL + .chan), $10
    91                          }
    92                          
    93                          !macro aySetEnvelopePeriod .dev, .period {
    94                                  +ayWrite .dev, AY_ENV_PERIOD_L, <.period
    95                                  +ayWrite .dev, AY_ENV_PERIOD_H, >.period
    96                          }
    97                          
    98                          !macro aySetEnvShape .dev, .shape {
    99                                  +ayWrite .dev, AY_ENV_SHAPE, .shape
   100                          }
   101                          
   102                          !macro aySetNoise .dev, .freq {
   103                                  +ayWrite .dev, AY_ENV_SHAPE, .freq >> 3
   104                          }
   105                          
   106                          !macro ayStop .dev, .chan {
   107                                  +ayPlayNote .dev, .chan, 0
   108                          }

; ******** Source: ../lib\sfx\ay3891x.asm
    10                          
    11                          
    12                          
    13                          !ifndef AY_IO_PORT { AY_IO_PORT = $40
    14                                  !warn "AY_IO_PORT not provided. Defaulting to ", AY_IO_PORT
    15                          }
    16                          
    17                          HAVE_AY3891X = 1
    18                          
    19                          ; -------------------------
    20                          ; Constants
    21                          ; -------------------------
    22                          AY_PSG0 = $00
    23                          AY_PSG1 = $04
    24                          
    25                          ; IO Ports
    26                          AY_S0 = IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_PSG0
    27                          AY_S1 = IO_PORT_BASE_ADDRESS | AY_IO_PORT | AY_PSG1
    28                          
    29                          AY_INACTIVE = $03
    30                          AY_READ     = $02
    31                          AY_WRITE    = $01
    32                          AY_ADDR     = $00
    33                          
    34                          AY_S0_READ  = AY_S0 | AY_READ
    35                          AY_S0_WRITE = AY_S0 | AY_WRITE
    36                          AY_S0_ADDR  = AY_S0 | AY_ADDR
    37                          
    38                          AY_S1_READ  = AY_S1 | AY_READ
    39                          AY_S1_WRITE = AY_S1 | AY_WRITE
    40                          AY_S1_ADDR  = AY_S1 | AY_ADDR
    41                          
    42                          ; Registers
    43                          AY_R0 = 0
    44                          AY_R1 = 1
    45                          AY_R2 = 2
    46                          AY_R3 = 3
    47                          AY_R4 = 4
    48                          AY_R5 = 5
    49                          AY_R6 = 6
    50                          AY_R7 = 7
    51                          AY_R8 = 8
    52                          AY_R9 = 9
    53                          AY_R10 = 10
    54                          AY_R11 = 11
    55                          AY_R12 = 12
    56                          AY_R13 = 13
    57                          AY_R14 = 14
    58                          AY_R15 = 15
    59                          AY_R16 = 16
    60                          AY_R17 = 17
    61                          
    62                          AY_CHA = 0
    63                          AY_CHB = 1
    64                          AY_CHC = 2
    65                          AY_CHN = 3
    66                          
    67                          AY_CHA_TONE_L   = AY_R0
    68                          AY_CHA_TONE_H   = AY_R1
    69                          AY_CHB_TONE_L   = AY_R2
    70                          AY_CHB_TONE_H   = AY_R3
    71                          AY_CHC_TONE_L   = AY_R4
    72                          AY_CHC_TONE_H   = AY_R5
    73                          AY_NOISE_GEN    = AY_R6
    74                          AY_ENABLES      = AY_R7
    75                          AY_CHA_AMPL     = AY_R8
    76                          AY_CHB_AMPL     = AY_R9
    77                          AY_CHC_AMPL     = AY_R10
    78                          AY_ENV_PERIOD_L = AY_R11
    79                          AY_ENV_PERIOD_H = AY_R12
    80                          AY_ENV_SHAPE    = AY_R13
    81                          AY_PORTA        = AY_R14
    82                          AY_PORTB        = AY_R15
    83                          
    84                          AY_ENV_SHAPE_CONTINUE  = $08
    85                          AY_ENV_SHAPE_ATTACK    = $04
    86                          AY_ENV_SHAPE_ALTERNATE = $02
    87                          AY_ENV_SHAPE_HOLD      = $01
    88                          
    89                          ;  /\  /\  /\  /\  /\ 
    90                          ; /  \/  \/  \/  \/  \
    91                          AY_ENV_SHAPE_TRIANGLE     = (AY_ENV_SHAPE_CONTINUE | AY_ENV_SHAPE_ATTACK | AY_ENV_SHAPE_ALTERNATE)
    92                          
    93                          ;  /------------------
    94                          ; /
    95                          AY_ENV_SHAPE_FADE_IN      = (AY_ENV_SHAPE_CONTINUE | AY_ENV_SHAPE_ATTACK | AY_ENV_SHAPE_HOLD)
    96                          
    97                          ; \
    98                          ;  \__________________
    99                          AY_ENV_SHAPE_FADE_OUT     = (AY_ENV_SHAPE_CONTINUE | AY_ENV_SHAPE_HOLD)
   100                          
   101                          ; \ |\ |\ |\ |\ |\ |\ |
   102                          ;  \| \| \| \| \| \| \|
   103                          AY_ENV_SHAPE_SAW1         = (AY_ENV_SHAPE_CONTINUE)
   104                          
   105                          ;  /| /| /| /| /| /| /|
   106                          ; / |/ |/ |/ |/ |/ |/ |
   107                          AY_ENV_SHAPE_SAW2         = (AY_ENV_SHAPE_CONTINUE | AY_ENV_SHAPE_ATTACK)
   108                          
   109                          ;  /|
   110                          ; / |__________________
   111                          AY_ENV_SHAPE_FADE_IN_STOP = (AY_ENV_SHAPE_ATTACK)
   112                          
   113                          
   114                          AY_CLOCK_FREQ   = 2000000
   115                          
   116                          ayInit:
   117                                  ; disable everything
   118  e150 a9078d407fa9ff8d...        +ayWrite AY_PSG0, AY_ENABLES, $ff
   119  e15a a9078d447fa9ff8d...        +ayWrite AY_PSG1, AY_ENABLES, $ff
   120                          
   121  e164 a9088d407fa9008d...        +aySetVolume AY_PSG0, AY_CHA, 0
   122  e16e a9098d407fa9008d...        +aySetVolume AY_PSG0, AY_CHB, 0
   123  e178 a90a8d407fa9008d...        +aySetVolume AY_PSG0, AY_CHC, 0
   124                          
   125  e182 a9008d407fa9008d...        +ayPlayNote AY_PSG0, AY_CHA, 0
   126  e196 a9028d407fa9008d...        +ayPlayNote AY_PSG0, AY_CHB, 0
   127  e1aa a9048d407fa9008d...        +ayPlayNote AY_PSG0, AY_CHC, 0
   128                          
   129  e1be a90b8d407fa9008d...        +aySetEnvelopePeriod AY_PSG0, 0
   130  e1d2 a90d8d407fa9008d...        +aySetEnvShape AY_PSG0, 0
   131  e1dc a90d8d407fa9008d...        +aySetNoise  AY_PSG0, 0
   132                          
   133  e1e6 a9088d447fa9008d...        +aySetVolume AY_PSG1, AY_CHA, 0
   134  e1f0 a9098d447fa9008d...        +aySetVolume AY_PSG1, AY_CHB, 0
   135  e1fa a90a8d447fa9008d...        +aySetVolume AY_PSG1, AY_CHC, 0
   136                          
   137  e204 a9008d447fa9008d...        +ayPlayNote AY_PSG1, AY_CHA, 0
   138  e218 a9028d447fa9008d...        +ayPlayNote AY_PSG1, AY_CHB, 0
   139  e22c a9048d447fa9008d...        +ayPlayNote AY_PSG1, AY_CHC, 0
   140                          
   141  e240 a90b8d447fa9008d...        +aySetEnvelopePeriod AY_PSG1, 0
   142  e254 a90d8d447fa9008d...        +aySetEnvShape AY_PSG1, 0
   143  e25e a90d8d447fa9008d...        +aySetNoise  AY_PSG1, 0
   144  e268 60                         rts
   145                          
   146                          ; Note frequencies from https://pages.mtu.edu/~suits/notefreqs.html
   147                          
   148                          NOTE_FREQ_C0  = 16.35
   149                          NOTE_FREQ_CS0 = 17.32
   150                          NOTE_FREQ_D0  = 18.35
   151                          NOTE_FREQ_DS0 = 19.45
   152                          NOTE_FREQ_E0  = 20.6
   153                          NOTE_FREQ_F0  = 21.83
   154                          NOTE_FREQ_FS0 = 23.12
   155                          NOTE_FREQ_G0  = 24.5
   156                          NOTE_FREQ_GS0 = 25.96
   157                          NOTE_FREQ_A0  = 27.5
   158                          NOTE_FREQ_AS0 = 29.14
   159                          NOTE_FREQ_B0  = 30.87
   160                          NOTE_FREQ_C1  = 32.7
   161                          NOTE_FREQ_CS1 = 34.65
   162                          NOTE_FREQ_D1  = 36.71
   163                          NOTE_FREQ_DS1 = 38.89
   164                          NOTE_FREQ_E1  = 41.2
   165                          NOTE_FREQ_F1  = 43.65
   166                          NOTE_FREQ_FS1 = 46.25
   167                          NOTE_FREQ_G1  = 49
   168                          NOTE_FREQ_GS1 = 51.91
   169                          NOTE_FREQ_A1  = 55
   170                          NOTE_FREQ_AS1 = 58.27
   171                          NOTE_FREQ_B1  = 61.74
   172                          NOTE_FREQ_C2  = 65.41
   173                          NOTE_FREQ_CS2 = 69.3
   174                          NOTE_FREQ_D2  = 73.42
   175                          NOTE_FREQ_DS2 = 77.78
   176                          NOTE_FREQ_E2  = 82.41
   177                          NOTE_FREQ_F2  = 87.31
   178                          NOTE_FREQ_FS2 = 92.5
   179                          NOTE_FREQ_G2  = 98
   180                          NOTE_FREQ_GS2 = 103.83
   181                          NOTE_FREQ_A2  = 110
   182                          NOTE_FREQ_AS2 = 116.54
   183                          NOTE_FREQ_B2  = 123.47
   184                          NOTE_FREQ_C3  = 130.81
   185                          NOTE_FREQ_CS3 = 138.59
   186                          NOTE_FREQ_D3  = 146.83
   187                          NOTE_FREQ_DS3 = 155.56
   188                          NOTE_FREQ_E3  = 164.81
   189                          NOTE_FREQ_F3  = 174.61
   190                          NOTE_FREQ_FS3 = 185
   191                          NOTE_FREQ_G3  = 196
   192                          NOTE_FREQ_GS3 = 207.65
   193                          NOTE_FREQ_A3  = 220
   194                          NOTE_FREQ_AS3 = 233.08
   195                          NOTE_FREQ_B3  = 246.94
   196                          NOTE_FREQ_C4  = 261.63
   197                          NOTE_FREQ_CS4 = 277.18
   198                          NOTE_FREQ_D4  = 293.66
   199                          NOTE_FREQ_DS4 = 311.13
   200                          NOTE_FREQ_E4  = 329.63
   201                          NOTE_FREQ_F4  = 349.23
   202                          NOTE_FREQ_FS4 = 369.99
   203                          NOTE_FREQ_G4  = 392
   204                          NOTE_FREQ_GS4 = 415.3
   205                          NOTE_FREQ_A4  = 440
   206                          NOTE_FREQ_AS4 = 466.16
   207                          NOTE_FREQ_B4  = 493.88
   208                          NOTE_FREQ_C5  = 523.25
   209                          NOTE_FREQ_CS5 = 554.37
   210                          NOTE_FREQ_D5  = 587.33
   211                          NOTE_FREQ_DS5 = 622.25
   212                          NOTE_FREQ_E5  = 659.25
   213                          NOTE_FREQ_F5  = 698.46
   214                          NOTE_FREQ_FS5 = 739.99
   215                          NOTE_FREQ_G5  = 783.99
   216                          NOTE_FREQ_GS5 = 830.61
   217                          NOTE_FREQ_A5  = 880
   218                          NOTE_FREQ_AS5 = 932.33
   219                          NOTE_FREQ_B5  = 987.77
   220                          NOTE_FREQ_C6  = 1046.5
   221                          NOTE_FREQ_CS6 = 1108.73
   222                          NOTE_FREQ_D6  = 1174.66
   223                          NOTE_FREQ_DS6 = 1244.51
   224                          NOTE_FREQ_E6  = 1318.51
   225                          NOTE_FREQ_F6  = 1396.91
   226                          NOTE_FREQ_FS6 = 1479.98
   227                          NOTE_FREQ_G6  = 1567.98
   228                          NOTE_FREQ_GS6 = 1661.22
   229                          NOTE_FREQ_A6  = 1760
   230                          NOTE_FREQ_AS6 = 1864.66
   231                          NOTE_FREQ_B6  = 1975.53
   232                          NOTE_FREQ_C7  = 2093
   233                          NOTE_FREQ_CS7 = 2217.46
   234                          NOTE_FREQ_D7  = 2349.32
   235                          NOTE_FREQ_DS7 = 2489.02
   236                          NOTE_FREQ_E7  = 2637.02
   237                          NOTE_FREQ_F7  = 2793.83
   238                          NOTE_FREQ_FS7 = 2959.96
   239                          NOTE_FREQ_G7  = 3135.96
   240                          NOTE_FREQ_GS7 = 3322.44
   241                          NOTE_FREQ_A7  = 3520
   242                          NOTE_FREQ_AS7 = 3729.31
   243                          NOTE_FREQ_B7  = 3951.07
   244                          NOTE_FREQ_C8  = 4186.01
   245                          NOTE_FREQ_CS8 = 4434.92
   246                          NOTE_FREQ_D8  = 4698.63
   247                          NOTE_FREQ_DS8 = 4978.03
   248                          NOTE_FREQ_E8  = 5274.04
   249                          NOTE_FREQ_F8  = 5587.65
   250                          NOTE_FREQ_FS8 = 5919.91
   251                          NOTE_FREQ_G8  = 6271.93
   252                          NOTE_FREQ_GS8 = 6644.88
   253                          NOTE_FREQ_A8  = 7040
   254                          NOTE_FREQ_AS8 = 7458.62
   255                          NOTE_FREQ_B8  = 7902.13

; ******** Source: kernel.asm
   149                          }
   150                          
   151                          !ifndef HBC56_DISABLE_TMS9918 {
   152                                  !ifndef TMS_MODEL { TMS_MODEL = 9918 }
   153                                  !src "gfx/tms9918.asm"
   154                          }
   155                          
   156                          !ifndef HBC56_DISABLE_SFXMAN {
   157                                  !src "sfx/sfxman.asm"
   158                          }
   159                          
   160                          !ifndef HBC56_DISABLE_LCD {
   161                                  !ifndef LCD_MODEL { LCD_MODEL = 12864 }

; ******** Source: ../lib\gfx\bitmap.asm
     1                          ; 6502 - Bitmap
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          ;
    10                          
    11                          ; Bitmap object has the following structure
    12                          ;
    13                          ; Width
    14                          ; Height
    15                          
    16                          HAVE_BITMAP = 1
    17                          
    18                          !ifndef BITMAP_ZP_START { BITMAP_ZP_START = $28
    19                                  !warn "BITMAP_ZP_START not provided. Defaulting to ", BITMAP_ZP_START
    20                          }
    21                          
    22                          !ifndef BITMAP_RAM_START { BITMAP_RAM_START = $7b80
    23                                  !warn "BITMAP_RAM_START not provided. Defaulting to ", BITMAP_RAM_START
    24                          }
    25                          
    26                          ; -------------------------
    27                          ; Zero page
    28                          ; -------------------------
    29                          PIX_ADDR                = BITMAP_ZP_START
    30                          BITMAP_ADDR_H           = BITMAP_ZP_START+2
    31                          BITMAP_ZP_SIZE          = 4
    32                          
    33                          ; -----------------------------------------------------------------------------
    34                          ; High RAM
    35                          ; -----------------------------------------------------------------------------
    36                          
    37                          BITMAP_X       = BITMAP_RAM_START + 1
    38                          BITMAP_Y       = BITMAP_RAM_START + 2
    39                          BITMAP_X1      = BITMAP_X
    40                          BITMAP_Y1      = BITMAP_Y
    41                          BITMAP_X2      = BITMAP_RAM_START + 3
    42                          BITMAP_Y2      = BITMAP_RAM_START + 4
    43                          
    44                          BITMAP_LINE_STYLE     = BITMAP_RAM_START + 7
    45                          BITMAP_LINE_STYLE_ODD = BITMAP_RAM_START + 8
    46                          
    47                          BITMAP_TMP1    = BITMAP_RAM_START + 9
    48                          BITMAP_TMP2    = BITMAP_RAM_START + 10
    49                          BITMAP_TMP3    = BITMAP_RAM_START + 11
    50                          BITMAP_TMP4    = BITMAP_RAM_START + 12
    51                          BITMAP_TMP5    = BITMAP_RAM_START + 13
    52                          BITMAP_TMP6    = BITMAP_RAM_START + 14
    53                          
    54                          BITMAP_RAM_SIZE = 16
    55                          
    56                          
    57                          !if BITMAP_ZP_END < (BITMAP_ZP_START + BITMAP_ZP_SIZE) {
    58                                  !error "BITMAP_ZP requires ",BITMAP_ZP_SIZE," bytes. Allocated ",BITMAP_ZP_END - BITMAP_ZP_START
    59                          }
    60                          
    61                          !if BITMAP_RAM_END < (BITMAP_RAM_START + BITMAP_RAM_SIZE) {
    62                                  !error "BITMAP_RAM requires ",BITMAP_RAM_SIZE," bytes. Allocated ",BITMAP_RAM_END - BITMAP_RAM_START
    63                          }
    64                          
    65                          
    66                          
    67                          ; -----------------------------------------------------------------------------
    68                          ; bitmapClear: Clear the bitmap
    69                          ; -----------------------------------------------------------------------------
    70                          ; Inputs:
    71                          ;  BITMAP_ADDR_H: Contains page-aligned address of 1-bit 128x64 bitmap
    72                          ; -----------------------------------------------------------------------------
    73                          bitmapClear:
    74  e269 a9ff                       lda #$ff
    75  e26b 8d1d7b                     sta BITMAP_LINE_STYLE
    76  e26e a900                       lda #0
    77                                  
    78                                  ; flow through.... danger?
    79                                  
    80                                  
    81                          ; -----------------------------------------------------------------------------
    82                          ; bitmapFill: Fill the bitmap with value in A
    83                          ; -----------------------------------------------------------------------------
    84                          ; Inputs:
    85                          ;  BITMAP_ADDR_H: Contains page-aligned address of 1-bit 128x64 bitmap
    86                          ;  A: The value to fill
    87                          ; -----------------------------------------------------------------------------
    88                          bitmapFill:
    89  e270 8d1f7b                     sta BITMAP_TMP1
    90  e273 a520                       lda BITMAP_ADDR_H
    91  e275 851f                       sta PIX_ADDR + 1
    92  e277 a200                       ldx #0
    93  e279 861e                       stx PIX_ADDR
    94                          
    95  e27b ad1f7b                     lda BITMAP_TMP1 
    96  e27e a000                       ldy #0
    97  e280 a204                       ldx #4
    98                          -
    99  e282 911e                       sta (PIX_ADDR), y
   100  e284 c8                         iny
   101  e285 d0fb                       bne -
   102  e287 e61f                       inc PIX_ADDR + 1
   103  e289 ca                         dex
   104  e28a d0f6                       bne -
   105                                  
   106  e28c 60                         rts
   107                                  
   108                                  
   109                          ; -----------------------------------------------------------------------------
   110                          ; bitmapXor: XOR (invert) the entire bitmap
   111                          ; -----------------------------------------------------------------------------
   112                          ; Inputs:
   113                          ;  BITMAP_ADDR_H: Contains page-aligned address of 1-bit 128x64 bitmap
   114                          ; -----------------------------------------------------------------------------
   115                          bitmapXor:
   116  e28d a520                       lda BITMAP_ADDR_H
   117  e28f 851f                       sta PIX_ADDR + 1
   118  e291 a200                       ldx #0
   119  e293 861e                       stx PIX_ADDR
   120                          
   121  e295 a000                       ldy #0
   122  e297 a204                       ldx #4
   123                          -
   124  e299 a9ff                       lda #$ff
   125  e29b 511e                       eor (PIX_ADDR), y
   126  e29d 911e                       sta (PIX_ADDR), y
   127                                  
   128  e29f c8                         iny
   129  e2a0 d0f7                       bne -
   130  e2a2 e61f                       inc PIX_ADDR + 1
   131  e2a4 ca                         dex
   132  e2a5 d0f2                       bne -
   133                                  
   134  e2a7 60                         rts
   135                                  
   136                          ; -----------------------------------------------------------------------------
   137                          ; _bitmapOffset: Set up the offset to the buffer based on X/Y (Internal use)
   138                          ; -----------------------------------------------------------------------------
   139                          ; Inputs:
   140                          ;  BITMAP_ADDR_H: Contains page-aligned address of 1-bit 128x64 bitmap
   141                          ;  BITMAP_X: X position (0 to 127)
   142                          ;  BITMAP_Y: Y position (0 to 63)
   143                          ; Outputs:
   144                          ;  PIX_ADDR: Set to byte at column 0 of row BITMAP_Y
   145                          ;  Y:            Y offset of byte within row (0 to 63)
   146                          ;  X:            Bit offset within the byte
   147                          ; -----------------------------------------------------------------------------
   148                          _bitmapOffset:
   149                          
   150  e2a8 a520                       lda BITMAP_ADDR_H
   151  e2aa 851f                       sta PIX_ADDR + 1
   152  e2ac a200                       ldx #0
   153  e2ae 861e                       stx PIX_ADDR
   154                                  
   155  e2b0 ad187b                     lda BITMAP_Y
   156  e2b3 4a                         lsr
   157  e2b4 4a                         lsr
   158  e2b5 4a                         lsr
   159  e2b6 4a                         lsr
   160  e2b7 18                         clc
   161  e2b8 651f                       adc PIX_ADDR + 1
   162  e2ba 851f                       sta PIX_ADDR + 1
   163                                  
   164  e2bc ad187b                     lda BITMAP_Y
   165  e2bf 290f                       and #$0f
   166  e2c1 0a                         asl
   167  e2c2 0a                         asl
   168  e2c3 0a                         asl
   169  e2c4 0a                         asl
   170  e2c5 851e                       sta PIX_ADDR
   171                                  
   172  e2c7 ad177b                     lda BITMAP_X
   173  e2ca 4a                         lsr
   174  e2cb 4a                         lsr
   175  e2cc 4a                         lsr
   176  e2cd a8                         tay       ; Y contains start byte offset in row
   177                                  
   178  e2ce ad177b                     lda BITMAP_X
   179  e2d1 2907                       and #$07
   180  e2d3 aa                         tax   ; X contains bit offset within byte (0 - 7)       
   181  e2d4 60                         rts
   182                                  
   183                          ; -----------------------------------------------------------------------------
   184                          ; bitmapSetPixel: Set a pixel
   185                          ; -----------------------------------------------------------------------------
   186                          ; Inputs:
   187                          ;  BITMAP_ADDR_H: Contains page-aligned address of 1-bit 128x64 bitmap
   188                          ;  BITMAP_X: X position (0 to 127)
   189                          ;  BITMAP_Y: Y position (0 to 63)
   190                          ; -----------------------------------------------------------------------------
   191                          bitmapSetPixel:
   192                          
   193  e2d5 20a8e2                     jsr _bitmapOffset
   194                                  
   195  e2d8 bd30e1                     lda tableBitFromLeft, x
   196                                  
   197  e2db 111e                       ora (PIX_ADDR), y
   198  e2dd 911e                       sta (PIX_ADDR), y
   199                                  
   200  e2df 60                         rts     
   201                                  
   202                          ; -----------------------------------------------------------------------------
   203                          ; bitmapClearPixel: Clear a pixel
   204                          ; -----------------------------------------------------------------------------
   205                          ; Inputs:
   206                          ;  BITMAP_ADDR_H: Contains page-aligned address of 1-bit 128x64 bitmap
   207                          ;  BITMAP_X: X position (0 to 127)
   208                          ;  BITMAP_Y: Y position (0 to 63)
   209                          ; -----------------------------------------------------------------------------
   210                          bitmapClearPixel:
   211                          
   212  e2e0 20a8e2                     jsr _bitmapOffset
   213                                  
   214  e2e3 bd38e1                     lda tableInvBitFromLeft, x
   215                          
   216  e2e6 311e                       and (PIX_ADDR), y
   217  e2e8 911e                       sta (PIX_ADDR), y
   218                                  
   219  e2ea 60                         rts
   220                                  
   221                                  
   222                          ; -----------------------------------------------------------------------------
   223                          ; bitmapXorPixel: XOR a pixel
   224                          ; -----------------------------------------------------------------------------
   225                          ; Inputs:
   226                          ;  BITMAP_ADDR_H: Contains page-aligned address of 1-bit 128x64 bitmap
   227                          ;  BITMAP_X: X position (0 to 127)
   228                          ;  BITMAP_Y: Y position (0 to 63)
   229                          ; -----------------------------------------------------------------------------
   230                          bitmapXorPixel:
   231                          
   232  e2eb 20a8e2                     jsr _bitmapOffset
   233                                  
   234  e2ee bd30e1                     lda tableBitFromLeft, x
   235                          
   236  e2f1 511e                       eor (PIX_ADDR), y
   237  e2f3 911e                       sta (PIX_ADDR), y
   238                                  
   239  e2f5 60                         rts
   240                                  
   241                          ; -----------------------------------------------------------------------------
   242                          ; bitmapLineH: Output a horizontal line
   243                          ; -----------------------------------------------------------------------------
   244                          ; Inputs:
   245                          ;  BITMAP_ADDR_H: Contains page-aligned address of 1-bit 128x64 bitmap
   246                          ;  BITMAP_X1: Start X position (0 to 127)
   247                          ;  BITMAP_X2: End X position (0 to 127)
   248                          ;  BITMAP_Y:  Y position (0 to 63)
   249                          ; -----------------------------------------------------------------------------
   250                          bitmapLineH:
   251                          
   252                                  END_OFFSET   = BITMAP_TMP3
   253                                  START_BYTE   = BITMAP_TMP1
   254                                  END_BYTE     = BITMAP_TMP2
   255                                  TMP_STYLE    = BITMAP_TMP5
   256                          
   257  e2f6 ad197b                     lda BITMAP_X2
   258  e2f9 4a                         lsr
   259  e2fa 4a                         lsr
   260  e2fb 4a                         lsr
   261  e2fc 8d217b                     sta END_OFFSET  ; END_OFFSET contains end byte offset within the row
   262                          
   263  e2ff 20a8e2                     jsr _bitmapOffset
   264                          
   265  e302 ad1d7b                     lda BITMAP_LINE_STYLE
   266  e305 8d237b                     sta TMP_STYLE
   267                                  
   268  e308 a9ff                       lda #$ff
   269                                  
   270                          ; shift the bits to the right for the pixel offset
   271                          -
   272  e30a e000                       cpx #0
   273  e30c f013                       beq ++
   274  e30e 4e237b                     lsr TMP_STYLE
   275  e311 900a                       bcc +
   276  e313 48                         pha
   277  e314 a980                       lda #$80
   278  e316 0d237b                     ora TMP_STYLE
   279  e319 8d237b                     sta TMP_STYLE
   280  e31c 68                         pla     
   281                          +
   282  e31d ca                         dex
   283  e31e 4a                         lsr
   284  e31f b0e9                       bcs -  ; carry is always set
   285                          ++
   286  e321 8d1f7b                     sta START_BYTE
   287                          
   288  e324 ad197b                     lda BITMAP_X2
   289  e327 2907                       and #$07
   290                                  
   291  e329 aa                         tax   ; X contains bit offset within byte (0 - 7)       
   292                                  
   293  e32a a9ff                       lda #$ff
   294                                  
   295                          ; shift the bits to the left for the pixel offset
   296                          -
   297  e32c e007                       cpx #7
   298  e32e f004                       beq +
   299  e330 e8                         inx
   300  e331 0a                         asl    
   301  e332 b0f8                       bcs -  ; carry is always set
   302                          +
   303  e334 8d207b                     sta END_BYTE
   304                                  
   305  e337 ad1f7b                     lda START_BYTE
   306  e33a cc217b                     cpy END_OFFSET
   307  e33d d015                       bne ++
   308  e33f 2d207b                     and END_BYTE  ; combine if within the same byte
   309                                  
   310  e342 48                         pha
   311  e343 49ff                       eor #$ff
   312  e345 311e                       and (PIX_ADDR), y
   313  e347 8d227b                     sta BITMAP_TMP4
   314  e34a 68                         pla
   315  e34b 2d237b                     and TMP_STYLE
   316  e34e 0d227b                     ora BITMAP_TMP4
   317  e351 911e                       sta (PIX_ADDR), y
   318                                  
   319  e353 60                         rts
   320                          ++
   321  e354 48                         pha
   322  e355 49ff                       eor #$ff
   323  e357 311e                       and (PIX_ADDR), y
   324  e359 8d227b                     sta BITMAP_TMP4
   325  e35c 68                         pla
   326  e35d 2d237b                     and TMP_STYLE
   327  e360 0d227b                     ora BITMAP_TMP4
   328  e363 911e                       sta (PIX_ADDR), y
   329                          -
   330  e365 a9ff                       lda #$ff
   331  e367 c8                         iny
   332  e368 cc217b                     cpy END_OFFSET
   333  e36b d003                       bne +
   334  e36d 2d207b                     and END_BYTE  ; combine if within the same byte
   335                          +
   336  e370 48                         pha
   337  e371 49ff                       eor #$ff
   338  e373 311e                       and (PIX_ADDR), y
   339  e375 8d227b                     sta BITMAP_TMP4
   340  e378 68                         pla
   341  e379 2d237b                     and TMP_STYLE
   342  e37c 0d227b                     ora BITMAP_TMP4
   343  e37f 911e                       sta (PIX_ADDR), y
   344                          
   345  e381 cc217b                     cpy END_OFFSET
   346  e384 d0df                       bne -   
   347                                  
   348  e386 60                         rts
   349                                  
   350                                  
   351                          ; -----------------------------------------------------------------------------
   352                          ; bitmapLineV: Output a horizontal line
   353                          ; -----------------------------------------------------------------------------
   354                          ; Inputs:
   355                          ;  BITMAP_ADDR_H: Contains page-aligned address of 1-bit 128x64 bitmap
   356                          ;  BITMAP_Y1: Start Y position (0 to 63)
   357                          ;  BITMAP_Y2: End Y position (0 to 63)
   358                          ;  BITMAP_X:  Y position (0 to 127)
   359                          ; -----------------------------------------------------------------------------
   360                          bitmapLineV:
   361                          
   362                                  COL_BYTE     = BITMAP_TMP1
   363                                  STYLE_BYTE   = BITMAP_TMP2
   364                          
   365  e387 20a8e2                     jsr _bitmapOffset
   366                                  
   367  e38a ad1d7b                     lda BITMAP_LINE_STYLE
   368  e38d 8d207b                     sta STYLE_BYTE
   369                                  
   370  e390 bd30e1                     lda tableBitFromLeft, x
   371                          
   372  e393 8d1f7b                     sta COL_BYTE    
   373                                  
   374  e396 ae187b                     ldx BITMAP_Y1
   375                          -
   376  e399 a980                       lda #$80
   377  e39b 2c207b                     bit STYLE_BYTE
   378  e39e d00c                       bne +
   379                                  ; draw a 0
   380  e3a0 ad1f7b                     lda COL_BYTE
   381  e3a3 49ff                       eor #$ff
   382  e3a5 311e                       and (PIX_ADDR), y       
   383  e3a7 911e                       sta (PIX_ADDR), y
   384  e3a9 4cb3e3                     jmp ++
   385                          +       ; draw a 1
   386  e3ac ad1f7b                     lda COL_BYTE    
   387  e3af 111e                       ora (PIX_ADDR), y       
   388  e3b1 911e                       sta (PIX_ADDR), y
   389                          ++
   390                                          
   391  e3b3 ec1a7b                     cpx BITMAP_Y2
   392  e3b6 f017                       beq ++
   393  e3b8 0e207b                     asl STYLE_BYTE
   394  e3bb 9003                       bcc +
   395  e3bd ee207b                     inc STYLE_BYTE
   396                          +
   397  e3c0 e8                         inx
   398  e3c1 a910                       lda #16
   399  e3c3 18                         clc
   400  e3c4 651e                       adc PIX_ADDR
   401  e3c6 9002                       bcc +
   402  e3c8 e61f                       inc PIX_ADDR + 1
   403                          +
   404  e3ca 851e                       sta PIX_ADDR
   405  e3cc 18                         clc
   406  e3cd 90ca                       bcc -
   407                          ++
   408                                  
   409  e3cf 60                         rts
   410                          
   411                          ; -----------------------------------------------------------------------------
   412                          ; bitmapLine: Output an arbitrary line
   413                          ; -----------------------------------------------------------------------------
   414                          ; Inputs:
   415                          ;  BITMAP_ADDR_H: Contains page-aligned address of 1-bit 128x64 bitmap
   416                          ;  BITMAP_X1: 
   417                          ;  BITMAP_Y1: 
   418                          ;  BITMAP_X2: 
   419                          ;  BITMAP_Y2: 
   420                          ; -----------------------------------------------------------------------------
   421                          bitmapLine:
   422                          
   423                                  LINE_WIDTH = BITMAP_TMP1
   424                                  LINE_HEIGHT = BITMAP_TMP2
   425                                  
   426                                  ; get width
   427  e3d0 ad197b                     lda BITMAP_X2
   428  e3d3 38                         sec
   429  e3d4 ed177b                     sbc BITMAP_X1
   430                                  
   431  e3d7 1012                       bpl +
   432  e3d9 ad177b                     lda BITMAP_X1
   433  e3dc 48                         pha
   434  e3dd ad197b                     lda BITMAP_X2
   435  e3e0 8d177b                     sta BITMAP_X1
   436  e3e3 68                         pla
   437  e3e4 8d197b                     sta BITMAP_X2
   438  e3e7 38                         sec
   439  e3e8 ed177b                     sbc BITMAP_X1   
   440                          +       
   441  e3eb 8d1f7b                     sta LINE_WIDTH
   442                          
   443                                  ; get height
   444  e3ee ad1a7b                     lda BITMAP_Y2
   445  e3f1 38                         sec
   446  e3f2 ed187b                     sbc BITMAP_Y1
   447                          
   448  e3f5 1012                       bpl +
   449  e3f7 ad187b                     lda BITMAP_Y1
   450  e3fa 48                         pha
   451  e3fb ad1a7b                     lda BITMAP_Y2
   452  e3fe 8d187b                     sta BITMAP_Y1
   453  e401 68                         pla
   454  e402 8d1a7b                     sta BITMAP_Y2
   455  e405 38                         sec
   456  e406 ed187b                     sbc BITMAP_Y1   
   457                          +       
   458  e409 8d207b                     sta LINE_HEIGHT
   459                                  
   460  e40c cd1f7b                     cmp LINE_WIDTH
   461  e40f b003                       bcs .goTall
   462  e411 4c17e4                     jmp _bitmapLineWide
   463                          .goTall
   464  e414 4c68e4                     jmp _bitmapLineTall
   465                                  
   466                                  ; rts in above subroutines
   467                                  
   468                          ; ----------------------------------------------------------------------------
   469                          
   470                          _bitmapLineWide:  ; a line that is wider than it is tall
   471                                  
   472                                  D = BITMAP_TMP6
   473                                  
   474                                  Y = BITMAP_TMP3
   475                                  
   476  e417 ad207b                     lda LINE_HEIGHT
   477  e41a 0a                         asl
   478  e41b 38                         sec
   479  e41c ed1f7b                     sbc LINE_WIDTH
   480  e41f 8d247b                     sta D
   481                                  
   482  e422 ad177b                     lda BITMAP_X
   483  e425 48                         pha
   484                                  
   485  e426 ad187b                     lda BITMAP_Y1
   486  e429 8d217b                     sta Y
   487                                  
   488                          -
   489  e42c 20d5e2                     jsr bitmapSetPixel
   490  e42f ad247b                     lda D
   491  e432 1007                       bpl +
   492  e434 ad207b                     lda LINE_HEIGHT
   493  e437 0a                         asl
   494  e438 4c4be4                     jmp ++
   495                          +
   496  e43b ee187b                 inc BITMAP_Y1
   497  e43e ad1f7b                     lda LINE_WIDTH
   498  e441 38                         sec
   499  e442 ed207b                     sbc LINE_HEIGHT
   500  e445 0a                         asl
   501  e446 49ff                       eor #$ff
   502  e448 18                         clc
   503  e449 6901                       adc #1
   504                          ++
   505  e44b 18                         clc
   506  e44c 6d247b                     adc D
   507  e44f 8d247b                     sta D
   508  e452 ee177b                     inc BITMAP_X
   509  e455 ad197b                     lda BITMAP_X2
   510  e458 cd177b                     cmp BITMAP_X
   511  e45b b0cf                       bcs -
   512                                  
   513  e45d ad217b                     lda Y
   514  e460 8d187b                     sta BITMAP_Y1
   515                                  
   516  e463 68                         pla
   517  e464 8d177b                     sta BITMAP_X
   518                                  
   519  e467 60                         rts
   520                                  
   521                          _bitmapLineTall:  ; a line that is taller than it is wide
   522                                  
   523                                  D = BITMAP_TMP6
   524                                  
   525                                  X = BITMAP_TMP3
   526                                  
   527  e468 ad1f7b                     lda LINE_WIDTH
   528  e46b 0a                         asl
   529  e46c 38                         sec
   530  e46d ed207b                     sbc LINE_HEIGHT
   531  e470 8d247b                     sta D
   532                                  
   533  e473 ad187b                     lda BITMAP_Y
   534  e476 48                         pha
   535                                  
   536  e477 ad177b                     lda BITMAP_X1
   537  e47a 8d217b                     sta X
   538                                  
   539                          -
   540  e47d 20d5e2                     jsr bitmapSetPixel
   541  e480 ad247b                     lda D
   542  e483 1007                       bpl +
   543  e485 ad1f7b                     lda LINE_WIDTH
   544  e488 0a                         asl
   545  e489 4c9ce4                     jmp ++
   546                          +
   547  e48c ee177b                 inc BITMAP_X1
   548  e48f ad207b                     lda LINE_HEIGHT
   549  e492 38                         sec
   550  e493 ed1f7b                     sbc LINE_WIDTH
   551  e496 0a                         asl
   552  e497 49ff                       eor #$ff
   553  e499 18                         clc
   554  e49a 6901                       adc #1
   555                          ++
   556  e49c 18                         clc
   557  e49d 6d247b                     adc D
   558  e4a0 8d247b                     sta D
   559  e4a3 ee187b                     inc BITMAP_Y
   560  e4a6 ad1a7b                     lda BITMAP_Y2
   561  e4a9 cd187b                     cmp BITMAP_Y
   562  e4ac b0cf                       bcs -
   563                          
   564  e4ae ad217b                     lda X
   565  e4b1 8d177b                     sta BITMAP_X1
   566                                  
   567  e4b4 68                         pla
   568  e4b5 8d187b                     sta BITMAP_Y
   569                                  
   570  e4b8 60                         rts
   571                                  
   572                          ; -----------------------------------------------------------------------------
   573                          ; bitmapRect: Output a rectangle outline
   574                          ; -----------------------------------------------------------------------------
   575                          ; Inputs:
   576                          ;  BITMAP_ADDR_H: Contains page-aligned address of 1-bit 128x64 bitmap
   577                          ;  BITMAP_X1: 
   578                          ;  BITMAP_Y1: 
   579                          ;  BITMAP_X2: 
   580                          ;  BITMAP_Y2: 
   581                          ; -----------------------------------------------------------------------------
   582                          bitmapRect:
   583  e4b9 20f6e2                     jsr bitmapLineH
   584  e4bc 2087e3                     jsr bitmapLineV
   585                                  
   586  e4bf ad177b                     lda BITMAP_X1
   587  e4c2 48                         pha
   588  e4c3 ad197b                     lda BITMAP_X2
   589  e4c6 8d177b                     sta BITMAP_X1
   590                          
   591  e4c9 2087e3                     jsr bitmapLineV
   592                                  
   593  e4cc 68                         pla
   594  e4cd 8d177b                     sta BITMAP_X1
   595                          
   596  e4d0 ad187b                     lda BITMAP_Y1
   597  e4d3 48                         pha
   598  e4d4 ad1a7b                     lda BITMAP_Y2
   599  e4d7 8d187b                     sta BITMAP_Y1
   600                                  
   601  e4da 20f6e2                     jsr bitmapLineH
   602                          
   603  e4dd 68                         pla
   604  e4de 8d187b                     sta BITMAP_Y1
   605                                  
   606  e4e1 60                         rts
   607                                  
   608                          ; -----------------------------------------------------------------------------
   609                          ; bitmapFilledRect: Output a filled rectangle
   610                          ; -----------------------------------------------------------------------------
   611                          ; Inputs:
   612                          ;  BITMAP_ADDR_H: Contains page-aligned address of 1-bit 128x64 bitmap
   613                          ;  BITMAP_X1: 
   614                          ;  BITMAP_Y1: 
   615                          ;  BITMAP_X2: 
   616                          ;  BITMAP_Y2: 
   617                          ; -----------------------------------------------------------------------------
   618                          bitmapFilledRect:
   619  e4e2 ad187b                     lda BITMAP_Y1
   620  e4e5 48                         pha
   621  e4e6 ad1d7b                     lda BITMAP_LINE_STYLE
   622  e4e9 48                         pha
   623                                  
   624                          -
   625  e4ea 20f6e2                     jsr bitmapLineH
   626  e4ed ee187b                     inc BITMAP_Y1
   627                          
   628  e4f0 68                         pla
   629  e4f1 8d1d7b                     sta BITMAP_LINE_STYLE
   630  e4f4 48                         pha
   631                                  
   632  e4f5 ad1a7b                     lda BITMAP_Y2
   633  e4f8 cd187b                     cmp BITMAP_Y1
   634  e4fb f014                       beq +
   635                          
   636  e4fd 20f6e2                     jsr bitmapLineH
   637  e500 ee187b                     inc BITMAP_Y1
   638                                  
   639  e503 ad1e7b                     lda BITMAP_LINE_STYLE_ODD
   640  e506 8d1d7b                     sta BITMAP_LINE_STYLE
   641                                  
   642  e509 ad1a7b                     lda BITMAP_Y2
   643  e50c cd187b                     cmp BITMAP_Y1
   644  e50f d0d9                       bne -
   645                          +       
   646                          
   647  e511 68                         pla
   648  e512 8d1d7b                     sta BITMAP_LINE_STYLE
   649  e515 68                         pla
   650  e516 8d187b                     sta BITMAP_Y1
   651                                  

; ******** Source: kernel.asm

; ******** Source: ../lib\lcd\lcd.asm
     1  e519 60                 ; 6502 LCD - HBC-56
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          
    10                          !ifndef LCD_IO_PORT { LCD_IO_PORT = $02
    11                                  !warn "LCD_IO_PORT not provided. Defaulting to ", LCD_IO_PORT
    12                          }
    13                          
    14                          !ifndef LCD_ZP_START { LCD_ZP_START = $38
    15                                  !warn "LCD_ZP_START not provided. Defaulting to ", LCD_ZP_START
    16                          }
    17                          
    18                          !ifndef LCD_RAM_START { LCD_RAM_START = $7c00
    19                                  !warn "LCD_RAM_START not provided. Defaulting to ", LCD_RAM_START
    20                          }
    21                          
    22                          HAVE_LCD = 1
    23                          
    24                          ; -------------------------
    25                          ; Zero page
    26                          ; -------------------------
    27                          LCD_TMP1        = LCD_ZP_START
    28                          LCD_TMP2        = LCD_ZP_START + 1
    29                          LCD_ZP_SIZE     = 2
    30                          
    31                          
    32                          ; -------------------------
    33                          ; High RAM
    34                          ; -------------------------
    35                          .LCD_BUFFER_ADDR        = LCD_RAM_START
    36                          .LCD_REGY_TMP           = LCD_RAM_START + 40
    37                          LCD_RAM_SIZE            = 42
    38                          
    39                          
    40                          !if LCD_ZP_END < (LCD_ZP_START + LCD_ZP_SIZE) {
    41                                  !error "LCD_ZP requires ",LCD_ZP_SIZE," bytes. Allocated ",LCD_ZP_END - LCD_ZP_START
    42                          }
    43                          
    44                          !if LCD_RAM_END < (LCD_RAM_START + LCD_RAM_SIZE) {
    45                                  !error "LCD_RAM requires ",LCD_RAM_SIZE," bytes. Allocated ",LCD_RAM_END - LCD_RAM_START
    46                          }
    47                          
    48                          
    49                          
    50                          ; -------------------------
    51                          ; Contants
    52                          ; -------------------------
    53                          
    54                          ; IO Ports
    55                          LCD_CMD         = IO_PORT_BASE_ADDRESS | LCD_IO_PORT
    56                          LCD_DATA        = IO_PORT_BASE_ADDRESS | LCD_IO_PORT | $01
    57                          
    58                          ; Commands
    59                          LCD_CMD_CLEAR                   = %00000001
    60                          LCD_CMD_HOME                    = %00000010
    61                          
    62                          LCD_CMD_ENTRY_MODE              = %00000100
    63                          LCD_CMD_ENTRY_MODE_INCREMENT    = %00000010
    64                          LCD_CMD_ENTRY_MODE_DECREMENT    = %00000000
    65                          LCD_CMD_ENTRY_MODE_SHIFT        = %00000001
    66                          
    67                          LCD_CMD_DISPLAY                 = %00001000
    68                          LCD_CMD_DISPLAY_ON              = %00000100
    69                          LCD_CMD_DISPLAY_CURSOR          = %00000010
    70                          LCD_CMD_DISPLAY_CURSOR_BLINK    = %00000001
    71                          
    72                          LCD_CMD_SHIFT                   = %00010000
    73                          LCD_CMD_SHIFT_CURSOR            = %00000000
    74                          LCD_CMD_SHIFT_DISPLAY           = %00001000
    75                          LCD_CMD_SHIFT_LEFT              = %00000000
    76                          LCD_CMD_SHIFT_RIGHT             = %00000100
    77                          
    78                          LCD_CMD_SET_CGRAM_ADDR          = $40
    79                          LCD_CMD_SET_DRAM_ADDR           = $80
    80                          
    81                          LCD_CMD_FUNCTIONSET             = $20
    82                          LCD_CMD_8BITMODE                = $10
    83                          LCD_CMD_2LINE                   = $08
    84                          
    85                          !ifndef LCD_MODEL {
    86                                  !warn "Set LCD_MODEL to one of: 1602, 2004 or 12864. Defaulting to 1602"
    87                                  LCD_MODEL = 1602
    88                          }
    89                          

; ******** Source: ../lib\lcd\lcd.inc
     1                          ; 6502 LCD Macros - HBC-56
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          
    10                          ; -----------------------------------------------------------------------------
    11                          ; lcdPrint: Print immediate text
    12                          ; -----------------------------------------------------------------------------
    13                          ; Inputs:
    14                          ;  str: String to print
    15                          ; -----------------------------------------------------------------------------
    16                          !macro lcdPrint str {
    17                                  jmp +
    18                          .textAddr
    19                                  !text str,0
    20                          +
    21                                  lda #<.textAddr
    22                                  sta STR_ADDR_L
    23                                  lda #>.textAddr
    24                                  sta STR_ADDR_H
    25                                  jsr lcdPrint
    26                          }
    27                          
    28                          
    29                          ; -----------------------------------------------------------------------------
    30                          ; lcdChar: Print immediate character
    31                          ; -----------------------------------------------------------------------------
    32                          ; Inputs:
    33                          ;  c: Character to print
    34                          ; -----------------------------------------------------------------------------
    35                          !macro lcdChar c {
    36                                  pha
    37                                  lda #c
    38                                  jsr lcdChar
    39                                  pla
    40                          }
    41                          
    42                          
    43                          ; -----------------------------------------------------------------------------
    44                          ; lcdConsolePrint: Print immediate text to console
    45                          ; -----------------------------------------------------------------------------
    46                          ; Inputs:
    47                          ;  str: String to print
    48                          ; -----------------------------------------------------------------------------
    49                          !macro lcdConsolePrint .str {
    50                                  jmp .afterText
    51                          .textAddr
    52                                  !text .str,0
    53                          .afterText        
    54                          
    55                                  lda #<.textAddr
    56                                  sta STR_ADDR_L
    57                                  lda #>.textAddr
    58                                  sta STR_ADDR_H
    59                                  jsr lcdConsolePrint        

; ******** Source: ../lib\lcd\lcd.asm
    91                          
    92                          ; -------------------------
    93                          ; Constants
    94                          ; -------------------------
    95                          !if LCD_MODEL = 1602 {
    96                                  LCD_ROWS = 2
    97                                  LCD_COLUMNS = 16
    98                                  LCD_GRAPHICS = 0
    99                                  LCD_ADDR_LINE1 = 0x00
   100                                  LCD_ADDR_LINE2 = 0x40
   101                          } else { !if LCD_MODEL = 2004 {
   102                                  LCD_ROWS = 4
   103                                  LCD_COLUMNS = 20
   104                                  LCD_GRAPHICS = 0
   105                                  LCD_ADDR_LINE1 = 0x00
   106                                  LCD_ADDR_LINE2 = 0x40
   107                                  LCD_ADDR_LINE3 = 0x14
   108                                  LCD_ADDR_LINE4 = 0x54
   109                          } else { !if LCD_MODEL = 12864 {
   110                                  LCD_ROWS = 4
   111                                  LCD_COLUMNS = 16
   112                                  LCD_GRAPHICS = 1
   113                                  LCD_ADDR_LINE1 = 0x00
   114                                  LCD_ADDR_LINE2 = 0x10
   115                                  LCD_ADDR_LINE3 = 0x08
   116                                  LCD_ADDR_LINE4 = 0x18

; ******** Source: ../lib\lcd\lcd12864b.asm
     1                          ; 6502 12864B LCD - HBC-56
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          
    10                          
    11                          HAVE_GRAPHICS_LCD = 1
    12                          
    13                          ; -------------------------
    14                          ; Constants
    15                          ; -------------------------
    16                          LCD_CMD_12864B_EXTENDED         = $04
    17                          LCD_CMD_EXT_GRAPHICS_ENABLE     = $02
    18                          LCD_CMD_EXT_GRAPHICS_ADDR       = $80
    19                          
    20                          
    21                          LCD_BASIC           = LCD_INITIALIZE
    22                          LCD_EXTENDED        = LCD_INITIALIZE | LCD_CMD_12864B_EXTENDED
    23                          
    24                          ;---------------------------
    25                          
    26                          
    27                          ; -----------------------------------------------------------------------------
    28                          ; lcdGraphicsMode: Initialise the LCD graphics mode
    29                          ; -----------------------------------------------------------------------------
    30                          lcdGraphicsMode:
    31  e51a 2037e6                     jsr lcdWait
    32  e51d a93c                       lda #LCD_EXTENDED
    33  e51f 8d027f                     sta LCD_CMD
    34                          
    35  e522 2037e6                     jsr lcdWait
    36  e525 a93e                       lda #LCD_EXTENDED | LCD_CMD_EXT_GRAPHICS_ENABLE
    37  e527 8d027f                     sta LCD_CMD
    38  e52a 60                         rts
    39                          
    40                          ; -----------------------------------------------------------------------------
    41                          ; lcdTextMode: Initialise the LCD text mode
    42                          ; -----------------------------------------------------------------------------
    43                          lcdTextMode:
    44  e52b 2037e6                     jsr lcdWait
    45  e52e a93c                       lda #LCD_EXTENDED
    46  e530 8d027f                     sta LCD_CMD
    47                          
    48  e533 2037e6                     jsr lcdWait
    49  e536 a93c                       lda #LCD_EXTENDED
    50  e538 8d027f                     sta LCD_CMD
    51  e53b 60                         rts
    52                          
    53                          
    54                          ; -----------------------------------------------------------------------------
    55                          ; lcdSetRow: Set LCD address to graphics row
    56                          ; -----------------------------------------------------------------------------
    57                          ; Inputs:
    58                          ;  Y: Row of the LCD (0 - 63)
    59                          ; -----------------------------------------------------------------------------
    60                          lcdGraphicsSetRow:
    61  e53c 48                         pha
    62                          
    63                                  ; set y address (0 - 31)
    64  e53d 2037e6                     jsr lcdWait
    65  e540 98                         tya
    66  e541 291f                       and #$1f  ; only want 0-31
    67  e543 0980                       ora #LCD_CMD_EXT_GRAPHICS_ADDR
    68  e545 8d027f                     sta LCD_CMD
    69                          
    70                                  ; set x address - either 0 or 8
    71  e548 2037e6                     jsr lcdWait
    72  e54b 98                         tya
    73  e54c 2920                       and #$20
    74  e54e 4a                         lsr
    75  e54f 4a                         lsr
    76  e550 0980                       ora #LCD_CMD_EXT_GRAPHICS_ADDR
    77  e552 8d027f                     sta LCD_CMD
    78                          
    79  e555 68                         pla
    80  e556 60                         rts
    81                          
    82                          
    83                          ; -----------------------------------------------------------------------------
    84                          ; lcdImage: Output a full-screen image from memory (XY upper-left)
    85                          ; -----------------------------------------------------------------------------
    86                          ; Inputs:
    87                          ;  BITMAP_ADDR_H: Contains page-aligned address of 1-bit 128x64 bitmap
    88                          ; -----------------------------------------------------------------------------
    89                          lcdImage:
    90                          
    91  e557 a520                       lda BITMAP_ADDR_H
    92  e559 851f                       sta PIX_ADDR + 1
    93  e55b a200                       ldx #0
    94  e55d 861e                       stx PIX_ADDR
    95                          
    96                          .imageLoop:
    97                          
    98                                  ; x in the range 0-63
    99                          
   100                                  ; set y address
   101  e55f 2037e6                     jsr lcdWait
   102  e562 8a                         txa
   103  e563 291f                       and #$1f  ; only want 0-31
   104  e565 0980                       ora #LCD_CMD_EXT_GRAPHICS_ADDR
   105  e567 8d027f                     sta LCD_CMD
   106                          
   107                                  ; set x address - either 0 or 8
   108  e56a 2037e6                     jsr lcdWait
   109  e56d 8a                         txa
   110  e56e 2920                       and #$20
   111  e570 4a                         lsr
   112  e571 4a                         lsr
   113  e572 0980                       ora #LCD_CMD_EXT_GRAPHICS_ADDR
   114  e574 8d027f                     sta LCD_CMD
   115                          
   116                          
   117  e577 a000                       ldy #0
   118                          .imgRowLoop
   119  e579 2037e6                     jsr lcdWait
   120                                  
   121  e57c b11e                       lda (PIX_ADDR), y
   122  e57e 8d037f                     sta LCD_DATA
   123                                  
   124  e581 c8                         iny
   125  e582 c010                       cpy #16
   126  e584 d0f3                       bne .imgRowLoop
   127                                  
   128  e586 a51e                       lda PIX_ADDR
   129  e588 18                         clc
   130  e589 6910                       adc #16
   131  e58b 9002                       bcc +
   132  e58d e61f                       inc PIX_ADDR + 1
   133                          +
   134  e58f 851e                       sta PIX_ADDR
   135                          
   136  e591 e8                         inx
   137  e592 e040                       cpx #64
   138  e594 d0c9                       bne .imageLoop
   139                          
   140  e596 60                         rts
   141                                  
   142                                  
   143                          ; -----------------------------------------------------------------------------
   144                          ; lcdImageVflip: Output a full-screen image from memory (XY lower-left)
   145                          ; -----------------------------------------------------------------------------
   146                          ; Inputs:
   147                          ;  BITMAP_ADDR_H: Contains page-aligned address of 1-bit 128x64 bitmap
   148                          ; -----------------------------------------------------------------------------
   149                          lcdImageVflip:
   150                          
   151  e597 a520                       lda BITMAP_ADDR_H
   152  e599 18                         clc
   153  e59a 6903                       adc #3
   154  e59c 851f                       sta PIX_ADDR + 1
   155  e59e a2f0                       ldx #240
   156  e5a0 861e                       stx PIX_ADDR
   157  e5a2 a200                       ldx #0
   158                          
   159                          .imageLoopV:
   160                          
   161                                  ; x in the range 0-63
   162                          
   163                                  ; set y address
   164  e5a4 2037e6                     jsr lcdWait
   165  e5a7 8a                         txa
   166  e5a8 291f                       and #$1f  ; only want 0-31
   167  e5aa 0980                       ora #LCD_CMD_EXT_GRAPHICS_ADDR
   168  e5ac 8d027f                     sta LCD_CMD
   169                          
   170                                  ; set x address - either 0 or 8
   171  e5af 2037e6                     jsr lcdWait
   172  e5b2 8a                         txa
   173  e5b3 2920                       and #$20
   174  e5b5 4a                         lsr
   175  e5b6 4a                         lsr
   176  e5b7 0980                       ora #LCD_CMD_EXT_GRAPHICS_ADDR
   177  e5b9 8d027f                     sta LCD_CMD
   178                          
   179                          
   180  e5bc a000                       ldy #0
   181                          .imgRowLoopV
   182  e5be 2037e6                     jsr lcdWait
   183                                  
   184  e5c1 b11e                       lda (PIX_ADDR), y
   185  e5c3 8d037f                     sta LCD_DATA
   186                                  
   187  e5c6 c8                         iny
   188  e5c7 c010                       cpy #16
   189  e5c9 d0f3                       bne .imgRowLoopV
   190                                  
   191  e5cb a51e                       lda PIX_ADDR
   192  e5cd 38                         sec
   193  e5ce e910                       sbc #16
   194  e5d0 b004                       bcs +
   195  e5d2 a9f0                       lda #240
   196  e5d4 c61f                       dec PIX_ADDR + 1
   197                          +
   198  e5d6 851e                       sta PIX_ADDR
   199                          
   200  e5d8 e8                         inx
   201  e5d9 e040                       cpx #64
   202  e5db d0c7                       bne .imageLoopV
   203                          
   204  e5dd 60                         rts

; ******** Source: ../lib\lcd\lcd.asm
   118                          } else {
   119                                  !error "Unknown LCD_MODEL. Must be one of: 1602, 2004 or 12864"
   120                          }}}
   121                          
   122                          
   123                          LCD_INITIALIZE  = LCD_CMD_FUNCTIONSET | LCD_CMD_8BITMODE | LCD_CMD_2LINE
   124                          DISPLAY_MODE    = LCD_CMD_DISPLAY | LCD_CMD_DISPLAY_ON
   125                          
   126                          ASCII_NEWLINE = 10
   127                          
   128                          ; -----------------------------------------------------------------------------
   129                          ; lcdInit: Initialise the LCD
   130                          ; -----------------------------------------------------------------------------
   131                          lcdInit:
   132  e5de 2037e6                     jsr lcdWait
   133  e5e1 a938                       lda #LCD_INITIALIZE
   134  e5e3 8d027f                     sta LCD_CMD
   135  e5e6 20f0e5                     jsr lcdClear
   136  e5e9 20f9e5                     jsr lcdHome
   137  e5ec 200be6                     jsr lcdDisplayOff
   138  e5ef 60                         rts
   139                          
   140                          
   141                          ; -----------------------------------------------------------------------------
   142                          ; lcdClear: Clears the LCD
   143                          ; -----------------------------------------------------------------------------
   144                          lcdClear:
   145  e5f0 2037e6                     jsr lcdWait
   146  e5f3 a901                       lda #LCD_CMD_CLEAR
   147  e5f5 8d027f                     sta LCD_CMD
   148  e5f8 60                         rts     
   149                          
   150                          ; -----------------------------------------------------------------------------
   151                          ; lcdHome: Return to the start address
   152                          ; -----------------------------------------------------------------------------
   153                          lcdHome:
   154  e5f9 2037e6                     jsr lcdWait
   155  e5fc a902                       lda #LCD_CMD_HOME
   156  e5fe 8d027f                     sta LCD_CMD
   157  e601 60                         rts     
   158                          
   159                          ; -----------------------------------------------------------------------------
   160                          ; lcdDisplayOn: Turn the display on
   161                          ; -----------------------------------------------------------------------------
   162                          lcdDisplayOn:
   163  e602 2037e6                     jsr lcdWait
   164  e605 a90c                       lda #DISPLAY_MODE
   165  e607 8d027f                     sta LCD_CMD
   166  e60a 60                         rts
   167                          
   168                          ; -----------------------------------------------------------------------------
   169                          ; lcdDisplayOff: Turn the display off
   170                          ; -----------------------------------------------------------------------------
   171                          lcdDisplayOff:
   172  e60b 2037e6                     jsr lcdWait
   173  e60e a908                       lda #LCD_CMD_DISPLAY
   174  e610 8d027f                     sta LCD_CMD
   175  e613 60                         rts
   176                          
   177                          ; -----------------------------------------------------------------------------
   178                          ; lcdCursorOn: Show cursor
   179                          ; -----------------------------------------------------------------------------
   180                          lcdCursorOn:
   181  e614 2037e6                     jsr lcdWait
   182  e617 a90e                       lda #DISPLAY_MODE | LCD_CMD_DISPLAY_CURSOR
   183  e619 8d027f                     sta LCD_CMD
   184  e61c 60                         rts     
   185                          
   186                          ; -----------------------------------------------------------------------------
   187                          ; lcdCursorOff: Hide cursor
   188                          ; -----------------------------------------------------------------------------
   189                          lcdCursorOff:
   190  e61d 2037e6                     jsr lcdWait
   191  e620 a90c                       lda #DISPLAY_MODE
   192  e622 8d027f                     sta LCD_CMD
   193  e625 60                         rts     
   194                          
   195                          ; -----------------------------------------------------------------------------
   196                          ; lcdCursorBlinkOn: Show cursor
   197                          ; -----------------------------------------------------------------------------
   198                          lcdCursorBlinkOn:
   199  e626 2037e6                     jsr lcdWait
   200  e629 a90f                       lda #DISPLAY_MODE | LCD_CMD_DISPLAY_CURSOR | LCD_CMD_DISPLAY_CURSOR_BLINK
   201  e62b 8d027f                     sta LCD_CMD
   202  e62e 60                         rts     
   203                          
   204                          ; -----------------------------------------------------------------------------
   205                          ; lcdDetect: Do we have an LCD plugged in?
   206                          ; -----------------------------------------------------------------------------
   207                          ; Outputs:
   208                          ;  C: 1 if exists. 0 if not
   209                          ; -----------------------------------------------------------------------------
   210                          lcdDetect:
   211  e62f 18                         clc
   212  e630 ad027f                     lda LCD_CMD
   213  e633 d001                       bne +
   214  e635 38                         sec
   215                          +
   216  e636 60                         rts
   217                          
   218                          
   219                          ; -----------------------------------------------------------------------------
   220                          ; lcdWait: Wait until the LCD is no longer busy
   221                          ; -----------------------------------------------------------------------------
   222                          ; Outputs:
   223                          ;  A: Current LCD address
   224                          ; -----------------------------------------------------------------------------
   225                          lcdWait:
   226  e637 ad027f                     lda LCD_CMD
   227  e63a 30fb                       bmi lcdWait  ; branch if bit 7 is set
   228  e63c 60                         rts
   229                          
   230                          ; -----------------------------------------------------------------------------
   231                          ; lcdWaitPreserve: Wait until the LCD is no longer busy Preserves A, address in x
   232                          ; -----------------------------------------------------------------------------
   233                          lcdWaitPreserve:
   234  e63d ac027f                     ldy LCD_CMD
   235  e640 30fb                       bmi lcdWaitPreserve; branch if bit 7 is set
   236  e642 60                         rts
   237                          
   238                          ; -----------------------------------------------------------------------------
   239                          ; lcdRead: Read a character from the LCD
   240                          ; -----------------------------------------------------------------------------
   241                          ; Outputs:
   242                          ;  A: Character read
   243                          ; -----------------------------------------------------------------------------
   244                          lcdRead:
   245  e643 2037e6                     jsr lcdWait
   246  e646 ad037f                     lda LCD_DATA
   247  e649 60                         rts
   248                          
   249                          ; -----------------------------------------------------------------------------
   250                          ; lcdPrint: Print a null-terminated string
   251                          ; -----------------------------------------------------------------------------
   252                          ; Inputs:
   253                          ;  STR_ADDR: Contains address of null-terminated string
   254                          ; -----------------------------------------------------------------------------
   255                          lcdPrint:
   256  e64a a000                       ldy #0
   257                          -
   258  e64c 2037e6                     jsr lcdWait
   259  e64f b130                       lda (STR_ADDR), y
   260  e651 f012                       beq ++
   261  e653 c90a                       cmp #ASCII_NEWLINE ; check for newline
   262  e655 d007                       bne +
   263  e657 2028e8                     jsr lcdNextLine
   264  e65a c8                         iny
   265  e65b 4c4ce6                     jmp -
   266                          + 
   267  e65e 8d037f                     sta LCD_DATA
   268  e661 c8                         iny
   269  e662 4c4ce6                     jmp -
   270                          ++
   271  e665 60                         rts
   272                          
   273                          ; -----------------------------------------------------------------------------
   274                          ; lcdChar: Output a character
   275                          ; -----------------------------------------------------------------------------
   276                          ; Inputs:
   277                          ;  A: The character to output
   278                          ; -----------------------------------------------------------------------------
   279                          lcdChar:
   280  e666 203de6                     jsr lcdWaitPreserve
   281  e669 8d037f                     sta LCD_DATA
   282  e66c 60                         rts
   283                          
   284                          ; -----------------------------------------------------------------------------
   285                          ; lcdCharScroll: Output a character, scroll if required
   286                          ; -----------------------------------------------------------------------------
   287                          ; Inputs:
   288                          ;  A: The character to output
   289                          ; -----------------------------------------------------------------------------
   290                          lcdCharScroll:
   291  e66d 203de6                     jsr lcdWaitPreserve
   292  e670 8d037f                     sta LCD_DATA
   293                          
   294                                  ; Y is previous address
   295  e673 203fe7                     jsr lcdCurrentLine
   296  e676 8524                       sta LCD_TMP1
   297  e678 203de6                     jsr lcdWaitPreserve
   298  e67b 203fe7                     jsr lcdCurrentLine
   299  e67e 4524                       eor LCD_TMP1
   300  e680 f007                       beq +
   301  e682 e624                       inc LCD_TMP1
   302  e684 a524                       lda LCD_TMP1
   303  e686 4cd9e7                     jmp lcdGotoLine
   304                          +
   305  e689 60                         rts
   306                          
   307                          ; -----------------------------------------------------------------------------
   308                          ; lcdBackspace: Backspace a character
   309                          ; -----------------------------------------------------------------------------
   310                          lcdBackspace:
   311  e68a 203de6                     jsr lcdWaitPreserve
   312                                  ; Y is previous address
   313  e68d 203fe7                     jsr lcdCurrentLine
   314  e690 8524                       sta LCD_TMP1
   315                          
   316  e692 a910                       lda #LCD_CMD_SHIFT | LCD_CMD_SHIFT_LEFT
   317  e694 8d027f                     sta LCD_CMD
   318  e697 2037e6                     jsr lcdWait
   319  e69a 203de6                     jsr lcdWaitPreserve
   320  e69d 203fe7                     jsr lcdCurrentLine
   321  e6a0 4524                       eor LCD_TMP1
   322  e6a2 f009                       beq +
   323  e6a4 c624                       dec LCD_TMP1
   324  e6a6 3005                       bmi +
   325  e6a8 a524                       lda LCD_TMP1
   326  e6aa 4c42e7                     jmp lcdGotoLineEnd
   327                          +
   328  e6ad 2037e6                     jsr lcdWait
   329  e6b0 a920                       lda #' '
   330  e6b2 8d037f                     sta LCD_DATA
   331  e6b5 2037e6                     jsr lcdWait
   332  e6b8 a910                       lda #LCD_CMD_SHIFT | LCD_CMD_SHIFT_LEFT
   333  e6ba 8d027f                     sta LCD_CMD
   334                          
   335  e6bd 60                         rts
   336                          
   337                          ; -----------------------------------------------------------------------------
   338                          ; lcdInt8: Output an 8-bit integer
   339                          ; -----------------------------------------------------------------------------
   340                          ; Inputs:
   341                          ;  A: The value to output
   342                          ; -----------------------------------------------------------------------------
   343                          lcdInt8:
   344                          
   345                          .B = LCD_TMP1
   346                          .C = LCD_TMP2
   347                          
   348  e6be 48                         pha
   349  e6bf a201                       ldx #1
   350  e6c1 8625                       stx .C
   351  e6c3 e8                         inx
   352  e6c4 a040                       ldy #$40
   353                          --
   354  e6c6 8424                       sty .B
   355  e6c8 4a                         lsr
   356                          -
   357  e6c9 2a                         rol
   358  e6ca b005                       bcs +
   359  e6cc ddf1e6                     cmp .A, x
   360  e6cf 9004                       bcc ++
   361                          + 
   362  e6d1 fdf1e6                     sbc .A, x
   363  e6d4 38                         sec
   364                          ++ 
   365  e6d5 2624                       rol .B
   366  e6d7 90f0                       bcc -
   367  e6d9 a8                         tay
   368  e6da e425                       cpx .C
   369  e6dc a524                       lda .B
   370  e6de 9004                       bcc +
   371  e6e0 f007                       beq ++
   372  e6e2 8625                       stx .C
   373                          +
   374  e6e4 4930                       eor #$30
   375  e6e6 2066e6                     jsr lcdChar
   376                          ++
   377  e6e9 98                         tya
   378  e6ea a010                       ldy #$10
   379  e6ec ca                         dex
   380  e6ed 10d7                       bpl --
   381  e6ef 68                         pla
   382  e6f0 60                         rts
   383                          
   384  e6f1 80a0c8             .A !byte 128,160,200
   385                          
   386                          
   387                          ; -----------------------------------------------------------------------------
   388                          ; lcdHex8: Output an 8-bit byte as hexadecimal
   389                          ; -----------------------------------------------------------------------------
   390                          ; Inputs:
   391                          ;  A: The value to output
   392                          ; -----------------------------------------------------------------------------
   393                          lcdHex8:
   394  e6f4 48                         pha
   395  e6f5 4a                         lsr
   396  e6f6 4a                         lsr
   397  e6f7 4a                         lsr
   398  e6f8 4a                         lsr
   399  e6f9 aa                         tax
   400  e6fa bd0de7                     lda .H, x
   401  e6fd 2066e6                     jsr lcdChar
   402  e700 68                         pla
   403  e701 48                         pha
   404  e702 290f                       and #$0f
   405  e704 aa                         tax
   406  e705 bd0de7                     lda .H, x
   407  e708 2066e6                     jsr lcdChar
   408  e70b 68                         pla
   409  e70c 60                         rts
   410                          
   411  e70d 3031323334353637....H !text "0123456789abcdef"
   412                          
   413                          
   414                          !if LCD_ROWS > 2 {
   415                          
   416                          lcdCurrentLine4:
   417  e71d c018                       cpy #LCD_ADDR_LINE4
   418  e71f b00e                       bcs .lcdLine4
   419  e721 c010                       cpy #LCD_ADDR_LINE2
   420  e723 b017                       bcs .lcdLine2
   421  e725 c008                       cpy #LCD_ADDR_LINE3
   422  e727 b003                       bcs .lcdLine3
   423  e729 4c39e7                     jmp .lcdLine1
   424                          
   425                          .lcdLine3
   426  e72c a903                       lda #3
   427  e72e 60                         rts
   428                          
   429                          .lcdLine4
   430  e72f a904                       lda #4
   431  e731 60                         rts
   432                          
   433                          } ; LCD_ROWS > 2
   434                          
   435                          lcdCurrentLine2:
   436  e732 c010                       cpy #LCD_ADDR_LINE1+LCD_COLUMNS;16;LCD_ADDR_LINE2
   437  e734 9003                       bcc .lcdLine1
   438  e736 4c3ce7                     jmp .lcdLine2
   439                          
   440                          .lcdLine1
   441  e739 a901                       lda #1
   442  e73b 60                         rts
   443                          
   444                          .lcdLine2
   445  e73c a902                       lda #2
   446  e73e 60                         rts
   447                          
   448                          ; -----------------------------------------------------------------------------
   449                          ; lcdCurrentLine: Return the current line/row
   450                          ; -----------------------------------------------------------------------------
   451                          lcdCurrentLine:
   452                          !if LCD_ROWS > 2 {
   453  e73f 4c1de7                     jmp lcdCurrentLine4
   454                          } else {
   455                                  jmp lcdCurrentLine2
   456                          }
   457                          
   458                          
   459                          
   460                          ; -----------------------------------------------------------------------------
   461                          ; lcdGotoLineEnd: Go to end of line in 'A'
   462                          ; -----------------------------------------------------------------------------
   463                          lcdGotoLineEnd:
   464                          !if LCD_ROWS > 2 {
   465  e742 c904                       cmp #4
   466  e744 f071                       beq lcdLineFourEnd
   467  e746 c903                       cmp #3
   468  e748 f04b                       beq lcdLineThreeEnd
   469                          }
   470  e74a c902                       cmp #2
   471  e74c f025                       beq lcdLineTwoEnd
   472  e74e 4c51e7                     jmp lcdLineOneEnd
   473                          
   474                          
   475                          ; -----------------------------------------------------------------------------
   476                          ; lcdLineOneEnd: Move cursor to end of line 1
   477                          ; -----------------------------------------------------------------------------
   478                          lcdLineOneEnd:
   479  e751 48                         pha
   480                          !if LCD_MODEL = 12864 {
   481  e752 a987                       lda #(LCD_CMD_SET_DRAM_ADDR | LCD_ADDR_LINE1) + (LCD_COLUMNS/2) - 1
   482  e754 8d027f                     sta LCD_CMD
   483  e757 2043e6                     jsr lcdRead
   484  e75a 48                         pha
   485  e75b a987                       lda #(LCD_CMD_SET_DRAM_ADDR | LCD_ADDR_LINE1) + (LCD_COLUMNS/2) - 1
   486  e75d 8d027f                     sta LCD_CMD
   487  e760 a920                       lda #' '
   488  e762 2066e6                     jsr lcdChar
   489  e765 2066e6                     jsr lcdChar
   490  e768 a987                       lda #(LCD_CMD_SET_DRAM_ADDR | LCD_ADDR_LINE1) + (LCD_COLUMNS/2) - 1
   491  e76a 8d027f                     sta LCD_CMD
   492  e76d 68                         pla
   493  e76e 2066e6                     jsr lcdChar
   494                          } else {
   495                                  lda #(LCD_CMD_SET_DRAM_ADDR | LCD_ADDR_LINE1) + (LCD_COLUMNS) - 2
   496                                  sta LCD_CMD
   497                                  jsr lcdRead
   498                                  pha
   499                                  lda #(LCD_CMD_SET_DRAM_ADDR | LCD_ADDR_LINE1) + (LCD_COLUMNS) - 2
   500                                  sta LCD_CMD
   501                                  lda #' '
   502                                  jsr lcdChar
   503                                  jsr lcdChar
   504                                  lda #(LCD_CMD_SET_DRAM_ADDR | LCD_ADDR_LINE1) + (LCD_COLUMNS) - 2
   505                                  sta LCD_CMD
   506                                  pla
   507                                  jsr lcdChar
   508                          }
   509  e771 68                         pla
   510  e772 60                         rts
   511                          
   512                          ; -----------------------------------------------------------------------------
   513                          ; lcdLineTwoEnd: Move cursor to end of line 2
   514                          ; -----------------------------------------------------------------------------
   515                          lcdLineTwoEnd:
   516  e773 48                         pha
   517                          !if LCD_MODEL = 12864 {
   518  e774 a997                       lda #(LCD_CMD_SET_DRAM_ADDR | LCD_ADDR_LINE2) + (LCD_COLUMNS/2) - 1
   519  e776 8d027f                     sta LCD_CMD
   520  e779 2043e6                     jsr lcdRead
   521  e77c 48                         pha
   522  e77d a997                       lda #(LCD_CMD_SET_DRAM_ADDR | LCD_ADDR_LINE2) + (LCD_COLUMNS/2) - 1
   523  e77f 8d027f                     sta LCD_CMD
   524  e782 a920                       lda #' '
   525  e784 2066e6                     jsr lcdChar
   526  e787 2066e6                     jsr lcdChar
   527  e78a a997                       lda #(LCD_CMD_SET_DRAM_ADDR | LCD_ADDR_LINE2) + (LCD_COLUMNS/2) - 1
   528  e78c 8d027f                     sta LCD_CMD
   529  e78f 68                         pla
   530  e790 2066e6                     jsr lcdChar
   531                          } else {
   532                                  lda #(LCD_CMD_SET_DRAM_ADDR | LCD_ADDR_LINE2) + (LCD_COLUMNS) - 2
   533                                  sta LCD_CMD
   534                                  jsr lcdRead
   535                                  pha
   536                                  lda #(LCD_CMD_SET_DRAM_ADDR | LCD_ADDR_LINE2) + (LCD_COLUMNS) - 2
   537                                  sta LCD_CMD
   538                                  lda #' '
   539                                  jsr lcdChar
   540                                  jsr lcdChar
   541                                  lda #(LCD_CMD_SET_DRAM_ADDR | LCD_ADDR_LINE2) + (LCD_COLUMNS) - 2
   542                                  sta LCD_CMD
   543                                  pla
   544                                  jsr lcdChar
   545                          }
   546  e793 68                         pla
   547  e794 60                         rts
   548                          
   549                          
   550                           !if LCD_ROWS > 2 {
   551                          ; -----------------------------------------------------------------------------
   552                          ; lcdLineThreeEnd: Move cursor to end of line 3
   553                          ; -----------------------------------------------------------------------------
   554                          lcdLineThreeEnd:
   555  e795 48                         pha
   556                          !if LCD_MODEL = 12864 {
   557  e796 a98f                       lda #(LCD_CMD_SET_DRAM_ADDR | LCD_ADDR_LINE3) + (LCD_COLUMNS/2) - 1
   558  e798 8d027f                     sta LCD_CMD
   559  e79b 2043e6                     jsr lcdRead
   560  e79e 48                         pha
   561  e79f a98f                       lda #(LCD_CMD_SET_DRAM_ADDR | LCD_ADDR_LINE3) + (LCD_COLUMNS/2) - 1
   562  e7a1 8d027f                     sta LCD_CMD
   563  e7a4 a920                       lda #' '
   564  e7a6 2066e6                     jsr lcdChar
   565  e7a9 2066e6                     jsr lcdChar
   566  e7ac a98f                       lda #(LCD_CMD_SET_DRAM_ADDR | LCD_ADDR_LINE3) + (LCD_COLUMNS/2) - 1
   567  e7ae 8d027f                     sta LCD_CMD
   568  e7b1 68                         pla
   569  e7b2 2066e6                     jsr lcdChar
   570                          } else {
   571                                  lda #(LCD_CMD_SET_DRAM_ADDR | LCD_ADDR_LINE3) + (LCD_COLUMNS) - 2
   572                                  sta LCD_CMD
   573                                  jsr lcdRead
   574                                  pha
   575                                  lda #(LCD_CMD_SET_DRAM_ADDR | LCD_ADDR_LINE3) + (LCD_COLUMNS) - 2
   576                                  sta LCD_CMD
   577                                  lda #' '
   578                                  jsr lcdChar
   579                                  jsr lcdChar
   580                                  lda #(LCD_CMD_SET_DRAM_ADDR | LCD_ADDR_LINE3) + (LCD_COLUMNS) - 2
   581                                  sta LCD_CMD
   582                                  pla
   583                                  jsr lcdChar
   584                          }
   585  e7b5 68                         pla
   586  e7b6 60                         rts
   587                          
   588                          ; -----------------------------------------------------------------------------
   589                          ; lcdLineFourEnd: Move cursor to end of line 4
   590                          ; -----------------------------------------------------------------------------
   591                          lcdLineFourEnd:
   592  e7b7 48                         pha
   593                          !if LCD_MODEL = 12864 {
   594  e7b8 a99f                       lda #(LCD_CMD_SET_DRAM_ADDR | LCD_ADDR_LINE4) + (LCD_COLUMNS/2) - 1
   595  e7ba 8d027f                     sta LCD_CMD
   596  e7bd 2043e6                     jsr lcdRead
   597  e7c0 48                         pha
   598  e7c1 a99f                       lda #(LCD_CMD_SET_DRAM_ADDR | LCD_ADDR_LINE4) + (LCD_COLUMNS/2) - 1
   599  e7c3 8d027f                     sta LCD_CMD
   600  e7c6 a920                       lda #' '
   601  e7c8 2066e6                     jsr lcdChar
   602  e7cb 2066e6                     jsr lcdChar
   603  e7ce a99f                       lda #(LCD_CMD_SET_DRAM_ADDR | LCD_ADDR_LINE4) + (LCD_COLUMNS/2) - 1
   604  e7d0 8d027f                     sta LCD_CMD
   605  e7d3 68                         pla
   606  e7d4 2066e6                     jsr lcdChar
   607                          } else {
   608                                  lda #(LCD_CMD_SET_DRAM_ADDR | LCD_ADDR_LINE4) + (LCD_COLUMNS) - 2
   609                                  sta LCD_CMD
   610                                  jsr lcdRead
   611                                  pha
   612                                  lda #(LCD_CMD_SET_DRAM_ADDR | LCD_ADDR_LINE4) + (LCD_COLUMNS) - 2
   613                                  sta LCD_CMD
   614                                  lda #' '
   615                                  jsr lcdChar
   616                                  jsr lcdChar
   617                                  lda #(LCD_CMD_SET_DRAM_ADDR | LCD_ADDR_LINE4) + (LCD_COLUMNS) - 2
   618                                  sta LCD_CMD
   619                                  pla
   620                                  jsr lcdChar
   621                          }
   622  e7d7 68                         pla
   623  e7d8 60                         rts
   624                          
   625                          
   626                          } ; LCD_ROWS > 2
   627                          
   628                          ; -----------------------------------------------------------------------------
   629                          ; lcdGotoLine: Go to line in 'A'
   630                          ; -----------------------------------------------------------------------------
   631                          lcdGotoLine:
   632                          !if LCD_ROWS > 2 {
   633  e7d9 c904                       cmp #4
   634  e7db f027                       beq lcdLineFour
   635  e7dd c903                       cmp #3
   636  e7df f01b                       beq lcdLineThree
   637                          }
   638  e7e1 c902                       cmp #2
   639  e7e3 f00f                       beq lcdLineTwo
   640  e7e5 c901                       cmp #1
   641  e7e7 f003                       beq lcdLineOne
   642  e7e9 4c3ce8                     jmp lcdScrollUp
   643                          
   644                          
   645                          ; -----------------------------------------------------------------------------
   646                          ; lcdLineOne: Move cursor to line 1
   647                          ; -----------------------------------------------------------------------------
   648                          lcdLineOne:
   649  e7ec 48                         pha
   650  e7ed a980                       lda #(LCD_CMD_SET_DRAM_ADDR | LCD_ADDR_LINE1)
   651  e7ef 8d027f                     sta LCD_CMD
   652  e7f2 68                         pla
   653  e7f3 60                         rts
   654                          
   655                          ; -----------------------------------------------------------------------------
   656                          ; lcdLineTwo: Move cursor to line 2
   657                          ; -----------------------------------------------------------------------------
   658                          lcdLineTwo:
   659  e7f4 48                         pha
   660  e7f5 a990                       lda #(LCD_CMD_SET_DRAM_ADDR | LCD_ADDR_LINE2)
   661  e7f7 8d027f                     sta LCD_CMD
   662  e7fa 68                         pla
   663  e7fb 60                         rts
   664                          
   665                          
   666                           !if LCD_ROWS > 2 {
   667                          ; -----------------------------------------------------------------------------
   668                          ; lcdLineThree: Move cursor to line 3
   669                          ; -----------------------------------------------------------------------------
   670                          lcdLineThree:
   671  e7fc 48                         pha
   672  e7fd a988                       lda #(LCD_CMD_SET_DRAM_ADDR | LCD_ADDR_LINE3)
   673  e7ff 8d027f                     sta LCD_CMD
   674  e802 68                         pla
   675  e803 60                         rts
   676                          
   677                          ; -----------------------------------------------------------------------------
   678                          ; lcdLineFour: Move cursor to line 4
   679                          ; -----------------------------------------------------------------------------
   680                          lcdLineFour:
   681  e804 48                         pha
   682  e805 a998                       lda #(LCD_CMD_SET_DRAM_ADDR | LCD_ADDR_LINE4)
   683  e807 8d027f                     sta LCD_CMD
   684  e80a 68                         pla
   685  e80b 60                         rts
   686                           
   687                          ; -----------------------------------------------------------------------------
   688                          ; lcdNextLine4: Move cursor to next line (4-row LCD version)
   689                          ; -----------------------------------------------------------------------------
   690                          lcdNextLine4:
   691  e80c 2037e6                     jsr lcdWait
   692                                  ; A now contains address
   693  e80f c918                       cmp #LCD_ADDR_LINE4
   694  e811 b029                       bcs lcdScrollUp
   695  e813 c910                       cmp #LCD_ADDR_LINE2
   696  e815 b0e5                       bcs lcdLineThree
   697  e817 c908                       cmp #LCD_ADDR_LINE3
   698  e819 b0e9                       bcs lcdLineFour
   699                                  
   700  e81b 4cf4e7                     jmp lcdLineTwo
   701                           }
   702                           
   703                          
   704                          ; -----------------------------------------------------------------------------
   705                          ; lcdNextLine2: Move cursor to next line (2-row LCD version)
   706                          ; -----------------------------------------------------------------------------
   707                          lcdNextLine2:
   708  e81e 2037e6                     jsr lcdWait
   709                                  ; A now contains address
   710  e821 c910                       cmp #LCD_ADDR_LINE2
   711  e823 b017                       bcs lcdScrollUp
   712  e825 4cf4e7                     jmp lcdLineTwo
   713                          
   714                          ; -----------------------------------------------------------------------------
   715                          ; lcdNextLine: Move cursor to next line
   716                          ; -----------------------------------------------------------------------------
   717                          lcdNextLine:
   718                          !if LCD_ROWS > 2 {
   719  e828 4c0ce8                     jmp lcdNextLine4
   720                          } else {
   721                                  jmp lcdNextLine2
   722                          }
   723                          
   724                          ; -----------------------------------------------------------------------------
   725                          ; lcdReadLine: Reads a line from the display
   726                          ; -----------------------------------------------------------------------------
   727                          ; Inputs:
   728                          ;  STR_ADDR: Contains address to output null-terminated line to
   729                          ; -----------------------------------------------------------------------------
   730                          lcdReadLine:
   731  e82b a000                       ldy #0
   732                          -
   733  e82d 2043e6                     jsr lcdRead
   734  e830 9130                       sta (STR_ADDR), y
   735  e832 c8                         iny
   736  e833 c010                       cpy #LCD_COLUMNS
   737  e835 d0f6                       bne -
   738  e837 a900                       lda #0
   739  e839 9130                       sta (STR_ADDR), y
   740  e83b 60                         rts
   741                          
   742                          ; -----------------------------------------------------------------------------
   743                          ; lcdScrollUp: Scroll the LCD up one line
   744                          ; -----------------------------------------------------------------------------
   745                          lcdScrollUp:
   746  e83c 48                         pha
   747                          
   748  e83d a926                       lda #<.LCD_BUFFER_ADDR
   749  e83f 8530                       sta STR_ADDR_L
   750  e841 a97b                       lda #>.LCD_BUFFER_ADDR
   751  e843 8531                       sta STR_ADDR_H
   752                          
   753  e845 2037e6                     jsr lcdWait
   754  e848 20f4e7                     jsr lcdLineTwo
   755  e84b 202be8                     jsr lcdReadLine
   756  e84e 2037e6                     jsr lcdWait
   757  e851 20ece7                     jsr lcdLineOne
   758  e854 204ae6                     jsr lcdPrint
   759  e857 2037e6                     jsr lcdWait
   760                          
   761                          !if LCD_ROWS > 2 {
   762                          
   763  e85a 20fce7                     jsr lcdLineThree
   764  e85d 202be8                     jsr lcdReadLine
   765  e860 2037e6                     jsr lcdWait
   766  e863 20f4e7                     jsr lcdLineTwo
   767  e866 204ae6                     jsr lcdPrint
   768                                  
   769  e869 2037e6                     jsr lcdWait
   770  e86c 2004e8                     jsr lcdLineFour
   771  e86f 202be8                     jsr lcdReadLine
   772  e872 2037e6                     jsr lcdWait
   773  e875 20fce7                     jsr lcdLineThree
   774  e878 204ae6                     jsr lcdPrint
   775                                  
   776  e87b 2037e6                     jsr lcdWait
   777  e87e 2004e8                     jsr lcdLineFour
   778                          } else {
   779                                  jsr lcdLineTwo
   780                          }
   781                          
   782  e881 a210                       ldx #LCD_COLUMNS
   783                          -
   784  e883 48a9202066e668             +lcdChar ' '
   785  e88a ca                         dex
   786  e88b d0f6                       bne -
   787  e88d 2037e6                     jsr lcdWait
   788                          !if LCD_ROWS > 2 {
   789  e890 2004e8                     jsr lcdLineFour
   790                          } else {
   791                                  jsr lcdLineTwo
   792                          }
   793  e893 68                         pla
   794  e894 60                         rts
   795                          
   796                          ; -----------------------------------------------------------------------------
   797                          ; lcdConsoleOut: Print a null-terminated string
   798                          ; -----------------------------------------------------------------------------
   799                          ; Inputs:
   800                          ;  'A': Character to output to console
   801                          ; -----------------------------------------------------------------------------
   802                          lcdConsoleOut:
   803  e895 8c4e7b                     sty .LCD_REGY_TMP
   804  e898 c90a                       cmp #ASCII_RETURN
   805  e89a f013                       beq .newline
   806  e89c c908                       cmp #ASCII_BACKSPACE
   807  e89e f015                       beq .backspace
   808  e8a0 c90d                       cmp #ASCII_CR   ; omit these
   809  e8a2 f007                       beq .endOut
   810  e8a4 c900                       cmp #0
   811  e8a6 f003                       beq .endOut
   812                          
   813                                  ; regular character
   814  e8a8 206de6                     jsr lcdCharScroll ; outputs A to the LCD - auto-scrolls too :)
   815                          
   816                          .endOut:
   817  e8ab ac4e7b                     ldy .LCD_REGY_TMP
   818  e8ae 60                         rts
   819                          
   820                          .newline
   821  e8af 2028e8                     jsr lcdNextLine ; scroll to the next line... scroll screen if on last line
   822  e8b2 4cabe8                     jmp .endOut
   823                          
   824                          .backspace
   825  e8b5 208ae6                     jsr lcdBackspace 
   826  e8b8 4cabe8                     jmp .endOut
   827                          
   828                          ; -----------------------------------------------------------------------------
   829                          ; lcdConsolePrint: Print a null-terminated string (console mode)
   830                          ; -----------------------------------------------------------------------------
   831                          ; Inputs:
   832                          ;  STR_ADDR: Contains address of null-terminated string
   833                          ; -----------------------------------------------------------------------------
   834                          lcdConsolePrint:
   835  e8bb a000                       ldy #0
   836                          -
   837  e8bd b130                       lda (STR_ADDR), y
   838  e8bf f006                       beq +
   839  e8c1 2095e8                     jsr lcdConsoleOut
   840  e8c4 c8                         iny
   841  e8c5 d0f6                       bne -
   842                          +
   843  e8c7 60                         rts
   844                          

; ******** Source: kernel.asm

; ******** Source: ../lib\gfx\tilemap.asm
     1                          ; 6502 - Tilemap
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          ;
    10                          ; Tilemap structure
    11                          ; ---------------------
    12                          ; BufferAddressH   (Page-aligned buffer - MSB)
    13                          ; Size
    14                          ; TilesetAddressH  (Page-aligned tilset - MSB)
    15                          ; InvertAddressH   (Page-aligned invert flags - MSB) (optional)
    16                          ; DirtyAddressH    (Page-aligned dirty flags - MSB)  (optional)
    17                          

; ******** Source: ../lib\gfx\tilemap.inc
     1                          ; 6502 - Tilemap
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          ;
    10                          
    11                          
    12                          
    13                          !macro tilemapCreate .tilemapStructAddr, .bufferAddr, .tilesetAddr, .sizeFlags, .tileSizePx, .invertAddr, .dirtyAddr {
    14                                  !if <.tilesetAddr != 0 { !error "tilemapCreate: Tileset address must be page-aligned",.tilesetAddr }
    15                                  !if >.tilesetAddr < 3 { !error "tilemapCreate: Tileset address must be greater than $2ff",.tilesetAddr }
    16                                  !if <.bufferAddr != 0 { !error "tilemapCreate: Buffer address must be page-aligned",.bufferAddr }
    17                                  !if >.bufferAddr < 3 { !error "tilemapCreate: Buffer address must be greater than $2ff",.bufferAddr }
    18                                  !if .invertAddr != 0 and <.invertAddr != 0  {!error "tilemapCreate: Invert address must be page-aligned", .invertAddr}
    19                                  !if .invertAddr != 0 and >.invertAddr < 3  {!error "tilemapCreate: Invert address must be greater than $2ff", .invertAddr}
    20                                  !if .dirtyAddr != 0 and <.dirtyAddr != 0  {!error "tilemapCreate: Dirty address must be page-aligned", .dirtyAddr}
    21                                  !if .dirtyAddr != 0 and >.dirtyAddr < 3  {!error "tilemapCreate: Dirty address must be greater than $2ff", .dirtyAddr}
    22                                  !if .tileSizePx != 4 and .tileSizePx != 8 {!error "tilemapCreate: Tile size must be 4 or 8 pixels",.tileSizePx}
    23                          
    24                                  lda #<.tilemapStructAddr
    25                                  sta TILEMAP_ADDR
    26                                  lda #>.tilemapStructAddr
    27                                  sta TILEMAP_ADDR + 1
    28                          
    29                                  lda #>.bufferAddr
    30                                  sta .tilemapStructAddr + TILEMAP_BUFFER_ADDR
    31                                  lda #.sizeFlags
    32                                  sta .tilemapStructAddr + TILEMAP_SIZE
    33                                  lda #>.tilesetAddr
    34                                  sta .tilemapStructAddr + TILEMAP_TILES_ADDR
    35                                  lda #>.invertAddr
    36                                  sta .tilemapStructAddr + TILEMAP_INVERT_ADDR
    37                                  lda #>.dirtyAddr
    38                                  sta .tilemapStructAddr + TILEMAP_DIRTY_ADDR
    39                                  lda #.tileSizePx
    40                                  sta .tilemapStructAddr + TILEMAP_TILE_SIZE_PX
    41                          
    42                                  jsr tilemapInit
    43                          }
    44                          
    45                          !macro tilemapCreateDefault .sizeFlags, .tilesetAddr {
    46                                  +tilemapCreate TILEMAP_FIXED_ADDRESS, TILEMAP_DEFAULT_BUFFER_ADDRESS, .tilesetAddr, .sizeFlags, 8, $0, $0
    47                          }
    48                          
    49                          !macro tilemapSetActive .tilemapStructAddr {
    50                                  lda #<.tilemapStructAddr
    51                                  sta TILEMAP_ADDR
    52                                  lda #>.tilemapStructAddr
    53                                  sta TILEMAP_ADDR + 1
    54                          
    55                                  jsr tilemapSetActive

; ******** Source: ../lib\gfx\tilemap.asm
    19                          
    20                          HAVE_TILEMAP = 1
    21                          
    22                          
    23                          !ifndef TILEMAP_ZP_START { TILEMAP_ZP_START = $20
    24                                  !warn "TILEMAP_ZP_START not provided. Defaulting to ", TILEMAP_ZP_START
    25                          }
    26                          
    27                          !ifndef TILEMAP_RAM_START { TILEMAP_RAM_START = $7a00
    28                                  !warn "TILEMAP_RAM_START not provided. Defaulting to ", TILEMAP_RAM_START
    29                          }
    30                          
    31                          !if (TILEMAP_RAM_START & $ff) != 0 {
    32                                  !error "TILEMAP_RAM_START must be on a page boundary"
    33                          }
    34                          
    35                          ; -------------------------
    36                          ; Tilemap structure
    37                          ; -------------------------
    38                          TILEMAP_BUFFER_ADDR     = 0                             ; High byte of page-aligned buffer
    39                          TILEMAP_SIZE            = 1     ; Size flags
    40                          TILEMAP_TILES_ADDR      = 2
    41                          TILEMAP_INVERT_ADDR     = 3     ; High byte of tilemap
    42                          TILEMAP_DIRTY_ADDR      = 4
    43                          TILEMAP_WIDTH_TILES     = 5
    44                          TILEMAP_HEIGHT_TILES    = 6
    45                          TILEMAP_TILE_SIZE_PX    = 7
    46                          TILEMAP_STRUCTURE_SIZE  = TILEMAP_TILE_SIZE_PX
    47                          
    48                          
    49                          ; -------------------------
    50                          ; Zero page
    51                          ; -------------------------
    52                          TILEMAP_ADDR            = TILEMAP_ZP_START
    53                          TILEMAP_TMP_BUFFER_ADDR = TILEMAP_ZP_START + 2
    54                          TILEMAP_TMP_TILES_ADDR  = TILEMAP_ZP_START + 4
    55                          TILEMAP_ZP_SIZE         = 6
    56                          
    57                          ; -----------------------------------------------------------------------------
    58                          ; High RAM
    59                          ; -----------------------------------------------------------------------------
    60                          TILEMAP_DEFAULT_BUFFER_ADDRESS = TILEMAP_RAM_START
    61                          
    62                          TILEMAP_TMP_BUF_ROW     = TILEMAP_RAM_START + $80
    63                          TILEMAP_TMP_BUF_COL     = TILEMAP_RAM_START + $81
    64                          TILEMAP_TMP_TILE_ROW    = TILEMAP_RAM_START + $82
    65                          TILEMAP_TMP_OUTPUT_ROW  = TILEMAP_RAM_START + $83
    66                          TILEMAP_TMP_1           = TILEMAP_RAM_START + $84
    67                          TILEMAP_TMP_2           = TILEMAP_RAM_START + $85
    68                          TILEMAP_TMP_TILES_W     = TILEMAP_RAM_START + $86
    69                          TILEMAP_TMP_TILES_H     = TILEMAP_RAM_START + $87
    70                          TILEMAP_TMP_TILE_SIZE   = TILEMAP_RAM_START + $88
    71                          
    72                          TILEMAP_FIXED_ADDRESS   = TILEMAP_RAM_START + $100
    73                          
    74                          TILEMAP_RAM_SIZE        = (TILEMAP_FIXED_ADDRESS + TILEMAP_STRUCTURE_SIZE) - TILEMAP_RAM_START
    75                          
    76                          
    77                          
    78                          !if TILEMAP_ZP_END < (TILEMAP_ZP_START + TILEMAP_ZP_SIZE) {
    79                                  !error "TILEMAP_ZP requires ",TILEMAP_ZP_SIZE," bytes. Allocated ",TILEMAP_ZP_END - TILEMAP_ZP_START
    80                          }
    81                          
    82                          !if TILEMAP_RAM_END < (TILEMAP_RAM_START + TILEMAP_RAM_SIZE) {
    83                                  !error "TILEMAP_RAM requires ",TILEMAP_RAM_SIZE," bytes. Allocated ",TILEMAP_RAM_END - TILEMAP_RAM_START
    84                          }
    85                          
    86                          ; -------------------------
    87                          ; Contants
    88                          ; -------------------------
    89                          TILEMAP_SIZE_X_16       = %00000000
    90                          TILEMAP_SIZE_X_32       = %00000001
    91                          TILEMAP_SIZE_X_64       = %00000010
    92                          TILEMAP_SIZE_Y_8        = %00000000
    93                          TILEMAP_SIZE_Y_16       = %00000100
    94                          TILEMAP_SIZE_Y_32       = %00001000
    95                          
    96                          TILE_SIZE               = 8     ; size of each tile (in px)
    97                          
    98                          
    99                          
   100                          
   101                          ; -----------------------------------------------------------------------------
   102                          ; tilemapInit: Initialise a tilemap
   103                          ; -----------------------------------------------------------------------------
   104                          ; Inputs:
   105                          ;  TILEMAP_ADDR: Address of tilemap structure
   106                          ; -----------------------------------------------------------------------------
   107                          tilemapInit:
   108  e8c8 a000                       ldy #0
   109  e8ca 842e                       sty MEM_LEN
   110  e8cc 842f                       sty MEM_LEN + 1
   111  e8ce 842a                       sty MEM_DST
   112  e8d0 b118                       lda (TILEMAP_ADDR), y  ; buffer address H
   113  e8d2 852b                       sta MEM_DST + 1
   114  e8d4 851b                       sta TILEMAP_TMP_BUFFER_ADDR + 1
   115                          
   116  e8d6 a001                       ldy #TILEMAP_SIZE
   117                          
   118                          @MIN_WIDTH=16
   119                          @MIN_HEIGHT=8
   120                          
   121  e8d8 a910                       lda #@MIN_WIDTH         ; minimum width
   122  e8da 8d817a                     sta TILEMAP_TMP_BUF_COL ; temporary storage for x tiles
   123  e8dd a908                       lda #@MIN_HEIGHT        ; minimum height
   124  e8df 8d807a                     sta TILEMAP_TMP_BUF_ROW ; temporary storage for y tiles
   125                          
   126  e8e2 a900                       lda #0
   127  e8e4 852f                       sta MEM_LEN + 1
   128  e8e6 a980                       lda #(@MIN_WIDTH * @MIN_HEIGHT) ; base size (16 x 8)
   129  e8e8 852e                       sta MEM_LEN                     ; size in bytes
   130  e8ea b118                       lda (TILEMAP_ADDR), y           ; size flags
   131  e8ec 8d847a                     sta TILEMAP_TMP_1
   132  e8ef f038                       beq ++
   133                          
   134                          
   135                                  ; check size flags, multiple size
   136  e8f1 a903                       lda #TILEMAP_SIZE_X_32 | TILEMAP_SIZE_X_64
   137  e8f3 2c847a                     bit TILEMAP_TMP_1
   138  e8f6 f015                       beq +
   139  e8f8 062e                       asl MEM_LEN
   140  e8fa 262f                       rol MEM_LEN  + 1
   141  e8fc 0e817a                     asl TILEMAP_TMP_BUF_COL
   142  e8ff a902                       lda #TILEMAP_SIZE_X_64
   143  e901 2c847a                     bit TILEMAP_TMP_1
   144  e904 f007                       beq +
   145  e906 062e                       asl MEM_LEN
   146  e908 262f                       rol MEM_LEN  + 1
   147  e90a 0e817a                     asl TILEMAP_TMP_BUF_COL
   148                          +
   149  e90d a90c                       lda #TILEMAP_SIZE_Y_16 | TILEMAP_SIZE_Y_32
   150  e90f 2c847a                     bit TILEMAP_TMP_1
   151  e912 f015                       beq ++
   152  e914 062e                       asl MEM_LEN
   153  e916 262f                       rol MEM_LEN  + 1
   154  e918 0e807a                     asl TILEMAP_TMP_BUF_ROW
   155  e91b a908                       lda #TILEMAP_SIZE_Y_32
   156  e91d 2c847a                     bit TILEMAP_TMP_1
   157  e920 f007                       beq ++
   158  e922 062e                       asl MEM_LEN
   159  e924 262f                       rol MEM_LEN  + 1
   160  e926 0e807a                     asl TILEMAP_TMP_BUF_ROW
   161                          ++
   162                                  ; MEM_DST and MEM_LEN are set. clear the buffer.
   163  e929 a900                       lda #$00
   164  e92b 200de1                     jsr memsetMultiPage
   165                          
   166  e92e ad817a                     lda TILEMAP_TMP_BUF_COL
   167  e931 a005                       ldy #TILEMAP_WIDTH_TILES
   168  e933 9118                       sta (TILEMAP_ADDR), y
   169                          
   170  e935 ad807a                     lda TILEMAP_TMP_BUF_ROW
   171  e938 a006                       ldy #TILEMAP_HEIGHT_TILES
   172  e93a 9118                       sta (TILEMAP_ADDR), y
   173                          
   174                                  ; todo: invert & dirty
   175                          
   176  e93c 2040e9                     jsr tilemapSetActive
   177                          
   178  e93f 60                         rts
   179                          
   180                          ; -----------------------------------------------------------------------------
   181                          ; tilemapSetActive: Set the current/active tilemap
   182                          ; -----------------------------------------------------------------------------
   183                          ; Inputs:
   184                          ;  TILEMAP_ADDR: Address of tilemap structure
   185                          ; -----------------------------------------------------------------------------
   186                          tilemapSetActive:
   187  e940 a005                       ldy #TILEMAP_WIDTH_TILES
   188  e942 b118                       lda (TILEMAP_ADDR), y
   189  e944 8d867a                     sta TILEMAP_TMP_TILES_W
   190                          
   191  e947 a006                       ldy #TILEMAP_HEIGHT_TILES
   192  e949 b118                       lda (TILEMAP_ADDR), y
   193  e94b 8d877a                     sta TILEMAP_TMP_TILES_H
   194                          
   195  e94e a007                       ldy #TILEMAP_TILE_SIZE_PX
   196  e950 b118                       lda (TILEMAP_ADDR), y
   197  e952 8d887a                     sta TILEMAP_TMP_TILE_SIZE
   198  e955 60                         rts
   199                          
   200                          
   201                          !if LCD_GRAPHICS=1 {
   202                          
   203                          ; -----------------------------------------------------------------------------
   204                          ; tilemapRenderRowToLcd: Render a row of the current/active tilemap
   205                          ; -----------------------------------------------------------------------------
   206                          ; Prerequisites:
   207                          ;  tilemapSetActive called for the tilemap
   208                          ; Inputs:
   209                          ;  y: Row to render (0-7)
   210                          ; -----------------------------------------------------------------------------
   211                          tilemapRenderRowToLcd:
   212  e956 98                         tya
   213  e957 2907                       and #$07
   214  e959 8d807a                     sta TILEMAP_TMP_BUF_ROW
   215  e95c 8d857a                     sta TILEMAP_TMP_2
   216  e95f 0a                         asl
   217  e960 0a                         asl
   218  e961 0a                         asl
   219  e962 8d837a                     sta TILEMAP_TMP_OUTPUT_ROW
   220                          
   221  e965 ee857a                     inc TILEMAP_TMP_2
   222                          
   223                                  ; set the working tilemap buffer address
   224  e968 a000                       ldy #TILEMAP_BUFFER_ADDR
   225  e96a b118                       lda (TILEMAP_ADDR), y
   226  e96c 851b                       sta TILEMAP_TMP_BUFFER_ADDR + 1
   227                          
   228                                  ; reset temp variables to zero
   229  e96e a900                       lda #0
   230  e970 851a                       sta TILEMAP_TMP_BUFFER_ADDR ; LSB
   231  e972 851c                       sta TILEMAP_TMP_TILES_ADDR  ; LSB
   232  e974 8d817a                     sta TILEMAP_TMP_BUF_COL
   233  e977 8d827a                     sta TILEMAP_TMP_TILE_ROW
   234                          
   235  e97a 4c9be9                     jmp .tilemapRenderFrom
   236                          
   237                          
   238                          ; -----------------------------------------------------------------------------
   239                          ; tilemapRenderToLcd: Render the current/active tilemap
   240                          ; -----------------------------------------------------------------------------
   241                          ; Prerequisites:
   242                          ;  tilemapSetActive called for the tilemap
   243                          ; -----------------------------------------------------------------------------
   244                          tilemapRenderToLcd:
   245                          
   246  e97d ad877a                     lda TILEMAP_TMP_TILES_H
   247  e980 8d857a                     sta TILEMAP_TMP_2
   248                          
   249                                  ; set the working tilemap buffer address
   250  e983 a000                       ldy #TILEMAP_BUFFER_ADDR
   251  e985 b118                       lda (TILEMAP_ADDR), y
   252  e987 851b                       sta TILEMAP_TMP_BUFFER_ADDR + 1
   253                                  
   254                                  ; reset temp variables to zero
   255  e989 a900                       lda #0
   256  e98b 851a                       sta TILEMAP_TMP_BUFFER_ADDR ; LSB
   257  e98d 851c                       sta TILEMAP_TMP_TILES_ADDR  ; LSB
   258  e98f 8d807a                     sta TILEMAP_TMP_BUF_ROW
   259  e992 8d817a                     sta TILEMAP_TMP_BUF_COL
   260  e995 8d827a                     sta TILEMAP_TMP_TILE_ROW
   261  e998 8d837a                     sta TILEMAP_TMP_OUTPUT_ROW
   262                          
   263                          .tilemapRenderFrom
   264  e99b ac837a                     ldy TILEMAP_TMP_OUTPUT_ROW
   265  e99e 203ce5                     jsr lcdGraphicsSetRow
   266                          
   267                                  ; iterate over the buffer rows and columns
   268                          @renderRow
   269                          ;!byte $db
   270                          
   271  e9a1 a900                       lda #0
   272  e9a3 8d847a                     sta TILEMAP_TMP_1
   273                          
   274                                  ; set the working tileset address
   275  e9a6 a002                       ldy #TILEMAP_TILES_ADDR
   276  e9a8 b118                       lda (TILEMAP_ADDR), y
   277  e9aa 851d                       sta TILEMAP_TMP_TILES_ADDR + 1
   278                          
   279                                  ; get tile offset
   280  e9ac ad807a                     lda TILEMAP_TMP_BUF_ROW
   281  e9af 0a                         asl
   282  e9b0 0a                         asl
   283  e9b1 0a                         asl
   284  e9b2 0a                         asl
   285  e9b3 18                         clc
   286  e9b4 6d817a                     adc TILEMAP_TMP_BUF_COL
   287  e9b7 a8                         tay
   288                          
   289                          
   290                                  ; load the tile index
   291  e9b8 b11a                       lda (TILEMAP_TMP_BUFFER_ADDR), y
   292                          
   293                                  ; multiply by 8 to get an offset into the tileset buffer
   294                                  ; storing overflow in TILEMAP_TMP_1
   295  e9ba 0a                         asl
   296  e9bb 2e847a                     rol TILEMAP_TMP_1
   297  e9be 0a                         asl 
   298  e9bf 2e847a                     rol TILEMAP_TMP_1
   299  e9c2 0a                         asl
   300  e9c3 2e847a                     rol TILEMAP_TMP_1
   301                          
   302                                  ; add the tile row offset (the row of the current tile)
   303                                  ; and set as y index
   304  e9c6 0d827a                     ora TILEMAP_TMP_TILE_ROW
   305  e9c9 a8                         tay
   306                          
   307                                  ; load the overflow and add to the MSB of the tileset address
   308  e9ca ad847a                     lda TILEMAP_TMP_1
   309  e9cd 18                         clc
   310  e9ce 651d                       adc TILEMAP_TMP_TILES_ADDR + 1
   311  e9d0 851d                       sta TILEMAP_TMP_TILES_ADDR + 1
   312                          
   313  e9d2 2037e6                     jsr lcdWait
   314                          
   315                                  ; load the byte from the tile
   316  e9d5 b11c                       lda (TILEMAP_TMP_TILES_ADDR), y
   317                          
   318                                  ; output the byte
   319  e9d7 8d037f                     sta LCD_DATA
   320                          
   321                                  ; increment column and check against # columns
   322  e9da ee817a                     inc TILEMAP_TMP_BUF_COL
   323  e9dd ad867a                     lda TILEMAP_TMP_TILES_W
   324  e9e0 cd817a                     cmp TILEMAP_TMP_BUF_COL
   325  e9e3 d0bc                       bne @renderRow
   326                          
   327                                  ; increment tile row (row within tile) and check against tile size
   328  e9e5 a900                       lda #0
   329  e9e7 8d817a                     sta TILEMAP_TMP_BUF_COL
   330  e9ea ee827a                     inc TILEMAP_TMP_TILE_ROW
   331  e9ed ee837a                     inc TILEMAP_TMP_OUTPUT_ROW
   332  e9f0 ac837a                     ldy TILEMAP_TMP_OUTPUT_ROW
   333                          
   334  e9f3 203ce5                     jsr lcdGraphicsSetRow
   335                          
   336  e9f6 ad887a                     lda TILEMAP_TMP_TILE_SIZE
   337  e9f9 cd827a                     cmp TILEMAP_TMP_TILE_ROW
   338  e9fc d0a3                       bne @renderRow
   339                          
   340                                  ; increment row and check against # rows
   341  e9fe a900                       lda #0
   342  ea00 8d827a                     sta TILEMAP_TMP_TILE_ROW
   343  ea03 ee807a                     inc TILEMAP_TMP_BUF_ROW
   344  ea06 ad857a                     lda TILEMAP_TMP_2
   345  ea09 cd807a                     cmp TILEMAP_TMP_BUF_ROW
   346  ea0c d093                       bne @renderRow
   347                          
   348  ea0e 60                         rts
   349                          

; ******** Source: kernel.asm
   165                          }
   166                          
   167                          !ifndef HBC56_DISABLE_UART {

; ******** Source: ../lib\ser\uart.asm
     1                          ; 6502 - MC68B50 UART
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          
    10                          HAVE_UART = 1
    11                          
    12                          ; -------------------------
    13                          ; Constants
    14                          ; -------------------------
    15                          !ifndef UART_IO_PORT { UART_IO_PORT = $20
    16                                  !warn "UART_IO_PORT not provided. Defaulting to ", UART_IO_PORT
    17                          }
    18                          
    19                          !ifndef UART_ZP_START { UART_ZP_START = $40
    20                                  !warn "UART_ZP_START not provided. Defaulting to ", UART_ZP_START
    21                          }
    22                          
    23                          !ifndef UART_RAM_START { UART_RAM_START = $7c80
    24                                  !warn "UART_RAM_START not provided. Defaulting to ", UART_RAM_START
    25                          }
    26                          
    27                          
    28                          ; -----------------------------------------------------------------------------
    29                          ; Zero page
    30                          ; -----------------------------------------------------------------------------
    31                          UART_RX_BUFFER_HEAD  = UART_ZP_START            ; head of circular buffer
    32                          UART_RX_BUFFER_TAIL  = UART_ZP_START + 1        ; tail of circular buffer
    33                          UART_RX_BUFFER_BYTES = UART_ZP_START + 2        ; bytes in buffer
    34                          UART_RX_FLAGS        = UART_ZP_START + 3        ; flags
    35                          @UART_ZP_END         = UART_ZP_START + 4
    36                          
    37                          !if (.UART_ZP_SIZE < @UART_ZP_END - UART_ZP_START) {
    38                                  !error "UART ZP allocation insufficient. Allocated: ", .UART_ZP_SIZE, " Require: ", (@UART_ZP_END - UART_ZP_START)
    39                          }
    40                          
    41                          ; -----------------------------------------------------------------------------
    42                          ; High RAM
    43                          ; -----------------------------------------------------------------------------
    44                          UART_RX_BUFFER       = UART_RAM_START
    45                          UART_RX_BUFFER_SIZE  = $100
    46                          
    47                          @UART_RAM_END        = UART_RAM_START + UART_RX_BUFFER_SIZE
    48                          
    49                          !if (.UART_RAM_SIZE < @UART_RAM_END - UART_RAM_START) {
    50                                  !error "UART RAM allocation insufficient. Allocated: ", .UART_RAM_SIZE, " Require: ", (@UART_RAM_END - UART_RAM_START)
    51                          }
    52                          
    53                          
    54                          ; IO Ports
    55                          UART_REG      = IO_PORT_BASE_ADDRESS | UART_IO_PORT
    56                          UART_DATA     = IO_PORT_BASE_ADDRESS | UART_IO_PORT | $01
    57                          
    58                          ; -----------------------------------------------------------------------------
    59                          ; Constants
    60                          ; -----------------------------------------------------------------------------
    61                          UART_CTL_MASTER_RESET       = %00000011
    62                          UART_CTL_CLOCK_DIV_16       = %00000001
    63                          UART_CTL_CLOCK_DIV_64       = %00000010
    64                          UART_CTL_WORD_7BIT_EPB_2SB  = %00000000
    65                          UART_CTL_WORD_7BIT_OPB_2SB  = %00000100
    66                          UART_CTL_WORD_7BIT_EPB_1SB  = %00001000
    67                          UART_CTL_WORD_7BIT_OPB_1SB  = %00001100
    68                          UART_CTL_WORD_8BIT_2SB      = %00010000
    69                          UART_CTL_WORD_8BIT_1SB      = %00010100
    70                          UART_CTL_WORD_8BIT_EPAR_1SB = %00011000
    71                          UART_CTL_WORD_8BIT_OPAR_1SB = %00011100
    72                          UART_CTL_RX_INT_ENABLE      = %10000000
    73                          
    74                          UART_STATUS_RX_REG_FULL     = %00000001
    75                          UART_STATUS_TX_REG_EMPTY    = %00000010
    76                          UART_STATUS_CARRIER_DETECT  = %00000100
    77                          UART_STATUS_CLEAR_TO_SEND   = %00001000
    78                          UART_STATUS_FRAMING_ERROR   = %00010000
    79                          UART_STATUS_RCVR_OVERRUN    = %00100000
    80                          UART_STATUS_PARITY_ERROR    = %01000000
    81                          UART_STATUS_IRQ             = %10000000
    82                          
    83                          UART_FLOWCTRL_XON           = $11
    84                          UART_FLOWCTRL_XOFF          = $13
    85                          
    86                          UART_RX_BUFFER_XOFF_SIZE    = 192
    87                          UART_RX_BUFFER_XON_SIZE     = 4
    88                          
    89                          
    90                          ; -----------------------------------------------------------------------------
    91                          ; uartInit: Initialise the UART
    92                          ; -----------------------------------------------------------------------------
    93                          uartInit:
    94  ea0f a900                       lda #0
    95  ea11 8526                       sta UART_RX_BUFFER_HEAD
    96  ea13 8527                       sta UART_RX_BUFFER_TAIL
    97  ea15 8528                       sta UART_RX_BUFFER_BYTES
    98  ea17 8529                       sta UART_RX_FLAGS
    99                          
   100  ea19 a903                       lda #UART_CTL_MASTER_RESET
   101  ea1b 8d207f                     sta UART_REG
   102  ea1e ea                         nop
   103  ea1f ea                         nop
   104                          
   105  ea20 a992                       lda #(UART_CTL_CLOCK_DIV_64 | UART_CTL_WORD_8BIT_2SB | UART_CTL_RX_INT_ENABLE)
   106  ea22 8d207f                     sta UART_REG
   107  ea25 ea                         nop
   108  ea26 ea                         nop
   109                          
   110  ea27 204fea                     jsr uartFlowCtrlXon
   111                          
   112  ea2a 60                         rts
   113                          
   114                          ; -----------------------------------------------------------------------------
   115                          ; uartIrq: Standard UART IRQ handler
   116                          ; -----------------------------------------------------------------------------
   117                          uartIrq:
   118  ea2b a901                       lda #UART_STATUS_RX_REG_FULL
   119  ea2d 2c207f                     bit UART_REG
   120  ea30 f01c                       beq @endFlowControlCheck
   121  ea32 ea                         nop
   122  ea33 ea                         nop
   123                          
   124  ea34 da                         phx
   125  ea35 a626                       ldx UART_RX_BUFFER_HEAD
   126  ea37 ad217f                     lda UART_DATA
   127  ea3a 9d507b                     sta UART_RX_BUFFER, x
   128  ea3d e626                       inc UART_RX_BUFFER_HEAD
   129  ea3f e628                       inc UART_RX_BUFFER_BYTES
   130  ea41 fa                         plx
   131                          
   132                          @flowControlCheck
   133                                  ; check flow control
   134  ea42 ff2909                     bbs7 UART_RX_FLAGS, @endFlowControlCheck    ; if already xoff, just leave
   135  ea45 a9c0                       lda #UART_RX_BUFFER_XOFF_SIZE               ; otherwise, should we ask for xoff?
   136  ea47 c528                       cmp UART_RX_BUFFER_BYTES
   137  ea49 b003                       bcs @endFlowControlCheck                    ; all good
   138  ea4b 205aea                     jsr uartFlowCtrlXoff                        ; stop please.
   139                          
   140                          @endFlowControlCheck
   141  ea4e 60                         rts
   142                          
   143                          ; -----------------------------------------------------------------------------
   144                          ; uartFlowCtrlXon: Allow client to send data
   145                          ; -----------------------------------------------------------------------------
   146                          uartFlowCtrlXon:
   147  ea4f 7729                       rmb7 UART_RX_FLAGS        
   148  ea51 a911                       lda #UART_FLOWCTRL_XON
   149  ea53 ea                         nop
   150  ea54 ea                         nop
   151  ea55 ea                         nop
   152  ea56 ea                         nop
   153  ea57 4c90ea                     jmp uartOut
   154                          
   155                          ; -----------------------------------------------------------------------------
   156                          ; uartFlowCtrlXoff: Stop client to sending data
   157                          ; -----------------------------------------------------------------------------
   158                          uartFlowCtrlXoff
   159  ea5a f729                       smb7 UART_RX_FLAGS
   160  ea5c a913                       lda #UART_FLOWCTRL_XOFF
   161  ea5e ea                         nop
   162  ea5f ea                         nop
   163  ea60 4c96ea                     jmp uartOutNoBsCheck
   164                          
   165                          ; -----------------------------------------------------------------------------
   166                          ; uartInWait: Input a byte from the UART (wait forever)
   167                          ; -----------------------------------------------------------------------------
   168                          ; Outputs:
   169                          ;   A: Value of the buffer
   170                          ; -----------------------------------------------------------------------------
   171                          uartInWait:
   172  ea63 a526                       lda UART_RX_BUFFER_HEAD
   173  ea65 c527                       cmp UART_RX_BUFFER_TAIL
   174  ea67 f0fa                       beq uartInWait
   175  ea69 08                         php
   176  ea6a 78                         sei
   177  ea6b 8008                       bra .uartIncheckFlowControl
   178                          
   179                          ; -----------------------------------------------------------------------------
   180                          ; uartInNoWait: Input a byte from the UART (don't wait)
   181                          ; -----------------------------------------------------------------------------
   182                          ; Outputs:
   183                          ;   A: Value of the buffer
   184                          ;   C: Set if a byte is read
   185                          ; -----------------------------------------------------------------------------
   186                          uartInNoWait:
   187  ea6d 08                         php
   188  ea6e 78                         sei
   189  ea6f a526                       lda UART_RX_BUFFER_HEAD
   190  ea71 c527                       cmp UART_RX_BUFFER_TAIL
   191  ea73 f018                       beq @noData
   192                          
   193                          .uartIncheckFlowControl
   194                                  ; check flow control
   195  ea75 7f2909                     bbr7 UART_RX_FLAGS, @readUartValue  ; if already xon, just exit again
   196  ea78 a904                       lda #UART_RX_BUFFER_XON_SIZE        ; otherwise, should we ask for xon?
   197  ea7a c528                       cmp UART_RX_BUFFER_BYTES
   198  ea7c 9003                       bcc @readUartValue                  ; all good
   199  ea7e 204fea                     jsr uartFlowCtrlXon                 ; continue sending please.
   200                          
   201                          @readUartValue
   202  ea81 a627                       ldx UART_RX_BUFFER_TAIL
   203  ea83 bd507b                     lda UART_RX_BUFFER, x
   204  ea86 e627                       inc UART_RX_BUFFER_TAIL
   205  ea88 c628                       dec UART_RX_BUFFER_BYTES
   206  ea8a 28                         plp
   207  ea8b 38                         sec
   208  ea8c 60                         rts
   209                          @noData
   210  ea8d 28                         plp
   211  ea8e 18                         clc
   212  ea8f 60                         rts
   213                          
   214                          
   215                          ; -----------------------------------------------------------------------------
   216                          ; uartOut: Output a byte to the UART
   217                          ; -----------------------------------------------------------------------------
   218                          ; Inputs:
   219                          ;   A: Value to output
   220                          ; -----------------------------------------------------------------------------
   221                          uartOut:
   222  ea90 c908                       cmp #$08        ; bs
   223  ea92 d002                       bne uartOutNoBsCheck
   224  ea94 a97f                       lda #$7f        ; del
   225                          uartOutNoBsCheck:
   226  ea96 48                         pha
   227  ea97 a902                       lda #UART_STATUS_TX_REG_EMPTY
   228                          
   229                          @aciaTestSend
   230  ea99 2c207f                     bit UART_REG
   231  ea9c ea                         nop
   232  ea9d ea                         nop
   233  ea9e d002                       bne +
   234  eaa0 80f7                       bra @aciaTestSend
   235                          
   236                          +
   237  eaa2 68                         pla
   238  eaa3 8d217f                     sta UART_DATA
   239  eaa6 60                         rts
   240                          
   241                          
   242                          ; -----------------------------------------------------------------------------
   243                          ; uartOutString: Output a string to the UART
   244                          ; -----------------------------------------------------------------------------
   245                          ; Inputs:
   246                          ;   A: Value to output
   247                          ; -----------------------------------------------------------------------------
   248                          uartOutString:
   249  eaa7 a000                       ldy #0
   250                          -
   251  eaa9 b130                       lda (STR_ADDR), y
   252  eaab f006                       beq +
   253  eaad 2096ea                     jsr uartOutNoBsCheck
   254  eab0 c8                         iny
   255  eab1 d0f6                       bne -
   256                          +
   257  eab3 60                         rts

; ******** Source: kernel.asm
   169                          }
   170                          
   171                          !ifndef HBC56_DISABLE_NES {

; ******** Source: ../lib\inp\nes.asm
     1                          ; 6502 NES Controllers - HBC-56
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          
    10                          
    11                          !ifndef NES_IO_PORT { NES_IO_PORT = $82
    12                                  !warn "NES_IO_PORT not provided. Defaulting to ", NES_IO_PORT
    13                          }
    14                          
    15                          !ifndef NES_RAM_START { NES_RAM_START = $7ea1
    16                                  !warn "NES_RAM_START not provided. Defaulting to ", NES_RAM_START
    17                          }
    18                          
    19                          ; -------------------------
    20                          ; High RAM
    21                          ; -------------------------
    22                          NES_TMP        = NES_RAM_START
    23                          NES_RAM_SIZE   = 1
    24                          
    25                          
    26                          !if NES_RAM_END < (NES_RAM_START + NES_RAM_SIZE) {
    27                                  !error "NES_RAM requires ",NES_RAM_SIZE," bytes. Allocated ",NES_RAM_END - NES_RAM_START
    28                          }
    29                          
    30                          
    31                          ; IO Ports
    32                          NES1_IO_ADDR     = IO_PORT_BASE_ADDRESS | NES_IO_PORT
    33                          NES2_IO_ADDR     = IO_PORT_BASE_ADDRESS | NES_IO_PORT | $01
    34                          
    35                          
    36                          NES_RIGHT       = %00000001
    37                          NES_LEFT        = %00000010
    38                          NES_DOWN        = %00000100
    39                          NES_UP          = %00001000
    40                          NES_START       = %00010000
    41                          NES_SELECT      = %00100000
    42                          NES_B           = %01000000
    43                          NES_A           = %10000000
    44                          
    45                          ; -----------------------------------------------------------------------------
    46                          ; nesWaitForPress: Wait for a NES button press (either port)
    47                          ; -----------------------------------------------------------------------------
    48                          nesWaitForPress:
    49  eab4 a9ff                       lda #$ff
    50                          @notPressed
    51  eab6 cd827f                     cmp NES1_IO_ADDR
    52  eab9 d005                       bne @pressed
    53  eabb cd837f                     cmp NES2_IO_ADDR
    54  eabe f0f6                       beq @notPressed
    55                          @pressed
    56  eac0 60                         rts
    57                          
    58                          ; -----------------------------------------------------------------------------
    59                          ; nes1Pressed: Is a button pressed?
    60                          ; -----------------------------------------------------------------------------
    61                          ; Inputs:
    62                          ;   A: Button to test
    63                          ; Outputs:
    64                          ;   Carry set if pressed, Carry clear if not
    65                          nes1Pressed:
    66  eac1 2c827f                     bit NES1_IO_ADDR
    67  eac4 18                         clc
    68  eac5 d001                       bne +
    69  eac7 38                         sec
    70                          +
    71  eac8 60                         rts
    72                          
    73                          ; -----------------------------------------------------------------------------
    74                          ; nes2Pressed: Is a button pressed?
    75                          ; -----------------------------------------------------------------------------
    76                          ; Inputs:
    77                          ;   A: Button to test
    78                          ; Outputs:
    79                          ;   Carry set if pressed, Carry clear if not
    80                          nes2Pressed:
    81  eac9 2c827f                     bit NES1_IO_ADDR
    82  eacc 18                         clc
    83  eacd d001                       bne +
    84  eacf 38                         sec
    85                          +
    86  ead0 60                         rts
    87                          
    88                          
    89                          
    90                          

; ******** Source: kernel.asm
   173                          }
   174                          
   175                          !ifndef HBC56_DISABLE_KEYBOARD {

; ******** Source: ../lib\inp\keyboard.asm
     1                          ; 6502 KB Controller - HBC-56
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github@com/visrealm/hbc-56
     8                          ;
     9                          
    10                          !ifndef HAVE_MATH_INC { !src "ut/math.inc" }
    11                          
    12                          HAVE_KEYBOARD = 1
    13                          
    14                          ; -------------------------
    15                          ; Constants
    16                          ; -------------------------
    17                          !ifndef KB_IO_PORT { KB_IO_PORT = $80
    18                                  !warn "KB_IO_PORT not provided@ Defaulting to ", KB_IO_PORT
    19                          }
    20                          
    21                          !ifndef KB_RAM_START { KB_RAM_START = $7ea1
    22                                  !warn "KB_RAM_START not provided@ Defaulting to ", KB_RAM_START
    23                          }
    24                          
    25                          ; -------------------------
    26                          ; High RAM
    27                          ; -------------------------
    28                          KB_FLAGS          = KB_RAM_START
    29                          KB_TMP_X          = KB_RAM_START + 1
    30                          KB_TMP_Y          = KB_RAM_START + 2
    31                          KB_CB_PRESSED     = KB_RAM_START + 3
    32                          KB_CB_RELEASED    = KB_RAM_START + 5
    33                          KB_CURRENT_STATE  = KB_RAM_START + 7
    34                          KB_BUFFER_HEAD    = KB_RAM_START + 8         ; head of circular buffer
    35                          KB_BUFFER_TAIL    = KB_RAM_START + 9         ; tail of circular buffer
    36                          KB_BUFFER         = KB_RAM_START + 10
    37                          KB_BUFFER_SIZE    = (1 << 4)
    38                          KB_BUFFER_MASK    = KB_BUFFER_SIZE - 1
    39                          KB_PRESSED_MAP    = KB_BUFFER + KB_BUFFER_SIZE
    40                          
    41                          KB_PRESSED_MAP_SIZE = $fd + 1
    42                          KB_PRESSED_MAP_BYTES = 32
    43                          
    44                          KB_RAM_SIZE     = (KB_PRESSED_MAP + KB_PRESSED_MAP_BYTES) - KB_RAM_START
    45                          
    46                          
    47                          !if KB_RAM_END < (KB_RAM_START + KB_RAM_SIZE) {
    48                                  !error "KB_RAM requires ",KB_RAM_SIZE," bytes@ Allocated ",KB_RAM_END - KB_RAM_START
    49                          }
    50                          
    51                          ; -------------------------
    52                          ; Contants
    53                          ; -------------------------
    54                          KB_SHIFT_DOWN   = %00000001
    55                          KB_CTRL_DOWN    = %00000010
    56                          KB_ALT_DOWN     = %00000100
    57                          KB_CAPS_LOCK    = %00001000
    58                          KB_NUM_LOCK     = %00010000
    59                          
    60                          KB_RELEASE      = $f0
    61                          KB_EXT_KEY      = $e0
    62                          KB_PAUSE_KEY    = $e1
    63                          
    64                          KB_SCANCODE_0 = $45
    65                          KB_SCANCODE_1 = $16
    66                          KB_SCANCODE_2 = $1E
    67                          KB_SCANCODE_3 = $26
    68                          KB_SCANCODE_4 = $25
    69                          KB_SCANCODE_5 = $2E
    70                          KB_SCANCODE_6 = $36
    71                          KB_SCANCODE_7 = $3D
    72                          KB_SCANCODE_8 = $3E
    73                          KB_SCANCODE_9 = $46
    74                          KB_SCANCODE_A = $1C
    75                          KB_SCANCODE_B = $32
    76                          KB_SCANCODE_C = $21
    77                          KB_SCANCODE_D = $23
    78                          KB_SCANCODE_E = $24
    79                          KB_SCANCODE_F = $2B
    80                          KB_SCANCODE_G = $34
    81                          KB_SCANCODE_H = $33
    82                          KB_SCANCODE_I = $43
    83                          KB_SCANCODE_J = $3B
    84                          KB_SCANCODE_K = $42
    85                          KB_SCANCODE_L = $4B
    86                          KB_SCANCODE_M = $3A
    87                          KB_SCANCODE_N = $31
    88                          KB_SCANCODE_O = $44
    89                          KB_SCANCODE_P = $4D
    90                          KB_SCANCODE_Q = $15
    91                          KB_SCANCODE_R = $2D
    92                          KB_SCANCODE_S = $1B
    93                          KB_SCANCODE_T = $2C
    94                          KB_SCANCODE_U = $3C
    95                          KB_SCANCODE_V = $2A
    96                          KB_SCANCODE_W = $1D
    97                          KB_SCANCODE_X = $22
    98                          KB_SCANCODE_Y = $35
    99                          KB_SCANCODE_Z = $1A
   100                          KB_SCANCODE_F1 = $05
   101                          KB_SCANCODE_F2 = $06
   102                          KB_SCANCODE_F3 = $04
   103                          KB_SCANCODE_F4 = $0C
   104                          KB_SCANCODE_F5 = $03
   105                          KB_SCANCODE_F6 = $0B
   106                          KB_SCANCODE_F7 = $83
   107                          KB_SCANCODE_F8 = $0A
   108                          KB_SCANCODE_F9 = $01
   109                          KB_SCANCODE_F10 = $09
   110                          KB_SCANCODE_F11 = $78
   111                          KB_SCANCODE_F12 = $07
   112                          KB_SCANCODE_NUMPAD_0 = $70
   113                          KB_SCANCODE_NUMPAD_1 = $69
   114                          KB_SCANCODE_NUMPAD_2 = $72
   115                          KB_SCANCODE_NUMPAD_3 = $7A
   116                          KB_SCANCODE_NUMPAD_4 = $6B
   117                          KB_SCANCODE_NUMPAD_5 = $73
   118                          KB_SCANCODE_NUMPAD_6 = $74
   119                          KB_SCANCODE_NUMPAD_7 = $6C
   120                          KB_SCANCODE_NUMPAD_8 = $75
   121                          KB_SCANCODE_NUMPAD_9 = $7D
   122                          KB_SCANCODE_NUMPAD_DIVIDE = $CA
   123                          KB_SCANCODE_NUMPAD_ENTER = $DA
   124                          KB_SCANCODE_NUMPAD_MINUS = $7B
   125                          KB_SCANCODE_NUMPAD_MULTIPLY = $7C
   126                          KB_SCANCODE_NUMPAD_PERIOD = $71
   127                          KB_SCANCODE_NUMPAD_PLUS = $79
   128                          KB_SCANCODE_NUM_LOCK = $77
   129                          KB_SCANCODE_ALT_LEFT = $11
   130                          KB_SCANCODE_ALT_RIGHT_ = $91
   131                          KB_SCANCODE_APOS = $52
   132                          KB_SCANCODE_ARROW_DOWN = $F2
   133                          KB_SCANCODE_ARROW_LEFT = $EB
   134                          KB_SCANCODE_ARROW_RIGHT = $F4
   135                          KB_SCANCODE_ARROW_UP = $F5
   136                          KB_SCANCODE_BACKSPACE = $66
   137                          KB_SCANCODE_CAPS_LOCK = $58
   138                          KB_SCANCODE_COMMA = $41
   139                          KB_SCANCODE_CTRL_LEFT = $14
   140                          KB_SCANCODE_CTRL_RIGHT = $94
   141                          KB_SCANCODE_DELETE = $F1
   142                          KB_SCANCODE_END = $E9
   143                          KB_SCANCODE_ENTER = $5A
   144                          KB_SCANCODE_EQUAL = $55
   145                          KB_SCANCODE_ESC = $76
   146                          KB_SCANCODE_HOME = $EC
   147                          KB_SCANCODE_INSERT = $F0
   148                          KB_SCANCODE_MENU = $AF
   149                          KB_SCANCODE_MINUS = $4E
   150                          KB_SCANCODE_PAGE_DOWN = $FA
   151                          KB_SCANCODE_PAGE_UP = $FD
   152                          KB_SCANCODE_PAUSE = $E1
   153                          KB_SCANCODE_PERIOD = $49
   154                          KB_SCANCODE_PRTSCR = $92
   155                          KB_SCANCODE_SCROLL_LOCK = $7E
   156                          KB_SCANCODE_SEMICOLON = $4C
   157                          KB_SCANCODE_SHIFT_LEFT = $12
   158                          KB_SCANCODE_SHIFT_RIGHT = $59
   159                          KB_SCANCODE_SLASH_BACK = $5D
   160                          KB_SCANCODE_SLASH_FORWARD = $4A
   161                          KB_SCANCODE_SPACEBAR = $29
   162                          KB_SCANCODE_SQUARE_LEFT = $54
   163                          KB_SCANCODE_SQUARE_RIGHT = $5B
   164                          KB_SCANCODE_TAB = $0D
   165                          KB_SCANCODE_TILDE = $0E
   166                          KB_SCANCODE_WINDOWS_LEFT = $9F
   167                          KB_SCANCODE_WINDOWS_RIGHT = $A7
   168                          
   169                          
   170                          KB_SHIFT_LEFT_MAP_BYTE = KB_SCANCODE_SHIFT_LEFT >> 3
   171                          KB_SHIFT_LEFT_MAP_BIT  = $80 >> (KB_SCANCODE_SHIFT_LEFT & $07)
   172                          
   173                          KB_SHIFT_RIGHT_MAP_BYTE = KB_SCANCODE_SHIFT_RIGHT >> 3
   174                          KB_SHIFT_RIGHT_MAP_BIT  = $80 >> (KB_SCANCODE_SHIFT_RIGHT & $07)
   175                          
   176                          
   177                          ; IO Ports
   178                          KB_IO_ADDR         = IO_PORT_BASE_ADDRESS | KB_IO_PORT
   179                          KB_STATUS_ADDR     = IO_PORT_BASE_ADDRESS | KB_IO_PORT | $01
   180                          
   181                          ; -----------------------------------------------------------------------------
   182                          ; kbInit: Initialise the keyboard
   183                          ; -----------------------------------------------------------------------------
   184                          kbInit:
   185  ead1 a900                       lda #$00
   186  ead3 8d537c                     sta KB_FLAGS
   187                          
   188  ead6 a210                       ldx #16 ;buffer size
   189                                  
   190                                  ; ensure the hardware keyboard buffer is clear
   191                          -
   192  ead8 8e547c                     stx KB_TMP_X
   193  eadb 208ceb                     jsr .kbReadByte
   194  eade ae547c                     ldx KB_TMP_X
   195  eae1 ca                         dex
   196  eae2 d0f4                       bne -
   197                          
   198  eae4 a220a900ca9d6d7c...        +memset KB_PRESSED_MAP, 0, KB_PRESSED_MAP_BYTES
   199                          
   200  eaf0 9c5b7c                     stz KB_BUFFER_HEAD
   201  eaf3 9c5c7c                     stz KB_BUFFER_TAIL
   202                          
   203  eaf6 a900                       lda #.KB_STATE_DEFAULT
   204  eaf8 8d5a7c                     sta KB_CURRENT_STATE
   205                          
   206                                  ; flow through
   207                          
   208                          kbResetCallbacks:
   209  eafb a90b                       lda #<.kbDummyCb
   210  eafd 8d567c                     sta KB_CB_PRESSED
   211  eb00 8d587c                     sta KB_CB_RELEASED
   212                                  
   213  eb03 a9eb                       lda #>.kbDummyCb
   214  eb05 8d577c                     sta KB_CB_PRESSED + 1
   215  eb08 8d597c                     sta KB_CB_RELEASED + 1
   216                          
   217                                  ; flow through
   218                          
   219                          .kbDummyCb:
   220  eb0b 60                         rts
   221                          
   222                          ; -----------------------------------------------------------------------------
   223                          ; kbIntHandler: Standard keyboard interrupt handler
   224                          ; -----------------------------------------------------------------------------
   225                          kbIntHandler:
   226  eb0c 208ceb                     jsr .kbReadByte
   227  eb0f e000                       cpx #0
   228  eb11 f0f8                       beq .kbDummyCb
   229                          
   230  eb13 8a                         txa     ; acc now holds scancode
   231                          
   232  eb14 ae5a7c                     ldx KB_CURRENT_STATE
   233                          
   234  eb17 7c1aeb                     jmp (.kbStateHandlers, x)
   235                          
   236                          .KB_STATE_DEFAULT          = 0
   237                          .KB_STATE_RELEASE          = 2
   238                          .KB_STATE_EXTENDED         = 4
   239                          .KB_STATE_EXTENDED_RELEASE = 6
   240                          .KB_STATE_PAUSE_SEQ        = 8
   241                          
   242                          .kbStateHandlers:
   243  eb1a 24eb4aeb57eb48eb...!word .stdKeyHandler, .relKeyHandler, .extKeyHandler, .extRelKeyHandler, .pauseKeyHandler
   244                          
   245                          ; default scancode handler
   246                          .stdKeyHandler
   247  eb24 c9f0                       cmp #KB_RELEASE
   248  eb26 d006                       bne +
   249  eb28 a902                       lda #.KB_STATE_RELEASE
   250  eb2a 8d5a7c                     sta KB_CURRENT_STATE
   251  eb2d 60                         rts
   252                          +
   253  eb2e c9e0                       cmp #KB_EXT_KEY
   254  eb30 d006                       bne +
   255  eb32 a904                       lda #.KB_STATE_EXTENDED
   256  eb34 8d5a7c                     sta KB_CURRENT_STATE
   257  eb37 60                         rts
   258                          +
   259  eb38 c9e1                       cmp #KB_PAUSE_KEY
   260  eb3a d006                       bne +
   261  eb3c a908                       lda #.KB_STATE_PAUSE_SEQ
   262  eb3e 8d5a7c                     sta KB_CURRENT_STATE
   263  eb41 60                         rts
   264                          +
   265                                  ; a regular key was pressed 
   266                                  ; TODO: bit field rather than a byte per key?
   267  eb42 209eeb                     jsr .kbSetKey
   268                          
   269  eb45 6c567c                     jmp (KB_CB_PRESSED)
   270                                  ; subroutine returns above
   271                          
   272                          ; extended release scancode handler
   273                          .extRelKeyHandler:
   274  eb48 0980                       ora #$80
   275                                  ; flow through
   276                          
   277                          ;  release scancode handler
   278                          .relKeyHandler:
   279  eb4a aa                         tax
   280  eb4b 20d3eb                     jsr .kbClearKey
   281                          
   282  eb4e a900                       lda #.KB_STATE_DEFAULT
   283  eb50 8d5a7c                     sta KB_CURRENT_STATE
   284  eb53 8a                         txa
   285                          
   286  eb54 6c587c                     jmp (KB_CB_RELEASED)
   287                          
   288                          ; extended scancode handler
   289                          .extKeyHandler:
   290  eb57 c9f0                       cmp #KB_RELEASE
   291  eb59 d006                       bne +
   292  eb5b a906                       lda #.KB_STATE_EXTENDED_RELEASE
   293  eb5d 8d5a7c                     sta KB_CURRENT_STATE
   294  eb60 60                         rts
   295                          +
   296  eb61 0980                       ora #$80
   297                                  
   298  eb63 209eeb                     jsr .kbSetKey
   299                          
   300  eb66 a900                       lda #.KB_STATE_DEFAULT
   301  eb68 8d5a7c                     sta KB_CURRENT_STATE
   302  eb6b 8a                         txa
   303                          
   304  eb6c 6c567c                     jmp (KB_CB_PRESSED)
   305                          
   306                          ; pause/break sequence scancode handler
   307                          .pauseKeyHandler:
   308  eb6f c977                       cmp #$77
   309  eb71 d018                       bne @notLastByte
   310  eb73 aa                         tax
   311  eb74 ad4e7d                     lda KB_PRESSED_MAP + KB_SCANCODE_PAUSE
   312  eb77 d006                       bne +
   313  eb79 8e4e7d                     stx KB_PRESSED_MAP + KB_SCANCODE_PAUSE
   314  eb7c 6c567c                     jmp (KB_CB_PRESSED)
   315                          +
   316  eb7f 9c4e7d                     stz KB_PRESSED_MAP + KB_SCANCODE_PAUSE
   317                          
   318  eb82 a900                       lda #.KB_STATE_DEFAULT
   319  eb84 8d5a7c                     sta KB_CURRENT_STATE
   320  eb87 8a                         txa
   321                          
   322  eb88 6c587c                     jmp (KB_CB_RELEASED)
   323                          
   324                          @notLastByte
   325  eb8b 60                         rts
   326                          
   327                          ; -----------------------------------------------------------------------------
   328                          ; Outputs:
   329                          ;   A: Value of the KB Status (0 if no key)
   330                          ;   X: PS/2 Scancode byte
   331                          ; -----------------------------------------------------------------------------
   332                          .kbReadByte:        
   333  eb8c a200                       ldx #0
   334  eb8e a904                       lda #$04
   335  eb90 2c817f                     bit KB_STATUS_ADDR
   336  eb93 f008                       beq @end
   337                          
   338  eb95 a020                       ldy #32         ; TODO: this could probably be smaller
   339                          -
   340  eb97 88                         dey
   341  eb98 d0fd                       bne -
   342                          
   343  eb9a ae807f                     ldx KB_IO_ADDR
   344                          @end
   345  eb9d 60                         rts
   346                          
   347                          
   348                          ; -----------------------------------------------------------------------------
   349                          ; .kbSetKey: Set a key is pressed in KB_PRESSED_MAP
   350                          ; Inputs:
   351                          ;    A - scancode
   352                          ; -----------------------------------------------------------------------------
   353                          .kbSetKey:
   354  eb9e ae5b7c                     ldx KB_BUFFER_HEAD      ; store at head of buffer
   355  eba1 9d5d7c                     sta KB_BUFFER, x
   356                          
   357  eba4 8d547c                     sta KB_TMP_X            ; find byte in map
   358  eba7 4a4a4a                     +lsr3
   359  ebaa aa                         tax
   360  ebab ad547c                     lda KB_TMP_X
   361  ebae 2907                       and #$07
   362  ebb0 a8                         tay
   363  ebb1 bd6d7c                     lda KB_PRESSED_MAP, x
   364  ebb4 1930e1                     ora tableBitFromLeft, y ; set bit in map byte
   365  ebb7 9d6d7c                     sta KB_PRESSED_MAP, x   ; update map
   366                          
   367                                  ; check for toggle keys
   368  ebba ae547c                     ldx KB_TMP_X
   369  ebbd e058                       cpx #KB_SCANCODE_CAPS_LOCK
   370  ebbf d008                       bne +
   371  ebc1 a908                       lda #KB_CAPS_LOCK
   372  ebc3 4d537c                     eor KB_FLAGS
   373  ebc6 8d537c                     sta KB_FLAGS
   374                          +
   375                          
   376  ebc9 ad5b7c                     lda KB_BUFFER_HEAD      ; increment (and mask) buffer head
   377  ebcc 1a                         inc
   378  ebcd 290f                       and #KB_BUFFER_MASK
   379  ebcf 8d5b7c                     sta KB_BUFFER_HEAD
   380  ebd2 60                         rts
   381                          
   382                          ; -----------------------------------------------------------------------------
   383                          ; .kbClearKey: Clear a key is pressed in KB_PRESSED_MAP
   384                          ; Inputs:
   385                          ;    A - scancode
   386                          ; -----------------------------------------------------------------------------
   387                          .kbClearKey:
   388  ebd3 8d547c                     sta KB_TMP_X
   389  ebd6 4a4a4a                     +lsr3
   390  ebd9 aa                         tax
   391  ebda ad547c                     lda KB_TMP_X
   392  ebdd 2907                       and #$07
   393  ebdf a8                         tay
   394  ebe0 bd6d7c                     lda KB_PRESSED_MAP, x
   395  ebe3 3938e1                     and tableInvBitFromLeft, y
   396  ebe6 9d6d7c                     sta KB_PRESSED_MAP, x
   397  ebe9 60                         rts
   398                          
   399                          
   400                          .kbPopTail:
   401  ebea ad5c7c                     lda KB_BUFFER_TAIL
   402  ebed aa                         tax
   403  ebee 1a                         inc
   404  ebef 290f                       and #KB_BUFFER_MASK
   405  ebf1 8d5c7c                     sta KB_BUFFER_TAIL
   406  ebf4 bd5d7c                     lda KB_BUFFER, x
   407  ebf7 60                         rts
   408                          
   409                          ; -----------------------------------------------------------------------------
   410                          ; kbIsPressed: Is a key pressed right now?
   411                          ; Inputs:
   412                          ;    X - scancode
   413                          ; Returns:
   414                          ;    Z - clear if pressed, set if not pressed
   415                          ; -----------------------------------------------------------------------------
   416                          kbIsPressed:
   417  ebf8 8e547c                     stx KB_TMP_X
   418  ebfb 8a                         txa
   419  ebfc 4a4a4a                     +lsr3
   420  ebff aa                         tax
   421  ec00 ad547c                     lda KB_TMP_X
   422  ec03 2907                       and #$07
   423  ec05 a8                         tay
   424  ec06 b930e1                     lda tableBitFromLeft, y
   425  ec09 3d6d7c                     and KB_PRESSED_MAP, x
   426  ec0c ae547c                     ldx KB_TMP_X
   427  ec0f c900                       cmp #0
   428  ec11 60                         rts
   429                          
   430                          
   431                          ; -----------------------------------------------------------------------------
   432                          ; kbWaitForScancode: Wait for a key press
   433                          ; Returns:
   434                          ;    A - scancode
   435                          ; -----------------------------------------------------------------------------
   436                          kbWaitForScancode:
   437  ec12 ad5b7c                     lda KB_BUFFER_HEAD
   438  ec15 cd5c7c                     cmp KB_BUFFER_TAIL
   439  ec18 f0f8                       beq kbWaitForScancode
   440  ec1a 20eaeb                     jsr .kbPopTail
   441  ec1d 60                         rts
   442                          
   443                          ; -----------------------------------------------------------------------------
   444                          ; kbNextScancode: Return the next scancode in the buffer or zero if empty
   445                          ; Returns:
   446                          ;    A - scancode (or zero)
   447                          ; -----------------------------------------------------------------------------
   448                          kbNextScancode:
   449  ec1e ad5b7c                     lda KB_BUFFER_HEAD
   450  ec21 cd5c7c                     cmp KB_BUFFER_TAIL
   451  ec24 f004                       beq @noScancode
   452  ec26 20eaeb                     jsr .kbPopTail
   453                                  ;!byte $db
   454  ec29 60                         rts
   455                          
   456                          @noScancode
   457  ec2a a900                       lda #0
   458  ec2c 60                         rts
   459                          
   460                          ; -----------------------------------------------------------------------------
   461                          ; kbScancodeToAscii: Convert a scancode to ascii. shift/caps lock is honoured
   462                          ; Inputs:
   463                          ;    A - scancode (or zero)
   464                          ; Returns:
   465                          ;    A - ascii character
   466                          ; -----------------------------------------------------------------------------
   467                          kbScancodeToAscii:
   468  ec2d da                         phx
   469  ec2e 8d547c                     sta KB_TMP_X
   470  ec31 18                         clc
   471  ec32 1002                       bpl +
   472  ec34 fa                         plx        
   473  ec35 60                         rts
   474                          +
   475  ec36 a202                       ldx #KB_SHIFT_LEFT_MAP_BYTE
   476  ec38 a920                       lda #KB_SHIFT_LEFT_MAP_BIT
   477  ec3a 3c6d7c                     bit KB_PRESSED_MAP, x
   478  ec3d f003                       beq +
   479  ec3f 38                         sec
   480  ec40 800a                       bra @doneShiftCheck
   481                          +
   482                          
   483  ec42 a20b                       ldx #KB_SHIFT_RIGHT_MAP_BYTE
   484  ec44 a940                       lda #KB_SHIFT_RIGHT_MAP_BIT
   485  ec46 3c6d7c                     bit KB_PRESSED_MAP, x
   486  ec49 f001                       beq +
   487  ec4b 38                         sec
   488                          +
   489                          
   490                          @doneShiftCheck:
   491  ec4c b008                       bcs @shiftedKeys:
   492  ec4e ae547c                     ldx KB_TMP_X
   493  ec51 bd8aec                     lda KEY_MAP, x
   494  ec54 8006                       bra @end
   495                          
   496                          @shiftedKeys:
   497  ec56 ae547c                     ldx KB_TMP_X
   498  ec59 bd0aed                     lda KEY_MAP_SHIFTED, x
   499                          
   500                          @end
   501  ec5c 2018e0                     jsr isAlpha
   502  ec5f 9014                       bcc @afterAlphaCheck
   503  ec61 8d547c                     sta KB_TMP_X
   504  ec64 a908                       lda #KB_CAPS_LOCK
   505  ec66 2d537c                     and KB_FLAGS
   506  ec69 f007                       beq +
   507  ec6b ad547c                     lda KB_TMP_X
   508  ec6e 4920                       eor #$20
   509  ec70 8003                       bra @afterAlphaCheck
   510                          +
   511  ec72 ad547c                     lda KB_TMP_X
   512                          @afterAlphaCheck
   513  ec75 fa                         plx
   514  ec76 c9ff                       cmp #$ff
   515  ec78 38                         sec
   516  ec79 d001                       bne +
   517  ec7b 18                         clc
   518                          +        
   519  ec7c 60                         rts
   520                          
   521                          kbReadAscii:
   522  ec7d da                         phx
   523  ec7e 201eec                     jsr kbNextScancode
   524  ec81 f004                       beq @noKey
   525  ec83 fa                         plx
   526  ec84 4c2dec                     jmp kbScancodeToAscii
   527                          @noKey
   528  ec87 fa                         plx
   529  ec88 18                         clc
   530  ec89 60                         rts
   531                          
   532                          
   533                          KEY_MAP:
   534                          ;      0   1   2   3   4   5   6   7   8   9   a   b   c   d   e   f
   535  ec8a ffffffffffffffff...!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$09,$60,$ff; 0
   536  ec9a ffffffffff7131ff...!byte $ff,$ff,$ff,$ff,$ff,$71,$31,$ff,$ff,$ff,$7a,$73,$61,$77,$32,$ff; 1
   537  ecaa ff637864653433ff...!byte $ff,$63,$78,$64,$65,$34,$33,$ff,$ff,$20,$76,$66,$74,$72,$35,$ff; 2
   538  ecba ff6e6268677936ff...!byte $ff,$6e,$62,$68,$67,$79,$36,$ff,$ff,$ff,$6d,$6a,$75,$37,$38,$ff; 3
   539  ecca ff2c6b696f3039ff...!byte $ff,$2c,$6b,$69,$6f,$30,$39,$ff,$ff,$2e,$2f,$6c,$3b,$70,$2d,$ff; 4
   540  ecda ffff27ff5b3dffff...!byte $ff,$ff,$27,$ff,$5b,$3d,$ff,$ff,$ff,$ff,$0d,$5d,$ff,$5c,$ff,$ff; 5
   541  ecea ffffffffffff08ff...!byte $ff,$ff,$ff,$ff,$ff,$ff,$08,$ff,$ff,$31,$ff,$34,$37,$ff,$ff,$ff; 6
   542  ecfa 30ff323536381bff...!byte $30,$ff,$32,$35,$36,$38,$1b,$ff,$ff,$ff,$33,$2d,$ff,$39,$ff,$ff; 7
   543                          
   544                          KEY_MAP_SHIFTED:
   545                          ;      0   1   2   3   4   5   6   7   8   9   a   b   c   d   e   f
   546  ed0a ffffffffffffffff...!byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$09,$7e,$ff; 0
   547  ed1a ffffffffff5121ff...!byte $ff,$ff,$ff,$ff,$ff,$51,$21,$ff,$ff,$ff,$5a,$53,$41,$57,$40,$ff; 1
   548  ed2a ff435844452423ff...!byte $ff,$43,$58,$44,$45,$24,$23,$ff,$ff,$20,$56,$46,$54,$52,$25,$ff; 2
   549  ed3a ff4e424847595eff...!byte $ff,$4e,$42,$48,$47,$59,$5e,$ff,$ff,$ff,$4d,$4a,$55,$26,$2a,$ff; 3
   550  ed4a ff3c4b494f2928ff...!byte $ff,$3c,$4b,$49,$4f,$29,$28,$ff,$ff,$3e,$3f,$4c,$3a,$50,$5f,$ff; 4
   551  ed5a ffff22ff7b2bffff...!byte $ff,$ff,$22,$ff,$7b,$2b,$ff,$ff,$ff,$ff,$0d,$7d,$ff,$7c,$ff,$ff; 5
   552  ed6a ffffffffffff08ff...!byte $ff,$ff,$ff,$ff,$ff,$ff,$08,$ff,$ff,$31,$ff,$34,$37,$ff,$ff,$ff; 6
   553  ed7a 30ff323536381bff...!byte $30,$ff,$32,$35,$36,$38,$1b,$ff,$ff,$ff,$33,$2d,$ff,$39,$ff,$ff; 7

; ******** Source: kernel.asm
   177                          }
   178                          
   179  ed8a 6769746875622e63...+hbc56Title "github.com/visrealm/hbc-56"
   180                          

; ******** Source: bootscreen.asm
     1                          ; 6502 - HBC-56 - Memory tests
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          ;
    10                          
    11                          ; can be anywhere. we own the place at this stage
    12                          LOGO_BUFFER = $3000     
    13                          
    14                          !ifdef HAVE_TMS9918 {
    15                                  HBC56_BORDER     = TMS_DK_BLUE 
    16                                  HBC56_BACKGROUND = TMS_WHITE
    17                                  HBC56_LOGO       = TMS_DK_BLUE 
    18                                  HBC56_TEXT       = TMS_DK_BLUE
    19                          }
    20                          
    21                          !ifdef HBC56_TITLE_TEXT {
    22                                  HBC56_TITLE     = HBC56_TITLE_TEXT
    23                                  HBC56_TITLE_LEN = HBC56_TITLE_TEXT_LEN
    24                          }
    25                          
    26                          .HBC56_PRESS_ANY_KEY_TEXT:
    27  eda5 505245535320414e...        !text "PRESS ANY KEY...",0
    28                          .HBC56_PRESS_ANY_KEY_TEXT_LEN = *-.HBC56_PRESS_ANY_KEY_TEXT-1
    29                          
    30                          .HBC56_PRESS_ANY_NES_TEXT:
    31  edb6 5052455353204120...        !text "PRESS A TO BEGIN...",0
    32                          .HBC56_PRESS_ANY_NES_TEXT_LEN = *-.HBC56_PRESS_ANY_NES_TEXT-1
    33                          
    34                          !ifdef HAVE_GRAPHICS_LCD {
    35  edca eaeaeaeaeaeaeaea...        !align 255, 0
    36                          hbc56FontLcd:
    37  ee00 0000000000000000...        !bin "lcd/fonts/c64-alnum.bin"
    38                          hbc56LogoLcd:
    39  f000 07c01f03ffe003ff...        !bin "res/hbc56lcd.bin"
    40                          }
    41                          
    42                          !ifdef HAVE_TMS9918 {
    43                          hbc56LogoInd:
    44                                  !bin "res/hbc56boot.ind"
    45                          hbc56LogoPatt:
    46                                  !bin "res/hbc56boot.patt"
    47                          hbc56LogoPattEnd:        
    48                          }
    49                          
    50                          hbc56BootScreen:
    51                          
    52                          !ifdef HAVE_TMS9918 {
    53                                  +tmsSetAddrColorTable 16
    54                                  +tmsColorFgBg HBC56_LOGO, HBC56_BACKGROUND
    55                                  ldx #2
    56                                  jsr _tmsSendX8
    57                                  +tmsColorFgBg HBC56_TEXT, HBC56_BACKGROUND
    58                                  ldx #16
    59                                  jsr tmsInitColorTable
    60                          
    61                                  +tmsSetPosWrite 5,5
    62                                  +tmsSendData hbc56LogoInd, 22
    63                                  +tmsSetPosWrite 5,6
    64                                  +tmsSendData hbc56LogoInd + 22, 22
    65                                  +tmsSetPosWrite 5,7
    66                                  +tmsSendData hbc56LogoInd + 44, 22
    67                          
    68                                  +tmsSetAddrPattTable 200
    69                                  +tmsSendData hbc56LogoPatt, $178
    70                          
    71                                  +tmsPrintZ HBC56_META_TITLE, 8, 14
    72                          
    73                          
    74                                  !ifdef HBC56_TITLE_TEXT {
    75                                          +tmsPrintZ HBC56_TITLE, (32 - HBC56_TITLE_LEN) / 2, 22
    76                                  }
    77                          
    78                                  +tmsColorFgBg TMS_GREY, HBC56_BORDER
    79                                  jsr tmsSetBackground
    80                          }
    81                          
    82                          !ifdef HAVE_LCD {
    83  f100 202fe6                     jsr lcdDetect
    84  f103 907f                       bcc @noLcd
    85                                  !ifdef HAVE_GRAPHICS_LCD {
    86  f105 201ae5                             jsr lcdGraphicsMode
    87  f108 a900852aa930852b...                +memset LOGO_BUFFER, $00, 1024
    88  f11d a200bd00f09d8030...                +memcpy LOGO_BUFFER + 128, hbc56LogoLcd, 256
    89  f12a a930                               lda #>LOGO_BUFFER
    90  f12c 8520                               sta BITMAP_ADDR_H
    91  f12e 2057e5                             jsr lcdImage
    92                          
    93  f131 a280a900ca9d0030...                +memset LOGO_BUFFER, $0, 128
    94  f13d a9008518a97b8519...                +tilemapCreateDefault (TILEMAP_SIZE_X_16 | TILEMAP_SIZE_Y_8), hbc56FontLcd-(32*8)
    95  f166 a280a920ca9d007a...                +memset TILEMAP_DEFAULT_BUFFER_ADDRESS, ' ', 128
    96                          
    97  f172 a200bd9d7c9d407a...                +memcpy TILEMAP_DEFAULT_BUFFER_ADDRESS + 16*4, HBC56_META_TITLE, 16
    98                          
    99  f17f a004                               ldy #4
   100  f181 2056e9                             jsr tilemapRenderRowToLcd
   101                          
   102                                  } else {
   103                                          !if LCD_ROWS > 2 { +lcdPrint "\n" }
   104                                          !if LCD_COLUMNS > 16 { +lcdPrint "  " }
   105                                          +lcdPrint "     HBC-56\n"
   106                                          !if LCD_COLUMNS > 16 { +lcdPrint "  " }
   107                                          lda #<HBC56_META_TITLE
   108                                          sta STR_ADDR_L
   109                                          lda #>HBC56_META_TITLE
   110                                          sta STR_ADDR_H
   111                                          !if LCD_ROWS = 2 {
   112                                                  jsr lcdLineTwo
   113                                          }                
   114                                          jsr lcdPrint
   115                                          !if LCD_ROWS = 2 {
   116                                                  jsr lcdLineTwo
   117                                          } else {
   118                                                  jsr lcdLineThree
   119                                          }                
   120                                          !if LCD_COLUMNS > 16 { +lcdConsolePrint "  " }
   121                                  }
   122                          @noLcd:
   123                          }
   124  f184 60                         rts

; ******** Source: kernel.asm

; ******** Source: kernel.inc
     1                          ; 6502 - HBC-56 Kernel Macros
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          ;
    10                          
    11                          !macro setIntHandler .address {
    12                                  lda #<.address
    13                                  sta HBC56_INT_VECTOR + 1
    14                                  lda #>.address
    15                                  sta HBC56_INT_VECTOR + 2
    16                                  lda #JMP_OPCODE
    17                                  sta HBC56_INT_VECTOR
    18                          }
    19                          
    20                          !macro setNmiHandler .address {
    21                                  lda #<.address
    22                                  sta HBC56_NMI_VECTOR + 1
    23                                  lda #>.address
    24                                  sta HBC56_NMI_VECTOR + 2
    25                                  lda #JMP_OPCODE
    26                                  sta HBC56_NMI_VECTOR
    27                          }
    28                          
    29                          !macro setHbcMetaNES {
    30                                  lda #HBC56_CONSOLE_FLAG_NES
    31                                  ora HBC56_CONSOLE_FLAGS
    32                                  sta HBC56_CONSOLE_FLAGS
    33                          }
    34                          
    35                          !macro setHbcMetaNoWait {
    36                                  lda #HBC56_CONSOLE_FLAG_NOWAIT
    37                                  ora HBC56_CONSOLE_FLAGS
    38                                  sta HBC56_CONSOLE_FLAGS
    39                          }
    40                          
    41                          
    42                          !macro hbc56SetVsyncCallback .vsync {
    43                                  lda #<.vsync
    44                                  sta HBC56_VSYNC_CALLBACK
    45                                  lda #>.vsync
    46                                  sta HBC56_VSYNC_CALLBACK + 1
    47                          }
    48                          
    49                          !macro setHbcMetaTitle .titleStr {
    50                                  jmp .hbcMetaTitleOut
    51                          .titleStrLabel:
    52                                  !text .titleStr
    53                          .titleStrLabelLen = * - .titleStrLabel
    54                                  !byte 0 ; nul terminator for game name
    55                          
    56                          !if .titleStrLabelLen > HBC56_META_TITLE_MAX_LEN {
    57                                  !error "setHbcMetaTitle: Title metadata limited to ",HBC56_META_TITLE_MAX_LEN,"bytes"
    58                          }
    59                          .hbcMetaTitleOut:
    60                                  +memcpy HBC56_META_TITLE + (HBC56_META_TITLE_MAX_LEN-.titleStrLabelLen)/2, .titleStrLabel, .titleStrLabelLen
    61                                  lda #.titleStrLabelLen
    62                                  sta HBC56_META_TITLE_LEN
    63                          }
    64                          
    65                          !macro consoleEnableCursor {
    66                                  lda HBC56_CONSOLE_FLAGS
    67                                  ora #HBC56_CONSOLE_FLAG_CURSOR
    68                                  sta HBC56_CONSOLE_FLAGS
    69                          }
    70                          
    71                          !macro consoleDisableCursor {
    72                                  lda HBC56_CONSOLE_FLAGS
    73                                  and #!HBC56_CONSOLE_FLAG_CURSOR & $ff
    74                                  sta HBC56_CONSOLE_FLAGS
    75                          }
    76                          
    77                          !macro consoleLCDMode {
    78                                  lda HBC56_CONSOLE_FLAGS
    79                                  ora #HBC56_CONSOLE_FLAG_LCD
    80                                  sta HBC56_CONSOLE_FLAGS
    81                          }
    82                          
    83                          !macro setBreakpoint {
    84                                 !byte $db 
    85                          }
    86                          
    87                          !macro hbc56CustomDelay .delay {
    88                                  ldy #.delay
    89                                  jsr hbc56CustomDelay
    90                          }
    91                          
    92                          !macro hbc56DelayUs .us {
    93                          !if .us = 1 {
    94                                  nop
    95                                  nop
    96                          }
    97                          }
    98                          !macro hbc56DelayMs .ms {
    99                                  lda #<.ms
   100                                  sta DELAY_L
   101                                  lda #>.ms
   102                                  sta DELAY_H
   103                          
   104                                  jsr hbc56CustomDelayMs

; ******** Source: kernel.asm

; ******** Source: interrupts.asm
     1                          ; 6502 - HBC-56 Kernel Interrupt Handling
     2                          ;
     3                          ; Copyright (c) 2021 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/hbc-56
     8                          ;
     9                          ;
    10                          
    11                          ; -------------------------
    12                          ; Interrupts
    13                          ; -------------------------
    14                          TMS9918_IRQ            = 1      ; /INT
    15                          KB_IRQ                 = 2      ; RES1
    16                          UART_IRQ               = 3      ; RES2
    17                          VIA_IRQ                = 5      ; Onboard
    18                          
    19                          TMS9918_IRQ_BIT = (1 << (TMS9918_IRQ - 1))
    20                          KB_IRQ_BIT      = (1 << (KB_IRQ - 1))
    21                          UART_IRQ_BIT    = (1 << (UART_IRQ - 1))
    22                          
    23                          INT_CTRL_ADDRESS    = IO_PORT_BASE_ADDRESS | INT_IO_PORT
    24                          
    25                          ; -----------------------------------------------------------------------------
    26                          ; HBC-56 Interrupt handler
    27                          ; -----------------------------------------------------------------------------
    28                          hbc56IntHandler:
    29  f185 48                         pha
    30  f186 da                         phx
    31  f187 5a                         phy
    32                          
    33  f188 addf7f                     lda INT_CTRL_ADDRESS
    34                          
    35                          !ifdef HAVE_UART {
    36  f18b 8904                       bit #UART_IRQ_BIT
    37  f18d f005                       beq +
    38  f18f 202bea                     jsr uartIrq        
    39  f192 8009                       bra @endIntHandler
    40                          +
    41                          }
    42                          
    43                          !ifdef HAVE_TMS9918 {
    44                                  bit #TMS9918_IRQ_BIT
    45                                  beq +
    46                                  jsr hbc56Tms9918Int
    47                                  +tmsReadStatus
    48                                  bra @endIntHandler
    49                          +
    50                          }
    51                          
    52                          !ifdef HAVE_KEYBOARD {
    53  f194 8902                       bit #KB_IRQ_BIT
    54  f196 f005                       beq +
    55  f198 200ceb                     jsr kbIntHandler
    56  f19b 8000                       bra @endIntHandler
    57                          +
    58                          }
    59                                  
    60                          @endIntHandler:
    61  f19d 7a                         ply
    62  f19e fa                         plx
    63  f19f 68                         pla      
    64  f1a0 40                         rti
    65                          
    66                          
    67                          
    68                          ; -----------------------------------------------------------------------------
    69                          ; HBC-56 TMS9918 VSYNC Interrupt handler
    70                          ; -----------------------------------------------------------------------------
    71                          !ifdef HAVE_TMS9918 {
    72                          hbc56Tms9918Int:
    73                          
    74                                  ; update ticks and seconds
    75                                  inc HBC56_TICKS
    76                                  lda HBC56_TICKS
    77                                  cmp #TMS_FPS
    78                                  bne +
    79                                  lda #0
    80                                  sta HBC56_TICKS
    81                                  +inc16 HBC56_SECONDS_L
    82                          +
    83                                  ; "tick" for sfx manager
    84                                  !ifdef HAVE_SFX_MAN {
    85                                          jsr sfxManTick
    86                                  }
    87                          
    88                                  ; handle console if enabled
    89                                  bit HBC56_CONSOLE_FLAGS
    90                                  bpl +
    91                                  jsr .consoleVsyncCallback
    92                          +
    93                          
    94                                  ; rely on callback rts to return
    95                                  jmp (HBC56_VSYNC_CALLBACK)
    96                          
    97                          
    98                          ; -----------------------------------------------------------------------------
    99                          ; HBC-56 TMS9918 Console update
   100                          ; -----------------------------------------------------------------------------
   101                          .consoleVsyncCallback:
   102                          
   103                                  lda HBC56_TICKS
   104                                  beq .doCursor
   105                                  cmp #30
   106                                  beq .doCursor
   107                                  jmp @endConsoleCallback
   108                          
   109                          .doCursor:
   110                                  stx HBC56_TMP_X
   111                                  sty HBC56_TMP_Y
   112                                  jsr tmsSetPosConsole
   113                                  ldx HBC56_TMP_X
   114                                  ldy HBC56_TMP_Y
   115                                  lda HBC56_TICKS
   116                                  beq +
   117                                  lda #' '
   118                                  +tmsPut
   119                                  jmp @endConsoleCallback
   120                          + 
   121                                  lda #$7f
   122                                  +tmsPut
   123                          
   124                          @endConsoleCallback
   125                          
   126                          .nullCallbackFunction:
   127                                  rts
   128                          }

; ******** Source: kernel.asm
   184                          
   185                          ; -----------------------------------------------------------------------------
   186                          ; HBC-56 Main entry point (reset vector)
   187                          ; -----------------------------------------------------------------------------
   188                          kernelMain:
   189  f1a1 78                         sei
   190  f1a2 d8                         cld     ; make sure we're not in decimal mode
   191  f1a3 a2ff                       ldx #$ff
   192  f1a5 9a                         txs
   193                                  
   194  f1a6 a940                       lda #RTI_OPCODE
   195  f1a8 8d007e                     sta HBC56_INT_VECTOR
   196  f1ab 8d047e                     sta HBC56_NMI_VECTOR
   197                          
   198  f1ae a210a920ca9d9d7c...        +memset HBC56_META_TITLE, ' ', HBC56_META_TITLE_MAX_LEN
   199                          
   200  f1ba a900                       lda #0
   201  f1bc 8d967c                     sta HBC56_TICKS
   202  f1bf 8d977c                     sta HBC56_SECONDS_L
   203  f1c2 8d987c                     sta HBC56_SECONDS_H
   204  f1c5 8d9a7c                     sta HBC56_CONSOLE_FLAGS
   205                          
   206  f1c8 8dad7c                     sta HBC56_META_TITLE + HBC56_META_TITLE_MAX_LEN
   207                          
   208                          
   209  f1cb 20fcdf                     jsr HBC56_META_VECTOR   ; user program metadata
   210                          
   211                                  !ifdef HAVE_KEYBOARD {
   212  f1ce 20d1ea                             jsr kbInit
   213                                  }
   214                          
   215                                  !ifdef HAVE_AY3891X {
   216  f1d1 2050e1                             jsr ayInit
   217                                  }
   218                          
   219                                  !ifdef HAVE_SFXMAN {
   220                                          jsr sfxManInit  ; requires TMS interrupts
   221                                  }
   222                          
   223                                  !ifdef HAVE_TMS9918 {
   224                                          jsr tmsInit
   225                          
   226                                          ; dummy callback
   227                                          +hbc56SetVsyncCallback .nullCallbackFunction
   228                                  }
   229                          
   230                                  !ifdef HAVE_LCD {
   231  f1d4 202fe6                             jsr lcdDetect
   232  f1d7 900c                               bcc @noLcd1                
   233  f1d9 20dee5                             jsr lcdInit
   234  f1dc 20e1ff                             jsr hbc56Delay
   235  f1df 2002e6                             jsr lcdDisplayOn
   236  f1e2 20e1ff                             jsr hbc56Delay
   237                          @noLcd1:
   238                                  }
   239                          
   240  f1e5 2000f1                     jsr hbc56BootScreen
   241                          
   242  f1e8 a9858d017ea9f18d...        +setIntHandler hbc56IntHandler
   243                          
   244                                  !ifdef HAVE_TMS9918 {
   245                                          +tmsEnableOutput
   246                                          +tmsDisableInterrupts
   247                                  }
   248                          
   249  f1f7 a914                       lda #20
   250  f1f9 8d997c                     sta HBC56_TMP
   251                          -
   252  f1fc 20e1ff                     jsr hbc56Delay
   253  f1ff ce997c                     dec HBC56_TMP
   254  f202 d0f8                       bne -
   255                                 
   256                                  !ifdef HAVE_TMS9918 {
   257                                          +tmsEnableInterrupts
   258                                  }
   259  f204 58                         cli
   260                          
   261  f205 2061f2                     jsr hbc56HighBell
   262                          
   263  f208 a910                       lda #HBC56_CONSOLE_FLAG_NOWAIT
   264  f20a 2c9a7c                     bit HBC56_CONSOLE_FLAGS
   265  f20d d042                       bne .afterInput
   266                          
   267  f20f a940                       lda #HBC56_CONSOLE_FLAG_NES
   268  f211 2d9a7c                     and HBC56_CONSOLE_FLAGS
   269  f214 f01f                       beq .keyboardInput
   270                          
   271                          
   272                                  ; NES input
   273  f216 78                         sei
   274                                  !ifdef HAVE_TMS9918 {
   275                                          +tmsPrintZ .HBC56_PRESS_ANY_NES_TEXT, (32 - .HBC56_PRESS_ANY_NES_TEXT_LEN) / 2, 17
   276                                  }
   277                          
   278                                  !ifdef HAVE_LCD {
   279  f217 202fe6                             jsr lcdDetect
   280  f21a 9012                               bcc @noLcd2
   281                                          !ifdef HAVE_GRAPHICS_LCD {
   282  f21c a200bdb6ed9d607a...                        +memcpy TILEMAP_DEFAULT_BUFFER_ADDRESS + 16*6, .HBC56_PRESS_ANY_NES_TEXT, 16
   283  f229 a006                                       ldy #6
   284  f22b 2056e9                                     jsr tilemapRenderRowToLcd
   285                                          } else {
   286                                                  lda #<.HBC56_PRESS_ANY_NES_TEXT
   287                                                  sta STR_ADDR_L
   288                                                  lda #>.HBC56_PRESS_ANY_NES_TEXT
   289                                                  sta STR_ADDR_H
   290                                                  jsr lcdPrint
   291                                          }
   292                          @noLcd2:
   293                                  }
   294  f22e 58                         cli
   295  f22f 20b4ea                     jsr nesWaitForPress
   296  f232 4c51f2                     jmp .afterInput
   297                          
   298                          .keyboardInput
   299                          !ifdef HAVE_KEYBOARD {
   300                                  ; Keyboard  input
   301  f235 78                         sei
   302                                  !ifdef HAVE_TMS9918 {
   303                                          +tmsPrintZ .HBC56_PRESS_ANY_KEY_TEXT, (32 - .HBC56_PRESS_ANY_KEY_TEXT_LEN) / 2, 17
   304                                  }
   305                          
   306                                  !ifdef HAVE_LCD {
   307  f236 202fe6                             jsr lcdDetect
   308  f239 9012                               bcc @noLcd3
   309                                          !ifdef HAVE_GRAPHICS_LCD {
   310  f23b a200bda5ed9d607a...                        +memcpy TILEMAP_DEFAULT_BUFFER_ADDRESS + 16*6, .HBC56_PRESS_ANY_KEY_TEXT, 16
   311  f248 a006                                       ldy #6
   312  f24a 2056e9                                     jsr tilemapRenderRowToLcd
   313                                          } else {
   314                                                  lda #<.HBC56_PRESS_ANY_KEY_TEXT
   315                                                  sta STR_ADDR_L
   316                                                  lda #>.HBC56_PRESS_ANY_KEY_TEXT
   317                                                  sta STR_ADDR_H
   318                                                  jsr lcdPrint        
   319                                          }
   320                          @noLcd3:
   321                                  }
   322  f24d 58                         cli
   323  f24e 2012ec                     jsr kbWaitForScancode
   324                          }
   325                          
   326                          .afterInput
   327                          
   328                                  !ifdef HAVE_LCD {
   329                                          ;jsr lcdDetect
   330                                          ;bcc @noLcd4
   331  f251 20dee5                             jsr lcdInit
   332                                          !ifdef HAVE_GRAPHICS_LCD {
   333  f254 202be5                                     jsr lcdTextMode
   334                                          }
   335  f257 20f0e5                             jsr lcdClear
   336  f25a 20f9e5                             jsr lcdHome
   337                          @noLcd4:
   338                                  }
   339                          
   340                                  !ifdef HAVE_TMS9918 {
   341                                          jsr tmsInitTextTable ; clear output
   342                                          +tmsDisableOutput
   343                                          +tmsDisableInterrupts
   344                                  }
   345                                  ; no interrupts until the user code says so
   346  f25d 78                         sei
   347                          
   348  f25e 200080                     jsr DEFAULT_HBC56_RST_VECTOR
   349                          
   350                          ; -----------------------------------------------------------------------------
   351                          ; Beep (higher tone)
   352                          ; -----------------------------------------------------------------------------
   353                          hbc56HighBell:
   354                                  !ifdef HAVE_AY3891X {
   355  f261 a9078d407fad427f...                +ayToneEnable AY_PSG0, AY_CHC
   356  f273 a90a8d407fa90f8d...                +aySetVolume AY_PSG0, AY_CHC, $ff
   357  f27d a9048d407fa9598d...                +ayPlayNote AY_PSG0, AY_CHC, NOTE_FREQ_F5
   358                                  }
   359  f291 8032                       bra .noteTimeout
   360                          
   361                          ; -----------------------------------------------------------------------------
   362                          ; Beep (lower tone)
   363                          ; -----------------------------------------------------------------------------
   364                          hbc56Bell:
   365                                  !ifdef HAVE_AY3891X {
   366  f293 a9078d407fad427f...                +ayToneEnable AY_PSG0, AY_CHC
   367  f2a5 a90a8d407fa90f8d...                +aySetVolume AY_PSG0, AY_CHC, $ff
   368  f2af a9048d407fa97b8d...                +ayPlayNote AY_PSG0, AY_CHC, NOTE_FREQ_E3
   369                                  }
   370  f2c3 8000                       bra .noteTimeout
   371                          
   372                          .noteTimeout
   373                                  !ifdef HAVE_SFXMAN {
   374                                          lda HBC56_CONSOLE_FLAGS
   375                                          and #HBC56_CONSOLE_FLAG_LCD
   376                                          bne @skipSfxMan
   377                                          +sfxManSetChannelTimeout  AY_PSG0, AY_CHC, 0.16
   378                                          rts
   379                                  }
   380                          @skipSfxMan
   381                                  !ifdef HAVE_AY3891X {
   382  f2c5 20e1ff                             jsr hbc56Delay
   383  f2c8 20e1ff                             jsr hbc56Delay
   384  f2cb a9048d407fa9008d...                +ayStop AY_PSG0, AY_CHC
   385                                  }
   386                          
   387  f2df 60                         rts
   388                          
   389                          ; -----------------------------------------------------------------------------
   390                          ; Software reset
   391                          ; -----------------------------------------------------------------------------
   392                          hbc56Reset:
   393  f2e0 4ca1f1                     jmp kernelMain
   394                          
   395                          ; -----------------------------------------------------------------------------
   396                          ; Stop (loop forever)
   397                          ; -----------------------------------------------------------------------------
   398                          hbc56Stop:
   399  f2e3 4ce3f2                     jmp hbc56Stop
   400                          
   401                          ; -----------------------------------------------------------------------------
   402                          ; Delay function
   403                          ; -----------------------------------------------------------------------------
   404                          hbc56CustomDelayMs:
   405  f2e6 e633                       inc DELAY_H
   406                          -
   407  f2e8 a003                       ldy #3
   408  f2ea 20e3ff                     jsr hbc56CustomDelay
   409  f2ed c632                       dec DELAY_L
   410  f2ef d0f7                       bne -
   411  f2f1 a900                       lda #0
   412  f2f3 8532                       sta DELAY_L
   413  f2f5 c633                       dec DELAY_H
   414  f2f7 d0ef                       bne -
   415  f2f9 60                         rts
   416                          
   417                          
   418                          ;!warn "Kernel size: ", *-$f000
